#' mathScore
#' @description calculates MATH score of each tumor sample or based on Mutant-Allele Tumor Heterogeneity (MATH) approach.
#' 
#' @references Mroz, Edmund A. et al. Intra-Tumor Genetic Heterogeneity and Mortality in Head and Neck Cancer: Analysis of Data from The Cancer Genome Atlas. Ed. Andrew H. Beck. PLoS Medicine 12.2 (2015): e1001786.
#' 
#' @param maf Maf or MafList object generated by \code{\link{readMaf}} function.
#' @param patient.id Select the specific patients. Default NULL, all patients are included.
#' @param withinTumor Calculate between-region heterogeneity within tumor. (Default FALSE).
#' @param min.vaf The minimum VAF for filtering variants. Default 0.
#' @param use.adjVAF Use adjusted VAF in analysis when adjusted VAF or CCF is available. Default FALSE. 
#' @param use.tumorSampleLabel Logical (Default: FALSE). 
#' Rename the 'Tumor_Sample_Barcode' by 'Tumor_Sample_Label'.
#' @param ... Other options passed to \code{\link{subMaf}}
#' @return A data.frame of MATH scores
#' 
#' @examples
#' maf.File <- system.file("extdata/", "HCC_LDC.maf", package = "MesKit")
#' clin.File <- system.file("extdata/", "HCC_LDC.clin.txt", package = "MesKit")
#' ccf.File <- system.file("extdata/", "HCC_LDC.ccf.tsv", package = "MesKit")
#' maf <- readMaf(mafFile=maf.File, clinicalFile = clin.File, ccfFile=ccf.File, refBuild="hg19")
#' mathScore(maf)
#' 
#' @importFrom stats median
#' @export mathScore

## MATH Score main function
mathScore <- function(maf,
                      patient.id = NULL,
                      withinTumor = FALSE,
                      min.vaf = 0,
                      use.adjVAF = TRUE,
                      use.tumorSampleLabel = FALSE,
                      ...
                      ){
    ## select subclonal mutation when withinTumor is TRUE
    if(withinTumor){
        clonalStatus <- "Subclonal"
    }else{
        clonalStatus <- NULL
    }
    
    maf <- subMaf(maf, min.vaf = min.vaf, use.adjVAF = use.adjVAF, clonalStatus = clonalStatus, mafObj = TRUE, ...)
    
    ## check input data
    maf_list <- checkMafInput(maf, patient.id = patient.id)


    processMATH <- function(m, clonalStatus){
        patient <- getMafPatient(m)
        maf_data <- getMafData(m)
        if(nrow(maf_data) == 0){
            message("Warning: there was no mutation in ", patient, " after filtering.")
            return(NA)
        }
        
        if(use.tumorSampleLabel){
            if(!"Tumor_Sample_Label" %in% colnames(maf_data)){
                stop("Tumor_Sample_Label was not found. Please check clinical data or let use.tumorSampleLabel be 'FALSE'")
            }
            maf_data <- maf_data %>% 
                dplyr::mutate(Tumor_Sample_Barcode = .data$Tumor_Sample_Label)
        }
        
        ## MATH Caculation
        calMATH <- function(VAF){
            VAF = VAF[!is.na(VAF)] 
            
            MAD <- 1.4826 * stats::median(abs(VAF - stats::median(VAF)))
            MATH <- 100 * MAD / stats::median(VAF)
            return(round(MATH, digits=3))
        }
        
        if(withinTumor){
            if(! "CCF" %in% colnames(maf_data)){
                stop(paste0("Calculation of MATH score requires CCF data when withinTumor is TRUE."))
            }
            
            MATH.df <- maf_data %>% 
                dplyr::group_by(.data$Patient_ID, .data$Tumor_ID) %>%
                dplyr::summarise(MATH_Score = calMATH(.data$Tumor_Average_VAF)) %>%
                dplyr::ungroup() %>% 
                as.data.frame()
        }
        else{
            MATH.df <- maf_data %>%
                dplyr::group_by(.data$Patient_ID, .data$Tumor_Sample_Barcode) %>%
                dplyr::summarise(MATH_Score = calMATH(.data$VAF)) %>%
                dplyr::ungroup() %>% 
                as.data.frame()
        }
        return(MATH.df)
    }
    
    MATH_list <- lapply(maf_list, processMATH, clonalStatus)
    result <- MATH_list[!is.na(MATH_list)]
    # result <- dplyr::bind_rows(MATH_list)
    
    #y.limits <- c(
        #floor(min(MATH.df$MATH_Score)-15),
        #ceiling(max(MATH.df$MATH_Score)+15)
        ##ifelse(max(MATH.df$MATH_Score)+15 >100, 100, max(MATH.df$MATH_Score)+15)
    #)
    
    # # violin plot
    # if(plot){
    #     p <- ggplot(MATH.df, aes(x=as.factor(Patient_ID), y=MATH_Score, fill = Patient_ID)) + 
    #         geom_violin() + theme_bw() +     
    #         #ylim(y.limits) + 
    #         theme(legend.title = element_blank(),
    #         legend.text = element_text(size = 11),
    #         legend.key.size = unit(0.4, "cm"),
    #         panel.border = element_blank(), 
    #         panel.grid.major = element_line(linetype = 2, color = "grey"),
    #         panel.grid.minor = element_blank(),
    #         axis.line=element_line(color= "black", size= 1),
    #         axis.line.y = element_blank(),
    #         #axis.line.y = element_line(size=0.5, colour = "black"),
    #         #axis.ticks.y = element_line(size=0.5, colour = "black"),
    #         axis.line.x = element_blank(),
    #         axis.title = element_text(size = 12),
    #         axis.ticks.x = element_blank(),
    #         axis.text.x = element_text(size = 11, color = "black", angle = 90),
    #         axis.text.y = element_text(size = 11, color = "black")) + 
    #         scale_y_continuous(limits = y.limits, expand = c(0,0),
    #             breaks = round(seq(y.limits[1], y.limits[2], length = 5)))+
    #         #scale_y_continuous(breaks = c(y.limits[1], 40, 50, 60, 70, 80, 90, y.limits[2]), 
    #                            #limits = y.limits, labels = c(y.limits[1], 40,50,60,70,80,90,y.limits[2]),
    #                            #expand = c(0,0)) +
    #         scale_x_discrete(limits = levels(MATH.df$Patient_ID)) +
    #         labs(y = "MATH score", x = "") +
    #         annotate("segment", x = 0, xend = 0, y = y.limits[1], yend = y.limits[2], size = 0.6)      
    # }else{
    #     p <- NULL
    # }
    # 
    # return(list(MATH.df = MATH.df, MATH.plot = p))  
    if(length(result) == 0){
        return(NA)
    }
    return(result)   
    
}