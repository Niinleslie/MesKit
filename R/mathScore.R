#' mathScore
#' @description calculates MATH score of each tumor sample or based on Mutant-Allele Tumor Heterogeneity (MATH) approach.
#' 
#' @references Mroz, Edmund A. et al. Intra-Tumor Genetic Heterogeneity and Mortality in Head and Neck Cancer: Analysis of Data from The Cancer Genome Atlas. Ed. Andrew H. Beck. PLoS Medicine 12.2 (2015): e1001786.
#' 
#' @param maf Maf or MafList object generated by readMaf.
#' @param patient.id Select the specific patients. Default: NULL, all patients are included.
#' @param withinTumor Calculate AUC within types in each patients. Default :FALSE.
#' @param min.vaf The minimum VAF for filtering variants. Default: 0.02 
#' @param ... Other options passed to \code{\link{subsetMaf}}
#' @return a data.frame of MATH scores
#' 
#' @examples
#' mathScore(maf)
#' @export mathScore

## MATH Score main function
mathScore <- function(maf,
                      patient.id = NULL, 
                      withinTumor = FALSE,  
                      min.vaf = 0.02,
                      ...
                      ){
    
    ## check input data
    maf_list <- checkMafInput(maf, patient.id = patient.id)
    
    ## select subclonal mutation when withinTumor is TRUE
    if(withinTumor){
        clonalStatus <- "Subclonal"
    }else{
        clonalStatus <- NULL
    }
    
    MATH_list <- list()
    for(m in maf_list){
        maf_data <- subsetMaf(m,min.vaf = min.vaf,clonalStatus = clonalStatus,...)
        
        patient <- getMafPatient(m)
        if(nrow(maf_data) == 0){
            message("Warning :there was no mutation in ", patient, " after filter.")
            next
        }

        ## MATH Caculation
        calMATH <- function(VAF){
            VAF = VAF[!is.na(VAF)] 
            
            MAD <- 1.4826 * median(abs(VAF - median(VAF)))
            MATH <- 100 * MAD / median(VAF)
            return(round(MATH, digits=3))
        }
        
        if(withinTumor){
            if(! "CCF" %in% colnames(maf_data)){
                stop(paste0("Errors. Calculation of MATH score requires CCF data when withinTumor is TRUE." ,
                            "No CCF data was found when generate Maf object with readMaf function"))
            }
            
            MATH.df <- maf_data %>% 
                dplyr::group_by(Patient_ID, Tumor_ID) %>%
                dplyr::summarise(MATH_Score = calMATH(Tumor_Average_VAF)) %>%
                dplyr::ungroup() %>% 
                as.data.frame()
        }
        else{
            MATH.df <- maf_data %>%
                dplyr::group_by(Patient_ID, Tumor_Sample_Barcode) %>%
                dplyr::summarise(MATH_Score = calMATH(VAF)) %>%
                dplyr::ungroup() %>% 
                as.data.frame()
        }
        MATH_list[[patient]] <- MATH.df
    }
    result <- plyr::rbind.fill(MATH_list)
    #y.limits <- c(
        #floor(min(MATH.df$MATH_Score)-15),
        #ceiling(max(MATH.df$MATH_Score)+15)
        ##ifelse(max(MATH.df$MATH_Score)+15 >100, 100, max(MATH.df$MATH_Score)+15)
    #)
    
    # # violin plot
    # if(plot){
    #     p <- ggplot(MATH.df, aes(x=as.factor(Patient_ID), y=MATH_Score, fill = Patient_ID)) + 
    #         geom_violin() + theme_bw() +     
    #         #ylim(y.limits) + 
    #         theme(legend.title = element_blank(),
    #         legend.text = element_text(size = 11),
    #         legend.key.size = unit(0.4, "cm"),
    #         panel.border = element_blank(), 
    #         panel.grid.major = element_line(linetype = 2, color = "grey"),
    #         panel.grid.minor = element_blank(),
    #         axis.line=element_line(color= "black", size= 1),
    #         axis.line.y = element_blank(),
    #         #axis.line.y = element_line(size=0.5, colour = "black"),
    #         #axis.ticks.y = element_line(size=0.5, colour = "black"),
    #         axis.line.x = element_blank(),
    #         axis.title = element_text(size = 12),
    #         axis.ticks.x = element_blank(),
    #         axis.text.x = element_text(size = 11, color = "black", angle = 90),
    #         axis.text.y = element_text(size = 11, color = "black")) + 
    #         scale_y_continuous(limits = y.limits, expand = c(0,0),
    #             breaks = round(seq(y.limits[1], y.limits[2], length = 5)))+
    #         #scale_y_continuous(breaks = c(y.limits[1], 40, 50, 60, 70, 80, 90, y.limits[2]), 
    #                            #limits = y.limits, labels = c(y.limits[1], 40,50,60,70,80,90,y.limits[2]),
    #                            #expand = c(0,0)) +
    #         scale_x_discrete(limits = levels(MATH.df$Patient_ID)) +
    #         labs(y = "MATH score", x = "") +
    #         annotate("segment", x = 0, xend = 0, y = y.limits[1], yend = y.limits[2], size = 0.6)      
    # }else{
    #     p <- NULL
    # }
    # 
    # return(list(MATH.df = MATH.df, MATH.plot = p))  
    if(length(result) == 0){
        return(NA)
    }
    return(result)   
    
}