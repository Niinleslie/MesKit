#' A Multifunctional MATH Calculator
#' @description Calculate MATH score and present results in different ways 
#' determined by parameters. VAF can be on the scale 0-1 and you could filter 
#' VAF with minvaf and maxvaf.
#' 
#' @param maf the classMaf object generated by readMaf.
#' @param tsb specify excute ITH asessment for single or all samples from the same patient(Tumor_Sample_Barcodes) 
#' @param minvaf filter low frequency variants caused by sequencing error. Default 0. (on the scale of 0 to 1)
#' @param maxvaf filter high frequency variants due to copy number alterations or impure tumor. Default 1. (on the scale of 0 to 1)
#' @return MATH score list for all/selected samples or a MATH score value.
#' 
#' @examples
#' mathScore(maf, tsb=c("All"), minvaf=0.02, maxvaf=1)
#' ## generate MATH score for specific tsbs
#' mathScore(maf, tsb=c("SRR3670035"))
#' 
#' @export mathScore
#' 

## MATH Score main function
mathScore <- function(maf, tsb=c("All"), minvaf=0.02, maxvaf=1){
    ## get vaf-related infomation
    mafData <- maf@data
    dataHugoSymbol <- mafData$Hugo_Symbol
    dataVaf <- mafData$VAF
    dataTsb <- data.frame(mafData$Tumor_Sample_Barcode)
    vafInputMt <- data.frame(dataHugoSymbol, dataVaf, dataTsb)
    colnames(vafInputMt) <- c("Hugo_Symbol", "VAF", "Tumor_Sample_Barcode")
    ## get all sample names
    tsbLs <- data.frame(unique(vafInputMt$Tumor_Sample_Barcode))
    
    ## MATH results for one/all sample
    if (any(tsb == c("All"))){
        ## list all samples' MATH scores
        mathOFA <- .multiSampleMATH(vafInputMt, tsbLs, minvaf, maxvaf)
        colnames(mathOFA) <- c("Tumor_Sample_Barcode", "MATH_score", 
                               "TMB(mutations/Mb)")
        mathResult <- list(sampleLevel=mathOFA)
        return(mathResult)
    } else{
        ## calculate specific samples' MATH score
        tsbLs <- data.frame(tsb)
        mathSp <- .multiSampleMATH(vafInputMt, tsbLs, minvaf, maxvaf)
        colnames(mathSp) <- c("Tumor_Sample_Barcode", "MATH_score", 
                              "TMB(mutations/Mb)")
        mathResult <- list(sampleLevel=mathSp)
        return(mathResult)
    }
    message("MATH Score Calculation Done!")
}


## Data cleaning
.dataClean <- function(vafInputMt, tsb, minvaf, maxvaf){
    vafColumnMATH <- vafInputMt[which(
        vafInputMt$Tumor_Sample_Barcode == tsb), ]$VAF
    vafColumnMATH <- vafColumnMATH[which(
        !is.na(vafColumnMATH))][which(
            vafColumnMATH > minvaf & vafColumnMATH < maxvaf)]
    vafColumnMATH <- as.numeric(
        as.character(vafColumnMATH))[which(!is.na(vafColumnMATH))]
    return(vafColumnMATH)
}

## MATH Caculation
.calMATH <- function(vafColumnMATH){
    MAD <- 1.4826*median(abs(vafColumnMATH - median(vafColumnMATH)))
    MATH <- 100 * MAD / median(vafColumnMATH)
    return(round(MATH, digits=3))
}

## Tumor burden Caculation
.calTumorBurden <- function(vafColumnMATH){
    tumorBurden <- length(vafColumnMATH)/40
    return(tumorBurden)
}

## MATH multi-sample process
.multiSampleMATH <- function(vafInputMt, tsbLs, minvaf, maxvaf){
    samplesMATH <- data.frame()
    for (counter in seq_along(tsbLs[,1])){
        for (sampleNameMt in tsbLs){
            vafColumnMATH <- .dataClean(
                vafInputMt, 
                as.character(sampleNameMt)[counter], 
                minvaf, maxvaf)
            sampleMATH <- data.frame(
                as.character(sampleNameMt)[counter], 
                .calMATH(vafColumnMATH), .calTumorBurden(vafColumnMATH))
            samplesMATH <- rbind(samplesMATH, sampleMATH)
        }
    }
    colnames(samplesMATH) <- c("Tumor_Sample_Barcode", "MATH_score", 
                               "Tumor_Burden")
    return(samplesMATH)
}

# ## MATH patient calcualtion
# .patientMATH <- function(vafInputMt, tsbLs, minvaf, maxvaf){
#     vafColumnMATH <- vafInputMt$VAF
#     tsbNum <- nrow(tsbLs)
#     vafColumnMATH <- vafColumnMATH[which(
#         !is.na(vafColumnMATH))][which(
#             vafColumnMATH > minvaf & vafColumnMATH < maxvaf)]
#     vafColumnMATH <- as.numeric(
#         as.character(vafColumnMATH))[which(
#             !is.na(vafColumnMATH))]
#     result <- data.frame(MATH_score=.calMATH(vafColumnMATH), 
#                          Tumor_Burden=length(vafColumnMATH)/40/tsbNum)
#     return(result)
# }
