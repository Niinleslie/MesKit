#' mathScore
#' @description calculates MATH score of each tumor sample or based on Mutant-Allele Tumor Heterogeneity (MATH) approach.
#' 
#' @references Mroz, Edmund A. et al. Intra-Tumor Genetic Heterogeneity and Mortality in Head and Neck Cancer: Analysis of Data from The Cancer Genome Atlas. Ed. Andrew H. Beck. PLoS Medicine 12.2 (2015): e1001786.
#' 
#' @param maf a Maf object generated by readMaf.
#' @param patient.id select the specific patients. Default: NULL, all patients are included.
#' @param chrSilent Select chromosomes needed to be dismissed. Default NULL.
#' @param mutType select Proper variant classification you need. Default "All". Option: "nonSilent".
#' @param use.indel Logical value. Whether to use INDELs besides somatic SNVs. Default: TRUE.
#' @param min.vaf the minimum VAF for filtering variants. Default: 0.02 
#' @param withinTumor calculate AUC within types in each patients.Default :FALSE.
#' @param use.adjVAF calculate MATH score by adjusted VAF.Default: FALSE. 
#' @return a data.table of MATH scores
#' 
#' @examples
#' mathScore(maf, min.vaf = 0.02)
#' @export mathScore

## MATH Score main function
mathScore <- function(maf, 
                      chrSilent = NULL,
                      mutType = "All",
                      use.indel = TRUE,
                      patient.id = NULL, min.vaf=0.02,
                      withinTumor = FALSE, use.adjVAF = FALSE){
    
    ## select subclonal mutation when withinTumor is TRUE
    if(withinTumor){
        clonalStatus <- "Subclonal"
    }else{
        clonalStatus <- NULL
    }
    maf <- subsetMaf(maf,
                     patient.id = patient.id,
                     chrSilent = chrSilent,
                     mutType = mutType,
                     use.indel = use.indel,
                     min.vaf = min.vaf,
                     clonalStatus = clonalStatus)
    mafData <- maf@data
    
    if(use.adjVAF){
        if(!"VAF_adj" %in% colnames(mafData)){
            stop("Adjusted VAF was not found in maf data.")
        }
        else{
            mafData <- mafData %>% 
                dplyr::mutate(VAF = VAF_adj) %>% 
                dplyr::mutate(Tumor_Average_VAF = Tumor_Average_VAF_adj)
        }
    }


    ## MATH Caculation
    calMATH <- function(VAF){
    VAF = VAF[!is.na(VAF)] 
       
    MAD <- 1.4826*median(abs(VAF - median(VAF)))
    MATH <- 100 * MAD / median(VAF)
    return(round(MATH, digits=3))
    }

    if(withinTumor){
        if(! "CCF" %in% colnames(mafData)){
            stop(paste0("Errors. Calculation of MATH score requires CCF data when withinTumor is TRUE." ,
                        "No CCF data was found when generate Maf object with readMaf function"))
        }
        
        MATH.dt <- mafData %>% 
            dplyr::group_by(Patient_ID, Tumor_ID) %>%
            dplyr::summarise(MATH_Score = calMATH(Tumor_Average_VAF)) %>%
            dplyr::ungroup()
    }
    else{
        MATH.dt <- mafData %>%
            dplyr::group_by(Patient_ID, Tumor_Sample_Barcode) %>%
            dplyr::summarise(MATH_Score = calMATH(VAF)) %>%
            dplyr::ungroup()
    }

    #y.limits <- c(
        #floor(min(MATH.df$MATH_Score)-15),
        #ceiling(max(MATH.df$MATH_Score)+15)
        ##ifelse(max(MATH.df$MATH_Score)+15 >100, 100, max(MATH.df$MATH_Score)+15)
    #)
    
    # # violin plot
    # if(plot){
    #     p <- ggplot(MATH.df, aes(x=as.factor(Patient_ID), y=MATH_Score, fill = Patient_ID)) + 
    #         geom_violin() + theme_bw() +     
    #         #ylim(y.limits) + 
    #         theme(legend.title = element_blank(),
    #         legend.text = element_text(size = 11),
    #         legend.key.size = unit(0.4, "cm"),
    #         panel.border = element_blank(), 
    #         panel.grid.major = element_line(linetype = 2, color = "grey"),
    #         panel.grid.minor = element_blank(),
    #         axis.line=element_line(color= "black", size= 1),
    #         axis.line.y = element_blank(),
    #         #axis.line.y = element_line(size=0.5, colour = "black"),
    #         #axis.ticks.y = element_line(size=0.5, colour = "black"),
    #         axis.line.x = element_blank(),
    #         axis.title = element_text(size = 12),
    #         axis.ticks.x = element_blank(),
    #         axis.text.x = element_text(size = 11, color = "black", angle = 90),
    #         axis.text.y = element_text(size = 11, color = "black")) + 
    #         scale_y_continuous(limits = y.limits, expand = c(0,0),
    #             breaks = round(seq(y.limits[1], y.limits[2], length = 5)))+
    #         #scale_y_continuous(breaks = c(y.limits[1], 40, 50, 60, 70, 80, 90, y.limits[2]), 
    #                            #limits = y.limits, labels = c(y.limits[1], 40,50,60,70,80,90,y.limits[2]),
    #                            #expand = c(0,0)) +
    #         scale_x_discrete(limits = levels(MATH.df$Patient_ID)) +
    #         labs(y = "MATH score", x = "") +
    #         annotate("segment", x = 0, xend = 0, y = y.limits[1], yend = y.limits[2], size = 0.6)      
    # }else{
    #     p <- NULL
    # }
    # 
    # return(list(MATH.df = MATH.df, MATH.plot = p))  
    
    return(as.data.frame(MATH.dt) )   
    
}