#' calJSI
#'
#' @description The Jaccard similarity coefficient is defined as the ratio of shared variants to all
#' (shared plus discordant) variants for two samples.
#'
#' @param maf a Maf object generated by readMaf function
#' @param plot logical, default TRUE
#' @param use.circle, default FALSE
#'
#' @examples
#' calJSI(maf)
#' @return correlation matrix via Jaccard similarity coefficient method
#' @export calJSI


calJSI <- function(maf, plot = TRUE, use.circle = FALSE) {
        dat <- maf@data
        TSBs <- unique(dat$Tumor_Sample_Barcode)
        
        variants.list <- list()
        for (tsb in TSBs) {
            dat.tsb <- dat[which(dat$Tumor_Sample_Barcode == tsb), ]
            variants.list[[tsb]] <-
                paste(
                    dat.tsb$Hugo_Symbol,
                    dat.tsb$Chromosome,
                    dat.tsb$Start_Position,
                    dat.tsb$Variant_Type,
                    dat.tsb$Reference_Allele,
                    dat.tsb$Tumor_Seq_Allele2,
                    sep = ":"
                )
        }
        
        Jaccard.mat <-
            diag(1, nrow = length(TSBs), ncol = length(TSBs))
        colnames(Jaccard.mat) <- TSBs
        rownames(Jaccard.mat) <- TSBs
        
        for (i in 1:(length(TSBs) - 1)) {
            for (j in (i + 1):length(TSBs)) {
                variants.i <- unlist(variants.list[TSBs[[i]]])
                variants.j <- unlist(variants.list[TSBs[[j]]])
                
                Jaccard.mat[i, j] <-
                    length(intersect(variants.i, variants.j)) / length(union(variants.i, variants.j))
                
                Jaccard.mat[j, i] <- Jaccard.mat[i, j]
            }
        }
        
        if(plot){
            plotCorr(Jaccard.mat)
        }
        return(Jaccard.mat)
}

