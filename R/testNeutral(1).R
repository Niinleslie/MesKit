#' testNeutral
#' @description Evaluat whether a tumor follows neutral evolution or under strong selection
#' during the growth based on variant frequency distribution (VAF) of subclonal 
#' The subclonal mutant allele frequencies of a follow a simple power-law distribution predicted by neutral growth.  
#' 
#' @references Williams MJ, Werner B, Barnes CP, Graham TA, Sottoriva A. Identification of neutral tumor evolution across cancer types. 
#' Nat Genet. 2016;48(3):238â€“244. doi:10.1038/ng.3489
#' 
#' @param maf the Maf object generated by readMaf
#' @param patient.id select the specific patients. Default: NULL, all patients are included
#' @param min.depth the minimun depth of coverage. Defalut: 10
#' @param R2.threshold the threshod of R2 to decide whether a tumor follows neutral evolution. Default: 0.98
#' @param min.VAF_adj the minimum value of adjusted VAF value (1/2CCF). Default: 0.1
#' @param max.VAF_adj the maximum value of adjusted VAF value (1/2CCF). Default: 0.3
#' @param min.mut.count the minimun number of subclonal mutations used to fit model. Default: 30
#' @param plot logical, whether to print model fitting plot of each sample. Default: TRUE
#' 
#' @examples
#' testNeutral(maf)
#' @export testNeutral

testPowerLaw <- function(
    df, 
    min.vaf, 
    max.vaf, 
    min.depth,
    R2.threshold,
    min.mut.count,
    plot){

	subPowerLaw <- function(
    sample.df,
    min.vaf,
    max.vaf,
    min.depth,
    R2.threshold,
    min.mut.count,
    plot){

	    sample.id <- unique(sample.df$Tumor_Sample_Barcode)
	    sample.df <- sample.df %>%
	        dplyr::filter(
	            Status == "Subclonal" & 
	                Ref_allele_depth + Alt_allele_depth > min.depth &
	                VAF_adj > min.VAF_adj &
	                VAF_adj < max.VAF_adj &
	                !is.na(VAF_adj)
	        )  

		if(nrow(sample.df) < min.mut.count){
			R2.out = data.frame()
            vaf.plot  = NA

			warning(paste0("Sample ", sample.id, ": There is no enough eligible mutations can be used."))
		}else{
		    vaf <- sample.df$VAF_adj
			# max.vaf <- max(sample.df$VAF_adj)
			# min.vaf <- min(sample.df$VAF_adj)
			# 
			## get cumulative distribution 
			
			# breaks = ceiling((max.vaf - min.vaf)/0.005)
			# vafCount =  hist(1/sample.df$VAF_adj, breaks = breaks, plot = F)
			# vafCumsum <- data.frame(inv_f = vafCount$breaks, count = c(0,cumsum(vafCount$counts)))
			
			breaks <- seq(max.VAF_adj, min.VAF_adj, -0.005)
			mut.count <- sapply(breaks,function(x,vaf){sum(vaf > x)},vaf = vaf)
			vafCumsum <- data.frame(count = mut.count, f = breaks)
			vafCumsum$inv_f <- 1/vafCumsum$f - 1/max.VAF_adj
			vafCumsum$n_count <- vafCumsum$count/max(vafCumsum)
			vafCumsum$t_count <- vafCumsum$inv_f/(1/min.VAF_adj - 1/max.VAF_adj)
			
			## area of theoretical curve
			theoryA <- pracma::trapz(vafCumsum$inv_f, vafCumsum$t_count)
			# area of emprical curve
			dataA <- pracma::trapz(vafCumsum$inv_f, vafCumsum$n_count)
			# Take absolute difference between the two
			area <- abs(theoryA - dataA)
			# Normalize so that metric is invariant to chosen limits
			area<- area / (1 / min.VAF_adj - 1 / max.VAF_adj)
			
			
			## calculate mean distance
			meandist <- mean(abs(vafCumsum$n_count - vafCumsum$t_count))
			
			## calculate kolmogorovdist 
			n = length(vaf)
			cdfs <- 1 - ((1/sort(vaf) - 1/max.VAF_adj) /(1/min.VAF_adj - 1/max.VAF_adj))
			dp <- max((1:n) / n - cdfs)
			dn <- - min((0:(n-1)) / n - cdfs)
			kolmogorovdist  <- max(c(dn, dp))

			## R squared
			lmModel <- lm(vafCumsum$count ~ vafCumsum$inv_f + 0)
      		lmLine = summary(lmModel)
      		R2 = lmLine$adj.r.squared
      		
          R2.out <- data.frame(
            Tumor_Sample_Barcode = sample.id,
            Eligible_Mut_Count = nrow(sample.df ),
            Area = area,
            Kolmogorov_Distance = kolmogorovdist,
            Mean_distance = meandist,
            R2 = R2, 
            Type = dplyr::if_else(
              R2 >= R2.threshold,
              "neutral",
              "non-neutral"),
            patient = as.character(unique(sample.df$Patient_ID)) 
            )
      vaf.plot <- NA 
      if(plot){
        Arealabel <- as.character(paste0('italic(Area == )', area))
        KDlabel <- as.character(paste0('italic(KD == )', kolmogorovdist))
        Mdlabel <- as.character(paste0('italic(MD == )', meandist))
        R2label <- as.character(paste0(
                                       #  'Area == ', area,'\n',
                                       # ' Kolmogorov_Distance == ', kolmogorovdist, '\n',
                                       # 'Mean_distance == ', meandist, '\n',
                                       'italic(R)^2 == ', R2))
        x.min <- min(vafCumsum$f)
        x.max <- max(vafCumsum$f)
        x.breaks <- seq(x.min,x.max,(x.max-x.min)/2)
        x.breaks.pos <- 1/x.breaks - 1/max.VAF_adj
        x.breaks.label <- paste("1/", round(x.breaks,2),sep="")
        y.min <- min(vafCumsum$count)
        y.max <- max(vafCumsum$count,
                     (max(vafCumsum$inv_f)*lmModel$coefficients[1]))
      	vaf.plot <- ggplot(data = vafCumsum, mapping = aes(x = inv_f, y = count)) +
      		      geom_point()+
      		      geom_smooth(method=lm,formula = y ~ x + 0, color="red",se = FALSE)+
      		      theme(panel.grid =element_blank(),
      		            panel.border = element_blank(),
      		            panel.background = element_blank(),
      		            axis.line = element_blank(),
      		            axis.ticks = element_line(size = 1),
      		            axis.title = element_text(size = 13,face = "bold",colour = "black"),
      		            axis.text = element_text(size = 10,face = "bold",colour = "black"),
      		            axis.ticks.length = unit(.25, "cm"))+
      		    geom_segment(aes(x = min(inv_f),xend= max(inv_f), y=-Inf,yend=-Inf), size = 1)+
      		    geom_segment(aes(y = y.min ,yend = y.max,x=-Inf,xend=-Inf), size = 1.5)+
      		    scale_x_continuous(breaks = x.breaks.pos,
      		                        labels = x.breaks.label)+
      		    scale_y_continuous(breaks = seq(y.min,y.max,(y.max-y.min)/4),
      		                        labels = round(seq(y.min,y.max,(y.max-y.min)/4)))+
      		                        # labels = c(round(y.min),
      		                        #            round(y.min+(y.max-y.min)/4),
      		                        #            round(y.min+(y.max-y.min)*2/4),
      		                        #            round(y.max)))+
      		    xlab("Inverse allelic frequency 1/vaf")+
      		    ylab("Cumulative number of SSNVs")+
      	        annotate("text",
      	             x = quantile(vafCumsum$inv_f)[2],
      	             y = y.max,
      	             label = Arealabel,
      	             size = 4,
      	             fontface = "bold",
      	             parse = TRUE)+
      	       annotate("text",
      	             x = quantile(vafCumsum$inv_f)[2],
      	             y = y.max*0.95,
      	             label = KDlabel,
      	             size = 4,
      	             fontface = "bold",
      	             parse = TRUE)+
      	    annotate("text",
      	             x = quantile(vafCumsum$inv_f)[2],
      	             y = y.max*0.9,
      	             label = Mdlabel,
      	             size = 4,
      	             fontface = "bold",
      	             parse = TRUE)+
      		    annotate("text",
      		              x = quantile(vafCumsum$inv_f)[2],
      		              y = y.max*0.85,
      		              label = R2label,
      		              size = 4,
                        fontface = "bold",
                        parse = TRUE)

      		}
	      
		}
	
		return(list(model.fitting.out = R2.out, model.fitting.plot = vaf.plot))		
	}
	
	
	patient.R2 <- df %>%
	    dplyr::group_by(Tumor_Sample_Barcode) %>%
	    dplyr::group_map(~subPowerLaw(.,
	          min.vaf,
	          max.vaf,
	          min.depth,
	          R2.threshold,
	          plot,
	          min.mut.count = min.mut.count), 
	          keep = TRUE) %>%
	    rlang::set_names(unique(df$Tumor_Sample_Barcode))

  return(patient.R2)       
   #return(list(data.frame = neutralTest.out, plot.list = patient.plot))    	
}


testNeutral <- function(maf, patient.id = NULL, 
    min.depth = 10, R2.threshold = 0.98,
    min.VAF_adj = 0.1, max.VAF_adj = 0.3,
    min.mut.count = 30,
    plot = TRUE){
	
	mafData <- maf@data

    if(! "CCF" %in% colnames(mafData)){
        stop(paste0("Error: inferring whether a tumor follows neutral evolution requires CCF data.",
            "No CCF data was found when generate Maf object."))
    }

    if(is.null(patient.id)){
        patient.id = unique(mafData$Patient_ID)
    }else{
        patient.setdiff <- setdiff(patient.id, unique(mafData$Patient_ID))
        if(length(patient.setdiff) > 0){
            stop(paste0("Patient ", patient.setdiff, " can not be found in your data"))
        }
    }


	neutrality.list <- mafData %>%
	    dplyr::group_by(Patient_ID) %>%
	    dplyr::group_map(~testPowerLaw(.,
	        min.vaf, 
	        max.vaf, 
	        min.depth, 
	        R2.threshold, 
	        min.mut.count,
	        plot), 
	        keep = TRUE) %>%
	    rlang::set_names(unique(mafData$Patient_ID))    	
	
	testNeutral.out = list(
	    neutrality.metrics = lapply(neutrality.list, 
	                                function(x) do.call(rbind, lapply(x, function(y) y$model.fitting.out))
	    ),
	    model.fitting.plot = lapply(neutrality.list, 
	                                function(x) lapply(x, function(y) y$model.fitting.plot))
	)
	if(plot & length(patient.id)!=1){
	    violin.data <- do.call(rbind.fill,testNeutral.out$neutrality.metrics)
	    p.violin <- ggplot(data = violin.data,aes(x = patient, y = R2, fill = patient))+
	        geom_violin(trim=FALSE,color="white")+
	        geom_boxplot(width=0.05,position=position_dodge(0.9))+
	        geom_hline(yintercept = R2.threshold,linetype = 2)+
	        theme_bw() + 
	        ylim(0,1)+
	        theme(axis.text.x=element_text(hjust = 0.5,size=10), 
	              axis.text.y=element_text(size=10), 
	              axis.title.y=element_text(size = 15), 
	              axis.title.x=element_blank(), 
	              panel.border = element_blank(),axis.line = element_line(colour = "black",size=1),
	              legend.text=element_text( colour="black", size=10),
	              legend.title= element_blank(),
	              panel.grid.major = element_blank(),  
	              panel.grid.minor = element_blank())+  
	        ## color scales
	        scale_fill_manual(values = c( "#E64B35B2","#4DBBD5B2","#00A087B2","#3C5488B2","#F39B7FB2",
	                                      "#8491B4B2","#91D1C2B2","#DC0000B2","#7E6148B2","#91D1C2B2",
	                                      "#1B9E77","#D95F02","#7570B3","#E7298A","#66A61E","#E6AB02","#A6761D","#666666"))
	    testNeutral.out$R2.fit.plot <- p.violin
	    
	}

    return(testNeutral.out)
}



