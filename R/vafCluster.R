#' vafCluster
#' @description Generate variant allele frequency(VAF) frequency distribution
#'  curve in different mode.
#'  
#' @param maf a Maf object generated by readMaf function
#' @param seg a segment object generated by readSegment function.
#' @param minVaf the minimum value of VAF. Default: 0. Option: on the scale of 0 to 1
#' @param maxVaf the maximum value of VAF. Default: 0. Option: on the scale of 0 to 1
#' @param showMATH logical. Whether to show MATH Scores in the plot. Default TRUE 
#' @param plotOption character. Three options for displaying clustering of VAFs in samples. Default "compare"
#' "compare": prints comparison of VAFs distribution among samples;
#' "combine" prints VAFs distribution of samples all together;
#' "separate" prints VAFs distribution for each tumor sample separately
#' 
#' @examples
#' vafCluster(maf, plotOption="compare")
#' vafCluster(maf, plotOption="combine", showMATH=FALSE)
#' vafCluster(maf, plotOption="separate")
#' 
#'
#' @export vafCluster
#' @export vafClusterRshiny
#' 

## Main function for VAF plot
vafCluster <-function(maf, seg = NULL,
                      minVaf=0.02, maxVaf=1, showMATH=TRUE, 
                      plotOption="combine"){
  ## original data preparation
  ## read .maf file
  mafDat <- maf@data
  if (max(mafDat$VAF, na.rm=TRUE) > 1){
    mafDat$VAF <- mafDat$VAF/100
  }
  patientID <- maf@patientID
  
  ## fileter by minVaf and maxVaf
  mafDat <- mafDat[which(
    !is.na(mafDat$VAF)), ][which(
      mafDat$VAF > minVaf & mafDat$VAF < maxVaf), ]
  ## Ignoring variants in copy number altered regions
  if(!is.null(seg)){
    maf@data <- mafDat
    maf <- MesKit::copyNumberFilter(maf, seg)
  }
  ## extract vaf info
  n <- length(mafDat$Hugo_Symbol)
  vafInputMt <- data.frame(mafDat$Hugo_Symbol, 
                           mafDat$VAF, 
                           mafDat$Tumor_Sample_Barcode)
  colnames(vafInputMt) <- c("Hugo_Symbol", "VAF", "Samples")
  clusterAll <- data.frame()
  ## extract all tumor sample barcode
  tsbLs <- data.frame(unique(vafInputMt$Samples))
  colnames(tsbLs) <- c("samples")
  
  
  # build color vector for later use
  colorVector <- c("#3B4992FF", "#EE0000FF", "#008B45FF", "#631879FF", 
                   "#008280FF", "#BB0021FF", "#5F559BFF", "#A20056FF", 
                   "#808180FF", "#1B1919FF")
  
  
  ## plot all samples' vaf distribution
  if ((plotOption == "separate") | (plotOption == "combine")){
    ## general data process for all samples 
    lsPicName <- c()
    lsSep <- list()
    lsSampleName <- c()
    for (counterMt in seq_along(tsbLs[,1])){
      sampleName <- as.character(tsbLs[,1][counterMt])
      ## calculate ScoreMATH
      mathscore <- .mathCal(maf, minVaf, maxVaf, showMATH, plotOption, sampleName)
      sampleMt <- vafInputMt[which(
        vafInputMt$Samples %in% sampleName),]
      ## data cleaning
      sampleMt <- sampleMt[complete.cases(sampleMt), ]
      sampleMt <- sampleMt[which(sampleMt$VAF != 0),]
      if (length(sampleMt[,1]) < 3) {
        message(paste("Sample ", sampleName, " has too few mutaions",sep = ""))
        next()
      }
      
      ## infer possible cluster from mafDat
      clusterMt <- .clusterGenerator(mafDat, sampleName)
      clusterMt <- clusterMt[which(clusterMt$Tumor_Sample_Barcode == sampleName), ]
      
      ## separate: print VAF pictures for all samples separatively
      if (plotOption == "separate"){
        pic <- .drawVAF(clusterMt, sampleName, mathscore)
        lsSep[[counterMt]] <- pic
        lsSampleName <- c(lsSampleName,sampleName)
      }
      else {
        # prepare separated pictures for later combination 
        pic_cha <- paste("separate", ".", counterMt, 
                         "<-.drawVAF(clusterMt, ", 
                         "sampleName, mathscore, ", 
                         "MIXOption=plotOption)", sep="")
        eval(parse(text=pic_cha))
        pic_name <- paste("separate", ".", counterMt, sep="")
        lsPicName <- c(lsPicName, pic_name)
      }
    }
    if (plotOption == "separate"){
      names(lsSep) <- lsSampleName
      message(paste("VAF Plot(", plotOption, ") Generation Done!", sep=""))
      return(lsSep)
    }
    ## combine: print VAF pictures for all samples in one document
    if (plotOption == "combine"){
      if (showMATH){
        mathtbscoreLs <- .mathCal(maf, minVaf, maxVaf, showMATH, "compare", sampleName)
        
        ## set the columns of the picture and generate all single pictures
        combineTitle <- cowplot::ggdraw() + 
          cowplot::draw_label(
            paste("VAF clustering of ", patientID, sep=""),
            fontface = 'bold',
            x = 0,
            hjust = 0
          ) +
          theme(
            # add margin on the left of the drawing canvas,
            # so title is aligned with left edge of first plot
            plot.margin = margin(0, 0, 0, 7)
          )
        pic <- eval(parse(text=paste("cowplot::plot_grid(", 
                                     paste(lsPicName, collapse=","), 
                                     ", nrow=", 
                                     ceiling(length(lsPicName)/2), 
                                     ", ncol=2, align=\"v\")" , 
                                     sep="")))
        pic <- cowplot::plot_grid(
          combineTitle, pic,
          ncol = 1,
          # rel_heights values control vertical title margins
          rel_heights = c(0.1, 1))
        
      } else {
        pic <- eval(parse(text=paste("cowplot::plot_grid(", 
                                     paste(lsPicName, collapse=","), 
                                     ", nrow=", 
                                     ceiling(length(lsPicName)/2), 
                                     ", ncol=2, align=\"v\")" , 
                                     sep="")))
      }
      message(paste("VAF Plot(", plotOption, ") Generation Done!", sep=""))
      return(suppressWarnings(suppressMessages(pic)))
    }
  }
  
  ## plot all samples' vaf distribution with ggridges
  else if (plotOption == "compare"){
    ## calculate ScoreMATH
    mathtbscoreLs <- .mathCal(maf, minVaf, maxVaf, showMATH, plotOption)
    mathscore <- mathtbscoreLs$sampleLevel
    ## collect all samples' cluster results
    for (counterMt in seq_along(tsbLs[,1])){
      sampleName <- as.character(tsbLs[,1][counterMt])
      sampleMt <- vafInputMt[which(
        vafInputMt$Samples %in% sampleName),]
      ## data cleaning
      sampleMt <- sampleMt[complete.cases(sampleMt), ]
      sampleMt <- sampleMt[which(sampleMt$VAF != 0),]
      if (nrow(sampleMt) < 3) {
        message(paste("Sample ", sampleName, " has too few mutaions",sep = ""))
        next()
      }
      ## generate data from different Tumor_Sample_Barcode
      clusterMtCha <- paste("clusterMt_", counterMt, 
                            " <- .clusterGenerator(mafDat, sampleName)", sep ="")
      eval(parse(text=clusterMtCha))
      clusterMtCha <- paste("clusterMt_", counterMt, "$MATH", 
                            " <- rep(mathscore[which(mathscore$Tumor_Sample_Barcode == sampleName), ]$MATH_score, nrow(clusterMt_", counterMt, "))", sep ="")
      eval(parse(text=clusterMtCha))
      clusterMtCha <- paste("clusterAll <- rbind(clusterAll, ", 
                            "clusterMt_", counterMt, ")",sep ="")
      eval(parse(text=clusterMtCha))
    }
    # mathscore <- mathtbscoreLs$patientLevel$MATH_score
    pic <- suppressMessages(eval(parse(text=.ofaVAF(clusterAll, 
                                                    tsbLs, plotOption, 
                                                    mathscore, patientID, 
                                                    minVaf, maxVaf))))
    message(paste("VAF Plot(", plotOption, ") Generation Done!", sep=""))
    return(suppressWarnings(suppressMessages(pic)))
  }
  
  ## plot specific sample's vaf plot
  else if (plotOption %in% unique(vafInputMt$Samples))
  {
    ## data preparation
    sampleName <- plotOption
    sampleMt <- vafInputMt[which(vafInputMt$Samples %in% plotOption),]
    ## data cleaning
    sampleMt <- sampleMt[complete.cases(sampleMt), ]
    sampleMt <- sampleMt[which(sampleMt$VAF != 0),]
    if (length(sampleMt[,1]) < 3) {
      stop(paste("Sample ", sampleName, " has too few mutaions",sep = ""))
    }
    clusterMt <- .clusterGenerator(mafDat, sampleName)
    ## calculate ScoreMATH
    mathscore <- .mathCal(maf, minVaf, maxVaf, showMATH, plotOption, sampleName)
    ## VAF plot for specifc sample
    pic <- .drawVAF(clusterMt, plotOption, mathscore)
    message(paste("VAF Plot(", plotOption, ") Generation Done!", sep=""))
    return(suppressWarnings(suppressMessages(pic)))
  }
  else {
    stop("ERROR: plotOption settings failure.")
  }
}


## Special version of vafCluster for Rshiny App
vafClusterRshiny <-function(maf, seg = NULL, minVaf=0.02, maxVaf=1, showMATH=TRUE, 
                            plotOption="combine"){
  ## original data preparation
  ## read .maf file
  mafDat <- maf@data
  if (max(mafDat$VAF, na.rm=TRUE) > 1){
    mafDat$VAF <- mafDat$VAF/100
  }
  patientID <- maf@patientID
  
  ## fileter by minVaf and maxVaf
  mafDat <- mafDat[which(
    !is.na(mafDat$VAF)), ][which(
      mafDat$VAF > minVaf & mafDat$VAF < maxVaf), ]
  
  ## Ignoring variants in copy number altered regions
  if(!is.null(seg)){
    maf@data <- mafDat
    maf <- MesKit::copyNumberFilter(maf, seg)
  }
  ## extract vaf info
  n <- length(mafDat$Hugo_Symbol)
  vafInputMt <- data.frame(mafDat$Hugo_Symbol, 
                           mafDat$VAF, 
                           mafDat$Tumor_Sample_Barcode)
  colnames(vafInputMt) <- c("Hugo_Symbol", "VAF", "Samples")
  clusterAll <- data.frame()
  ## extract all tumor sample barcode
  tsbLs <- data.frame(unique(vafInputMt$Samples))
  colnames(tsbLs) <- c("samples")
  
  # build color vector for later use
  colorVector <- c("#3B4992FF", "#EE0000FF", "#008B45FF", "#631879FF", 
                   "#008280FF", "#BB0021FF", "#5F559BFF", "#A20056FF", 
                   "#808180FF", "#1B1919FF")
  
  ## plot all samples' vaf distribution
  if ((plotOption == "separate") | (plotOption == "combine")){
    ## general data process for all samples 
    lsPicName <- c()
    lsSep <- list()
    lsSampleName <- c()
    for (counterMt in seq_along(tsbLs[,1])){
      ## Rshiny: progress bar
      incProgress(amount=1)
      setProgress(message = paste('Processing', ' sample ', as.character(tsbLs[,1][counterMt])))
      
      sampleName <- as.character(tsbLs[,1][counterMt])
      ## calculate ScoreMATH
      mathscore <- .mathCal(maf, minVaf, maxVaf, showMATH, plotOption, sampleName)
      sampleMt <- vafInputMt[which(
        vafInputMt$Samples %in% sampleName),]
      ## data cleaning
      sampleMt <- sampleMt[complete.cases(sampleMt), ]
      sampleMt <- sampleMt[which(sampleMt$VAF != 0),]
      if (length(sampleMt[,1]) < 3) {
        message(paste("Sample ", sampleName, " has too few mutaions",sep = ""))
        next()
      }
      
      ## infer possible cluster from mafDat
      clusterMt <- .clusterGenerator(mafDat, sampleName)
      clusterMt <- clusterMt[which(clusterMt$Tumor_Sample_Barcode == sampleName), ]
      
      ## separate: print VAF pictures for all samples separatively
      if (plotOption == "separate"){
        pic <- .drawVAF(clusterMt, sampleName, mathscore)
        lsSep[[counterMt]] <- pic
        lsSampleName <- c(lsSampleName,sampleName)
      }
      else {
        # prepare separated pictures for later combination 
        pic_cha <- paste("separate", ".", counterMt, 
                         "<-.drawVAF(clusterMt, ", 
                         "sampleName, mathscore, ", 
                         "MIXOption=plotOption)", sep="")
        eval(parse(text=pic_cha))
        pic_name <- paste("separate", ".", counterMt, sep="")
        lsPicName <- c(lsPicName, pic_name)
      }
    }
    if (plotOption == "separate"){
      names(lsSep) <- lsSampleName
      message(paste("VAF Plot(", plotOption, ") Generation Done!", sep=""))
      return(lsSep)
    }
    ## combine: print VAF pictures for all samples in one document
    if (plotOption == "combine"){
      if (showMATH){
        mathtbscoreLs <- .mathCal(maf, minVaf, maxVaf, showMATH, "compare", sampleName)
        
        ## set the columns of the picture and generate all single pictures
        combineTitle <- cowplot::ggdraw() + 
          cowplot::draw_label(
            paste("VAF clustering of ", patientID, sep=""),
            fontface = 'bold',
            x = 0,
            hjust = 0
          ) +
          theme(
            # add margin on the left of the drawing canvas,
            # so title is aligned with left edge of first plot
            plot.margin = margin(0, 0, 0, 7)
          )
        pic <- eval(parse(text=paste("cowplot::plot_grid(", 
                                     paste(lsPicName, collapse=","), 
                                     ", nrow=", 
                                     ceiling(length(lsPicName)/2), 
                                     ", ncol=2, align=\"v\")" , 
                                     sep="")))
        pic <- cowplot::plot_grid(
          combineTitle, pic,
          ncol = 1,
          # rel_heights values control vertical title margins
          rel_heights = c(0.1, 1))
        
      } else {
        pic <- eval(parse(text=paste("cowplot::plot_grid(", 
                                     paste(lsPicName, collapse=","), 
                                     ", nrow=", 
                                     ceiling(length(lsPicName)/2), 
                                     ", ncol=2, align=\"v\")" , 
                                     sep="")))
      }
      ## Rshiny: progress bar
      incProgress(amount=1)
      setProgress(message = paste('Generating ', "VAF density plot - ", plotOption, " mode", sep=""))
      message(paste("VAF Plot(", plotOption, ") Generation Done!", sep=""))
      return(suppressWarnings(suppressMessages(pic)))
    }
  }
  
  ## plot all samples' vaf distribution with ggridges
  else if (plotOption == "compare"){
    ## calculate MATH score
    mathtbscoreLs <- .mathCal(maf, minVaf, maxVaf, showMATH, plotOption)
    mathscore <- mathtbscoreLs$sampleLevel
    ## collect all samples' cluster results
    for (counterMt in seq_along(tsbLs[,1])){
      ## Rshiny: progress bar
      incProgress(amount=1)
      setProgress(message = paste('Processing', ' sample ', as.character(tsbLs[,1][counterMt])))
      
      sampleName <- as.character(tsbLs[,1][counterMt])
      sampleMt <- vafInputMt[which(
        vafInputMt$Samples %in% sampleName),]
      ## data cleaning
      sampleMt <- sampleMt[complete.cases(sampleMt), ]
      sampleMt <- sampleMt[which(sampleMt$VAF != 0),]
      if (nrow(sampleMt) < 3) {
        message(paste("Sample ", sampleName, " has too few mutaions",sep = ""))
        next()
      }
      ## generate data from different Tumor_Sample_Barcode
      clusterMtCha <- paste("clusterMt_", counterMt, 
                            " <- .clusterGenerator(mafDat, sampleName)", sep ="")
      eval(parse(text=clusterMtCha))
      clusterMtCha <- paste("clusterMt_", counterMt, "$MATH", 
                            " <- rep(mathscore[which(mathscore$Tumor_Sample_Barcode == sampleName), ]$MATH_score, nrow(clusterMt_", counterMt, "))", sep ="")
      eval(parse(text=clusterMtCha))
      clusterMtCha <- paste("clusterAll <- rbind(clusterAll, ", 
                            "clusterMt_", counterMt, ")",sep ="")
      eval(parse(text=clusterMtCha))
    }
    # mathscore <- mathtbscoreLs$patientLevel$MATH_score
    pic <- suppressMessages(eval(parse(text=.ofaVAF(clusterAll, 
                                                    tsbLs, plotOption, 
                                                    mathscore, patientID, 
                                                    minVaf, maxVaf))))
    ## Rshiny: progress bar
    incProgress(amount=1)
    setProgress(message = paste('Generating ', "VAF density plot - ", plotOption, " mode", sep=""))
    message(paste("VAF Plot(", plotOption, ") Generation Done!", sep=""))
    return(suppressWarnings(suppressMessages(pic)))
  }
  
  ## plot specific sample's vaf plot
  else if (plotOption %in% unique(vafInputMt$Samples))
  {
    ## data preparation
    sampleName <- plotOption
    sampleMt <- vafInputMt[which(vafInputMt$Samples %in% plotOption),]
    ## data cleaning
    sampleMt <- sampleMt[complete.cases(sampleMt), ]
    sampleMt <- sampleMt[which(sampleMt$VAF != 0),]
    if (length(sampleMt[,1]) < 3) {
      stop(paste("Sample ", sampleName, " has too few mutaions",sep = ""))
    }
    clusterMt <- .clusterGenerator(mafDat, sampleName)
    ## calculate ScoreMATH
    mathscore <- .mathCal(maf, minVaf, maxVaf, showMATH, plotOption)
    ## VAF plot for specifc sample
    mathscore <- .mathCal(maf, minVaf, maxVaf, showMATH, plotOption, plotOption)
    message(paste("VAF Plot(", plotOption, ") Generation Done!", sep=""))
    return(suppressWarnings(suppressMessages(pic)))
  }
  else {
    stop("ERROR: plotOption settings failure.")
  }
  
}


## Functions for all plotOption
## Calculate ScoreMATH
.mathCal <- function(maf, minVaf, maxVaf, showMATH=TRUE, 
                     plotOption, sampleName = ""){
  if (showMATH){
    if ((plotOption == "separate") | (plotOption == "combine")){
      mathtbscoreLs <- mathScore(maf, c(sampleName), minvaf=minVaf, maxvaf=maxVaf)
      mathtbscore <- mathtbscoreLs$sampleLevel
      mathscore <- mathtbscore[which(
        mathtbscore$Tumor_Sample_Barcode == sampleName), 
        ]$MATH_score
    }
    else if (plotOption == "compare"){
      mathtbscoreLs <- mathScore(maf, NULL, minvaf=minVaf, maxvaf=maxVaf)
      mathscore <- mathtbscoreLs
    }
    else if (plotOption %in% unique(maf@data$Tumor_Sample_Barcode)) {
      mathtbscoreLs <- mathScore(maf, c(sampleName), minvaf=minVaf, maxvaf=maxVaf)
      mathtbscore <- mathtbscoreLs$sampleLevel
      mathscore <- mathtbscore[which(
        mathtbscore$Tumor_Sample_Barcode == plotOption), 
        ]$MATH_score
    } else {
      stop("ERROR: plotOption setting error")
    }
  } else {
    mathscore <- NULL
  }
  return(mathscore)
}

.clusterGenerator <- function(mafDat, sampleName){
  ## refine part
  Mt <- mclust::densityMclust(mafDat$VAF, G=1:7, verbose=FALSE)
  clusterMt <- as.data.frame(mafDat)
  clusterMt$cluster <- as.character(Mt[["classification"]])
  ## 
  message(paste("Processing sample ", sampleName, sep = ""))
  return(clusterMt)
}


## Functions for specific plotOption: "separate", "combine", "tsb"
## VAF painter
.drawVAF <- function(clusterMt, 
                     plotOption, mathscore, 
                     MIXOption=""){
  ## A draft for density infomation(density_info) of ggplot
  picv <- ggplot(clusterMt, aes(x=VAF)) + 
    geom_line(size=1, colour="#00C0EB", stat="density")
  
  # build color vector for later use
  colorVector <- c("#3B4992FF", "#EE0000FF", "#008B45FF", "#631879FF", 
                   "#008280FF", "#BB0021FF", "#5F559BFF", "#A20056FF", 
                   "#808180FF", "#1B1919FF")
  
  if (is.null(mathscore)){
    if (MIXOption == "combine"){
      ## generate cha for ggplot and specific titles for minifigures
      vafDrawCha <- paste("ggplot(clusterMt, aes(x=VAF)) + 
                          theme_bw() + 
                          theme(legend.position=\'none\',", 
                          " title=element_text(size=10), ", 
                          "text=element_text(size=10), ", 
                          "panel.grid=element_blank(), ", 
                          "panel.border=element_blank(), ", 
                          "axis.line=element_line(size=0.25)) + ", 
                          "geom_line(size=1, colour=\"#00C0EB\", ", 
                          "stat=\"density\") + ", 
                          "geom_rug(aes(y=0, colour=cluster), sides=\"b\") + ", 
                          .vlineVAF(clusterMt, picv, 
                                    tsb_ls, plotOption),
                          "geom_rug(aes(y=0, colour=cluster), sides=\"b\") + ",
                          "scale_colour_manual(values=colorVector)", sep="")
      
    } else {
      ## generate character/string for ggplot and paint the picture
      vafDrawCha <- paste("ggplot(clusterMt, aes(x=VAF)) + 
                          theme_bw() + 
                          theme(title=element_text(size=16), ", 
                          "text=element_text(size=16), ", 
                          "panel.grid=element_blank(), ", 
                          "panel.border=element_blank(), ", 
                          "axis.line=element_line(size=0.25)) + ", 
                          "geom_line(size=1, colour=\"#00C0EB\", ", 
                          "stat=\"density\") + ", 
                          .vlineVAF(clusterMt, picv, 
                                    tsb_ls, plotOption),
                          "geom_rug(aes(y=0, colour=cluster), sides=\"b\") + ",
                          "scale_colour_manual(values=colorVector)", sep="")
    } 
  }
  else {
    if (MIXOption == "combine"){
      ## generate cha for ggplot and specific titles for minifigures
      vafDrawCha <- paste("ggplot(clusterMt, aes(x=VAF)) + 
                          theme_bw() + 
                          theme(legend.position=\'none\', ", 
                          "plot.title=element_text(size=10, hjust=1, ", 
                          "vjust=0.5, face='bold'), ", 
                          "title=element_text(size=10), ", 
                          "text=element_text(size=10), ", 
                          "panel.grid=element_blank(), ", 
                          "panel.border=element_blank(), ", 
                          "axis.line=element_line(size=0.25)) + ", 
                          "ggtitle(\"", plotOption, 
                          "\'s MATH Score: ", as.character(mathscore), 
                          "\") + ", 
                          "geom_line(size=1, colour=\"#00C0EB\", ", 
                          "stat=\"density\") + ", 
                          .vlineVAF(clusterMt, picv, 
                                    tsb_ls, plotOption),
                          "geom_rug(aes(y=0, colour=cluster), sides=\"b\") + ",
                          "scale_colour_manual(values=colorVector)", sep="")
    } else {
      ## generate character/string for ggplot and paint the picture
      vafDrawCha <- paste("ggplot(clusterMt, aes(x=VAF)) + 
                          theme_bw() + 
                          theme(plot.title=element_text(size=16, hjust=1, ", 
                          "vjust=0.5, face='bold'), ", 
                          "title=element_text(size=16), ",
                          "text=element_text(size=18), ", 
                          "panel.grid=element_blank(), ", 
                          "panel.border=element_blank(), ", 
                          "axis.line=element_line(size=0.25)) + ",  
                          "ggtitle(\"MATH Score: ", 
                          as.character(mathscore), "\") + ", 
                          "geom_line(size=1, colour=\"#00C0EB\", ", 
                          "stat=\"density\") + ", 
                          .vlineVAF(clusterMt, picv, 
                                    tsb_ls, plotOption),
                          "geom_rug(aes(y=0, colour=cluster), sides=\"b\") + ",
                          "scale_colour_manual(values=colorVector)", sep="")
    }
  }
  return(eval(parse(text=vafDrawCha)))
}


## Draw vlines for all plotOption
.vlineVAF <- function(clusterMt, pic, 
                      tsbLs, plotOption, 
                      tsb, ingredients=NULL)
{
  ## data prepare
  vafVlineCha <- ""
  clusterLs <- unique(clusterMt$cluster)
  ## density information of the curve for a tsb
  densityInfo <- data.frame(layer_data(pic))

  
  ## OFA specific: get scaling ratio
  if (!is.null(ingredients)){
    iscale <- ingredients$iscale[1]
    scale <- ingredients$scale[1]
  }
  
  ## Obtain vline Coordinate(x, xend, y, yend)
  for (cluster_name in clusterLs){
    x_end <- max(clusterMt[which(
      clusterMt$cluster == cluster_name), ]$VAF)
    x_end_alter <- densityInfo$x[which.min(
      abs(outer(densityInfo$x,x_end,FUN="-")))]
    y_end <- densityInfo$y[which(
      densityInfo$x == x_end_alter)]
    if (plotOption == "compare"){
      ## Scale and draw lines
      density <- densityInfo$density[which(
        densityInfo$x == x_end_alter)]
      vafVlineCha <- paste(
        vafVlineCha, 
        "geom_segment(data=clusterMt_", which(tsbLs == tsb), 
        " ,aes(x=", x_end_alter, 
        ", xend=", x_end_alter, 
        ", y=", which(tsbLs == tsb), 
        ", yend=", which(tsbLs == tsb) + density*iscale*scale, "), ", 
        "size=0.5, colour=\"grey\", linetype=\"dashed\") + ",sep="")
    }else{
      vafVlineCha <- paste(
        vafVlineCha, 
        "geom_segment(aes(x=", x_end_alter,", xend=", x_end_alter, 
        ", y=0, yend=", y_end,"), ", 
        "size=0.5, colour=\"grey\", linetype=\"dashed\") + ",sep="")
    }
  }
  vafVlineCha
}

## Functions for specific plotOption: "compare"
## VAF painter for OFA
.ofaVAF <- function(clusterAll, tsbLs, 
                    plotOption, mathscore, patientID, 
                    minVaf, maxVaf){
  
  # build color vector for later use
  colorVector <- c("#3B4992FF", "#EE0000FF", "#008B45FF", "#631879FF", 
                   "#008280FF", "#BB0021FF", "#5F559BFF", "#A20056FF", 
                   "#808180FF", "#1B1919FF")
  
  if (is.null(mathscore)){
    vafOFACha <- paste("ggplot(clusterAll, ", 
                       "aes(x=VAF, y=Tumor_Sample_Barcode)) +
                       theme_bw() + 
                       theme(title=element_text(size=16), ", 
                       "text=element_text(size=18), ", 
                       "panel.grid=element_blank(), ", 
                       "panel.border=element_blank(), ",
                       "axis.title=element_text(size=16), ", 
                       "axis.text=element_text(size=12), ", 
                       "axis.line=element_line(size=0.25)) + ",
                       "ggridges::geom_density_ridges(fill=\"whitesmoke\", ",
                       "calc_ecdf=TRUE, alpha=0.5) + ",
                       "geom_point(aes(x=VAF, ", 
                       "y=Tumor_Sample_Barcode, ", 
                       "color=cluster), ", 
                       "alpha=0.5, show.legend=FALSE) + ", 
                       "ggridges::geom_density_ridges(color=\"#00C0EB\", ", 
                       "fill=NA, calc_ecdf=TRUE, alpha=0.5, size=1) + ", 
                       .ofaVlineVAF(clusterAll, tsbLs, plotOption),  
                       "scale_colour_manual(values=colorVector) + ",
                       "labs(y = \"Sample\") + ", 
                       "scale_x_continuous(limits = ", "c(", as.character(minVaf), ",", as.character(maxVaf), "))", sep="")
  } else {
    vafOFACha <- paste("ggplot(clusterAll, ", 
                       "aes(x=VAF, y=Tumor_Sample_Barcode)) +
                       theme_bw() + 
                       theme(plot.title=element_text(size=16, hjust=1, ", 
                       "vjust=0.5, face='bold'), ", 
                       "title=element_text(size=16), ", 
                       "text=element_text(size=18), ", 
                       "panel.grid=element_blank(), ", 
                       "panel.border=element_blank(), ", 
                       "axis.title=element_text(size=16), ", 
                       "axis.text=element_text(size=12), ", 
                       "axis.line=element_line(size=0.25)) + ", 
                       "ggtitle(\"VAF clustering of ", patientID, "\") + ", 
                       "ggridges::geom_density_ridges(fill=\"whitesmoke\", ", 
                       "calc_ecdf=TRUE, alpha=0.5) + ",
                       "geom_point(aes(x=VAF, ", 
                       "y=Tumor_Sample_Barcode, ", 
                       "color=cluster), ", 
                       "alpha=0.5, show.legend=FALSE) + ", 
                       "ggridges::geom_density_ridges(color=\"#00C0EB\", ", 
                       "fill=NA, calc_ecdf=TRUE, alpha=0.5, size=1) + ",
                       .ofaVlineVAF(clusterAll, tsbLs, plotOption), 
                       "scale_colour_manual(values=colorVector) + ", 
                       "labs(y = \"Sample\") + ", 
                       "geom_text(data=cbind(clusterAll %>% dplyr::group_by(Tumor_Sample_Barcode) %>% dplyr::summarise(), 
                       MATH=unique(clusterAll$MATH), 
                       VAF=(clusterAll %>% dplyr::group_by(Tumor_Sample_Barcode) %>% dplyr::summarise(VAF=max(VAF)))$VAF),
                       aes(x=0.85*max(VAF), label=paste(\"MATH Score: \", sprintf(\"%1.3f\", MATH), sep=\"\")), 
                       position=position_nudge(y=0.5), colour=\"black\", size=3.5) + ", 
                       "scale_x_continuous(limits = ", "c(", as.character(minVaf), ",", as.character(maxVaf), "))", sep="")
  }
  vafOFACha
}


## VAF draw vlines for ofa
.ofaVlineVAF <- function(clusterAll, tsbLs, 
                         plotOption)
{
  ## data prepare
  .ofaVlineVAF <- ""
  ## density information of the curve for all tsbs
  gr <- ggplot(clusterAll, aes(x=VAF, y=Tumor_Sample_Barcode)) + 
    ggridges::geom_density_ridges() 
  ingredients <- ggplot_build(gr) %>% purrr::pluck("data", 1)
  
  for (tsb in tsbLs$samples)
  {
    ## renew tsb's data
    VAFVlineCha <- ""
    xEndLs <- data.frame()
    yEndLs <- data.frame()
    clusterMt <- clusterAll[which(
      clusterAll$Tumor_Sample_Barcode == tsb), ]
    clusterLs <- unique(clusterMt$cluster)
    ## A draft for density infomation(density_info) of ggplot
    picv <- ggplot(clusterMt, aes(x=VAF)) + 
      geom_line(size=1, colour="#00C0EB", stat="density")
    densityInfo <- data.frame(layer_data(picv))
    ## collect vlines for a single tsb
    VAFVlineCha <- .vlineVAF(clusterMt, picv, 
                             tsbLs, plotOption, 
                             tsb, ingredients)
    ## collect vlines for all tsbs
    .ofaVlineVAF <- paste(.ofaVlineVAF, VAFVlineCha)
  }
  .ofaVlineVAF
}

