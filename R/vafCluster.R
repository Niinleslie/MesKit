#' A VAF plot painter
#' @description Generate variant allele frequency(VAF) frequency distribution
#'  curve with ggplot2 as well as ggridges. Different parameters could lead to 
#'  different outputs with different range of samples.
#' 
#' @import ggplot2 ggsci cowplot grid
#' @importFrom ggridges geom_density_ridges
#' @importFrom dplyr group_by
#' @importFrom dplyr summarise
#' 
#' @param maf the classMaf object generated by readMaf.
#' @param vafColumn choose the specific column containing VAF values. Default "VAF".
#' @param minVaf the minimum value of vaf
#' @param maxVaf the maximum value of vaf
#' @param showMATH decide whether show the MATH Score or not
#' @param plotOption choose a vaf plot ouput option for your target data.Default "compare". 
#' "compare" will tend to provide a ridgeline plot.
#' "combine" will output a document with all samples of a patient.
#' "separate" will provide documents for every samples from the patient.
#' @param themeOption select a theme Palette from ggsci. Default "aaas".
#' 
#' @return Images of selected samples' VAF
#' 
#' @examples
#' maf.File <- system.file("extdata/multi_lesion/maf", "311252.maf", package = "Meskit")
#' sampleInfo.File <- system.file("extdata/multi_lesion", "sample_info.txt", package = "Meskit")
#' maf <- readMaf(mafFile=maf.File, sampleInfoFile=sampleInfo.File, refBuild="hg19")
#' vafCluster(maf, plotOption="compare")
#' vafCluster(maf, plotOption="combine")
#' vafCluster(maf, plotOption="separate")
#'
#' @export vafCluster
#' @export vafClusterRshiny
#' 

## Main function for VAF plot
vafCluster <-function(maf, vafColumn="VAF", 
                      minVaf=0.02, maxVaf=1, showMATH=TRUE, 
                      plotOption="combine", themeOption="aaas"){
    ## original data preparation
    ## read .maf file
    colnames(maf@data)[colnames(maf@data) == vafColumn] <- "VAF"
    mafInput <- maf@data
    if (max(mafInput$VAF, na.rm=TRUE) > 1){
        mafInput$VAF <- mafInput$VAF/100
    }
    patientID <- maf@patientID
    
    ## extract vaf info
    n <- length(mafInput$Hugo_Symbol)
    vafInputMt <- data.frame(mafInput$Hugo_Symbol, 
                             mafInput$VAF, 
                             mafInput$Tumor_Sample_Barcode)
    colnames(vafInputMt) <- c("Hugo_Symbol", "VAF", "Samples")
    clusterAll <- data.frame()
    ## extract all tumor sample barcode
    tsbLs <- data.frame(unique(vafInputMt$Samples))
    colnames(tsbLs) <- c("samples")
    
    ## plot all samples' vaf distribution
    if ((plotOption == "separate") | (plotOption == "combine")){
        ## general data process for all samples 
        lsPicName <- c()
        lsSep <- list()
        lsSampleName <- c()
        for (counterMt in seq_along(tsbLs[,1])){
            sampleName <- as.character(tsbLs[,1][counterMt])
            ## calculate ScoreMATH
            mathscore <- .mathCal(maf, minVaf, maxVaf, showMATH, plotOption, sampleName)
            sampleMt <- vafInputMt[which(
                vafInputMt$Samples %in% sampleName),]
            ## data cleaning
            sampleMt <- sampleMt[complete.cases(sampleMt), ]
            sampleMt <- sampleMt[which(sampleMt$VAF != 0),]
            if (length(sampleMt[,1]) < 3) {
                message(paste("Sample ", sampleName, " has too few mutaions",sep = ""))
                next()
            }
            
            ## infer possible cluster from mafInput
            clusterMt <- .clusterGenerator(mafInput, sampleName)
            clusterMt <- clusterMt[which(clusterMt$Tumor_Sample_Barcode == sampleName), ]

            ## separate: print VAF pictures for all samples separatively
            if (plotOption == "separate"){
                pic <- .drawVAF(clusterMt, themeOption, 
                                sampleName, mathscore)
                lsSep[[counterMt]] <- pic
                lsSampleName <- c(lsSampleName,sampleName)
            }
            else {
                # prepare separated pictures for later combination 
                pic_cha <- paste("separate", ".", counterMt, 
                                 "<-.drawVAF(clusterMt, themeOption, ", 
                                 "sampleName, mathscore, ", 
                                 "MIXOption=plotOption)", sep="")
                eval(parse(text=pic_cha))
                pic_name <- paste("separate", ".", counterMt, sep="")
                lsPicName <- c(lsPicName, pic_name)
            }
        }
        if (plotOption == "separate"){
            names(lsSep) <- lsSampleName
            message(paste("VAF Plot(", plotOption, ") Generation Done!", sep=""))
            return(lsSep)
        }
        ## combine: print VAF pictures for all samples in one document
        if (plotOption == "combine"){
            if (showMATH){
                mathtbscoreLs <- .mathCal(maf, minVaf, maxVaf, showMATH, "compare", sampleName)
                mathtbscore <- mathtbscoreLs$patientLevel
                combineMathScore <- mathtbscore[which(
                    mathtbscore$Tumor_Sample_Barcode == maf@patientID), 
                    ]$MATH_score
                ## set the columns of the picture and generate all single pictures
                combineTitle <- ggdraw() + 
                    draw_label(
                        paste("VAF density plot of ", patientID, ", MATH Score: ", as.character(combineMathScore), sep=""),
                        fontface = 'bold',
                        x = 0,
                        hjust = 0
                    ) +
                    theme(
                        # add margin on the left of the drawing canvas,
                        # so title is aligned with left edge of first plot
                        plot.margin = margin(0, 0, 0, 7)
                    )
                pic <- eval(parse(text=paste("plot_grid(", 
                                             paste(lsPicName, collapse=","), 
                                             ", nrow=", 
                                             ceiling(length(lsPicName)/2), 
                                             ", ncol=2, align=\"v\")" , 
                                             sep="")))
                pic <- plot_grid(
                    combineTitle, pic,
                    ncol = 1,
                    # rel_heights values control vertical title margins
                    rel_heights = c(0.1, 1))
                
            } else {
                pic <- eval(parse(text=paste("plot_grid(", 
                                             paste(lsPicName, collapse=","), 
                                             ", nrow=", 
                                             ceiling(length(lsPicName)/2), 
                                             ", ncol=2, align=\"v\")" , 
                                             sep="")))
            }
            message(paste("VAF Plot(", plotOption, ") Generation Done!", sep=""))
            return(suppressWarnings(suppressMessages(pic)))
        }
    }
    
    ## plot all samples' vaf distribution with ggridges
    else if (plotOption == "compare"){
        ## calculate ScoreMATH
        mathtbscoreLs <- .mathCal(maf, minVaf, maxVaf, showMATH, plotOption)
        mathscore <- mathtbscoreLs$sampleLevel
        ## collect all samples' cluster results
        for (counterMt in seq_along(tsbLs[,1])){
            sampleName <- as.character(tsbLs[,1][counterMt])
            sampleMt <- vafInputMt[which(
                vafInputMt$Samples %in% sampleName),]
            ## data cleaning
            sampleMt <- sampleMt[complete.cases(sampleMt), ]
            sampleMt <- sampleMt[which(sampleMt$VAF != 0),]
            if (nrow(sampleMt) < 3) {
                message(paste("Sample ", sampleName, " has too few mutaions",sep = ""))
                next()
            }
            ## generate data from different Tumor_Sample_Barcode
            clusterMtCha <- paste("clusterMt_", counterMt, 
                                  " <- .clusterGenerator(mafInput, sampleName)", sep ="")
            eval(parse(text=clusterMtCha))
            clusterMtCha <- paste("clusterMt_", counterMt, "$MATH", 
                                  " <- rep(mathscore[which(mathscore$Tumor_Sample_Barcode == sampleName), ]$MATH_score, nrow(clusterMt_", counterMt, "))", sep ="")
            eval(parse(text=clusterMtCha))
            clusterMtCha <- paste("clusterAll <- rbind(clusterAll, ", 
                                  "clusterMt_", counterMt, ")",sep ="")
            eval(parse(text=clusterMtCha))
        }
        mathscore <- mathtbscoreLs$patientLevel$MATH_score
        pic <- suppressMessages(eval(parse(text=.ofaVAF(clusterAll, themeOption, 
                                                        tsbLs, plotOption, 
                                                        mathscore, patientID, 
                                                        minVaf, maxVaf))))
        message(paste("VAF Plot(", plotOption, ") Generation Done!", sep=""))
        return(suppressWarnings(suppressMessages(pic)))
    }
    
    ## plot specific sample's vaf plot
    else if (plotOption %in% unique(vafInputMt$Samples))
    {
        ## data preparation
        sampleMt <- vafInputMt[which(
            vafInputMt$Samples %in% plotOption),]
        ## data cleaning
        sampleMt <- sampleMt[complete.cases(sampleMt), ]
        sampleMt <- sampleMt[which(sampleMt$VAF != 0),]
        if (length(sampleMt[,1]) < 3) {
            stop(paste("Sample ", sampleName, " has too few mutaions",sep = ""))
        }
        clusterMt <- .clusterGenerator(mafInput, sampleName)
        ## calculate ScoreMATH
        mathscore <- .mathCal(maf, minVaf, maxVaf, showMATH, plotOption)
        ## VAF plot for specifc sample
        pic <- .drawVAF(clusterMt, themeOption, 
                        plotOption, mathscore)
        message(paste("VAF Plot(", plotOption, ") Generation Done!", sep=""))
        return(suppressWarnings(suppressMessages(pic)))
    }
    else {
        stop("ERROR: plotOption settings failure.")
    }
}


## Main function for VAF plot
vafClusterRshiny <-function(maf, vafColumn="VAF", 
                      minVaf=0.02, maxVaf=1, showMATH=TRUE, 
                      plotOption="combine", themeOption="aaas"){
    ## original data preparation
    ## read .maf file
    colnames(maf@data)[colnames(maf@data) == vafColumn] <- "VAF"
    mafInput <- maf@data
    if (max(mafInput$VAF, na.rm=TRUE) > 1){
        mafInput$VAF <- mafInput$VAF/100
    }
    patientID <- maf@patientID
    
    ## extract vaf info
    n <- length(mafInput$Hugo_Symbol)
    vafInputMt <- data.frame(mafInput$Hugo_Symbol, 
                             mafInput$VAF, 
                             mafInput$Tumor_Sample_Barcode)
    colnames(vafInputMt) <- c("Hugo_Symbol", "VAF", "Samples")
    clusterAll <- data.frame()
    ## extract all tumor sample barcode
    tsbLs <- data.frame(unique(vafInputMt$Samples))
    colnames(tsbLs) <- c("samples")
    
    ## plot all samples' vaf distribution
    if ((plotOption == "separate") | (plotOption == "combine")){
        ## general data process for all samples 
        lsPicName <- c()
        lsSep <- list()
        lsSampleName <- c()
        for (counterMt in seq_along(tsbLs[,1])){
            ## Rshiny: progress bar
            incProgress(amount=1)
            setProgress(message = 'Processing', detail = paste(' sample ', as.character(tsbLs[,1][counterMt])))
            
            sampleName <- as.character(tsbLs[,1][counterMt])
            ## calculate ScoreMATH
            mathscore <- .mathCal(maf, minVaf, maxVaf, showMATH, plotOption, sampleName)
            sampleMt <- vafInputMt[which(
                vafInputMt$Samples %in% sampleName),]
            ## data cleaning
            sampleMt <- sampleMt[complete.cases(sampleMt), ]
            sampleMt <- sampleMt[which(sampleMt$VAF != 0),]
            if (length(sampleMt[,1]) < 3) {
                message(paste("Sample ", sampleName, " has too few mutaions",sep = ""))
                next()
            }
            
            ## infer possible cluster from mafInput
            clusterMt <- .clusterGenerator(mafInput, sampleName)
            clusterMt <- clusterMt[which(clusterMt$Tumor_Sample_Barcode == sampleName), ]
            
            ## separate: print VAF pictures for all samples separatively
            if (plotOption == "separate"){
                pic <- .drawVAF(clusterMt, themeOption, 
                                sampleName, mathscore)
                lsSep[[counterMt]] <- pic
                lsSampleName <- c(lsSampleName,sampleName)
            }
            else {
                # prepare separated pictures for later combination 
                pic_cha <- paste("separate", ".", counterMt, 
                                 "<-.drawVAF(clusterMt, themeOption, ", 
                                 "sampleName, mathscore, ", 
                                 "MIXOption=plotOption)", sep="")
                eval(parse(text=pic_cha))
                pic_name <- paste("separate", ".", counterMt, sep="")
                lsPicName <- c(lsPicName, pic_name)
            }
        }
        if (plotOption == "separate"){
            names(lsSep) <- lsSampleName
            message(paste("VAF Plot(", plotOption, ") Generation Done!", sep=""))
            return(lsSep)
        }
        ## combine: print VAF pictures for all samples in one document
        if (plotOption == "combine"){
            if (showMATH){
                mathtbscoreLs <- .mathCal(maf, minVaf, maxVaf, showMATH, "compare", sampleName)
                mathtbscore <- mathtbscoreLs$patientLevel
                combineMathScore <- mathtbscore[which(
                    mathtbscore$Tumor_Sample_Barcode == maf@patientID), 
                    ]$MATH_score
                ## set the columns of the picture and generate all single pictures
                combineTitle <- ggdraw() + 
                    draw_label(
                        paste("VAF density plot of ", patientID, ", MATH Score: ", as.character(combineMathScore), sep=""),
                        fontface = 'bold',
                        x = 0,
                        hjust = 0
                    ) +
                    theme(
                        # add margin on the left of the drawing canvas,
                        # so title is aligned with left edge of first plot
                        plot.margin = margin(0, 0, 0, 7)
                    )
                pic <- eval(parse(text=paste("plot_grid(", 
                                             paste(lsPicName, collapse=","), 
                                             ", nrow=", 
                                             ceiling(length(lsPicName)/2), 
                                             ", ncol=2, align=\"v\")" , 
                                             sep="")))
                pic <- plot_grid(
                    combineTitle, pic,
                    ncol = 1,
                    # rel_heights values control vertical title margins
                    rel_heights = c(0.1, 1))
                
            } else {
                pic <- eval(parse(text=paste("plot_grid(", 
                                             paste(lsPicName, collapse=","), 
                                             ", nrow=", 
                                             ceiling(length(lsPicName)/2), 
                                             ", ncol=2, align=\"v\")" , 
                                             sep="")))
            }
            ## Rshiny: progress bar
            incProgress(amount=1)
            setProgress(message = 'Generating ', detail = paste("VAF density plot - ", plotOption, " mode", sep=""))
            message(paste("VAF Plot(", plotOption, ") Generation Done!", sep=""))
            return(suppressWarnings(suppressMessages(pic)))
        }
    }
    
    ## plot all samples' vaf distribution with ggridges
    else if (plotOption == "compare"){
        ## calculate ScoreMATH
        mathtbscoreLs <- .mathCal(maf, minVaf, maxVaf, showMATH, plotOption)
        mathscore <- mathtbscoreLs$sampleLevel
        ## collect all samples' cluster results
        for (counterMt in seq_along(tsbLs[,1])){
            ## Rshiny: progress bar
            incProgress(amount=1)
            setProgress(message = 'Processing', detail = paste(' sample ', as.character(tsbLs[,1][counterMt])))
            
            sampleName <- as.character(tsbLs[,1][counterMt])
            sampleMt <- vafInputMt[which(
                vafInputMt$Samples %in% sampleName),]
            ## data cleaning
            sampleMt <- sampleMt[complete.cases(sampleMt), ]
            sampleMt <- sampleMt[which(sampleMt$VAF != 0),]
            if (nrow(sampleMt) < 3) {
                message(paste("Sample ", sampleName, " has too few mutaions",sep = ""))
                next()
            }
            ## generate data from different Tumor_Sample_Barcode
            clusterMtCha <- paste("clusterMt_", counterMt, 
                                  " <- .clusterGenerator(mafInput, sampleName)", sep ="")
            eval(parse(text=clusterMtCha))
            clusterMtCha <- paste("clusterMt_", counterMt, "$MATH", 
                                  " <- rep(mathscore[which(mathscore$Tumor_Sample_Barcode == sampleName), ]$MATH_score, nrow(clusterMt_", counterMt, "))", sep ="")
            eval(parse(text=clusterMtCha))
            clusterMtCha <- paste("clusterAll <- rbind(clusterAll, ", 
                                  "clusterMt_", counterMt, ")",sep ="")
            eval(parse(text=clusterMtCha))
        }
        mathscore <- mathtbscoreLs$patientLevel$MATH_score
        pic <- suppressMessages(eval(parse(text=.ofaVAF(clusterAll, themeOption, 
                                                        tsbLs, plotOption, 
                                                        mathscore, patientID, 
                                                        minVaf, maxVaf))))
        ## Rshiny: progress bar
        incProgress(amount=1)
        setProgress(message = 'Generating ', detail = paste("VAF density plot - ", plotOption, " mode", sep=""))
        message(paste("VAF Plot(", plotOption, ") Generation Done!", sep=""))
        return(suppressWarnings(suppressMessages(pic)))
    }
    
    ## plot specific sample's vaf plot
    else if (plotOption %in% unique(vafInputMt$Samples))
    {
        ## data preparation
        sampleMt <- vafInputMt[which(
            vafInputMt$Samples %in% plotOption),]
        ## data cleaning
        sampleMt <- sampleMt[complete.cases(sampleMt), ]
        sampleMt <- sampleMt[which(sampleMt$VAF != 0),]
        if (length(sampleMt[,1]) < 3) {
            stop(paste("Sample ", sampleName, " has too few mutaions",sep = ""))
        }
        clusterMt <- .clusterGenerator(mafInput, sampleName)
        ## calculate ScoreMATH
        mathscore <- .mathCal(maf, minVaf, maxVaf, showMATH, plotOption)
        ## VAF plot for specifc sample
        pic <- .drawVAF(clusterMt, themeOption, 
                        plotOption, mathscore)
        message(paste("VAF Plot(", plotOption, ") Generation Done!", sep=""))
        return(suppressWarnings(suppressMessages(pic)))
    }
    else {
        stop("ERROR: plotOption settings failure.")
    }
    
}





## Functions for all plotOption
## Calculate ScoreMATH
.mathCal <- function(maf, minVaf, maxVaf, showMATH=TRUE, 
                     plotOption, sampleName = ""){
    if (showMATH){
        if ((plotOption == "separate") | (plotOption == "combine")){
            mathtbscoreLs <- mathScore(maf, c(sampleName), minvaf=minVaf, maxvaf=maxVaf)
            mathtbscore <- mathtbscoreLs$sampleLevel
            mathscore <- mathtbscore[which(
                mathtbscore$Tumor_Sample_Barcode == sampleName), 
                ]$MATH_score
        }
        else if (plotOption == "compare"){
            mathtbscoreLs <- mathScore(maf, c("All"), minvaf=minVaf, maxvaf=maxVaf)
            mathscore <- mathtbscoreLs
        }
        else if (plotOption %in% unique(vafInputMt$Samples)) {
            mathtbscoreLs <- mathScore(maf, c(sampleName), minvaf=minVaf, maxvaf=maxVaf)
            mathtbscore <- mathtbscoreLs$sampleLevel
            mathscore <- mathtbscore[which(
                mathtbscore$Tumor_Sample_Barcode == plotOption), 
                ]$MATH_score
        } else {
            stop("ERROR: plotOption setting error")
        }
    } else {
        mathscore <- NULL
    }
    return(mathscore)
}

.clusterGenerator <- function(mafInput, sampleName){
    ## refine part
    Mt <- mclust::densityMclust(mafInput$VAF, G=1:7, verbose=FALSE)
    clusterMt <- as.data.frame(mafInput)
    clusterMt$cluster <- as.character(Mt[["classification"]])
    ## 
    message(paste("Processing sample ", sampleName, sep = ""))
    return(clusterMt)
}


## Functions for specific plotOption: "separate", "combine", "tsb"
## VAF painter
.drawVAF <- function(clusterMt, themeOption, 
                     plotOption, mathscore, 
                     MIXOption=""){
    ## A draft for density infomation(density_info) of ggplot
    picv <- ggplot(clusterMt, aes(x=VAF)) + 
        geom_line(size=1, colour="#00C0EB", stat="density")
    if (is.null(mathscore)){
        if (MIXOption == "combine"){
            ## generate cha for ggplot and specific titles for minifigures
            vafDrawCha <- paste("ggplot(clusterMt, aes(x=VAF)) + 
                       theme_bw() + 
                       theme(legend.position=\'none\',", 
                                " title=element_text(size=10), ", 
                                "text=element_text(size=10), ", 
                                "panel.grid=element_blank(), ", 
                                "panel.border=element_blank(), ", 
                                "axis.line=element_line(size=0.25)) + ", 
                                "geom_line(size=1, colour=\"#00C0EB\", ", 
                                "stat=\"density\") + ", 
                                "geom_rug(aes(y=0, colour=cluster), sides=\"b\") + ", 
                                .vlineVAF(clusterMt, picv, 
                                          tsb_ls, plotOption),
                                "ggsci::scale_color_", themeOption, "() + ", 
                                "ggsci::scale_fill_", themeOption, "()", sep="")
            
        } else {
            ## generate character/string for ggplot and paint the picture
            vafDrawCha <- paste("ggplot(clusterMt, aes(x=VAF)) + 
                       theme_bw() + 
                       theme(title=element_text(size=16), ", 
                                "text=element_text(size=16), ", 
                                "panel.grid=element_blank(), ", 
                                "panel.border=element_blank(), ", 
                                "axis.line=element_line(size=0.25)) + ", 
                                "geom_line(size=1, colour=\"#00C0EB\", ", 
                                "stat=\"density\") + ", 
                                "geom_rug(aes(y=0, colour=cluster), sides=\"b\") + ", 
                                .vlineVAF(clusterMt, picv, tsb_ls, plotOption),
                                "ggsci::scale_color_", themeOption, "() + ", 
                                "ggsci::scale_fill_", themeOption, "()", sep="")
        } 
    }
    else {
        if (MIXOption == "combine"){
            ## generate cha for ggplot and specific titles for minifigures
            vafDrawCha <- paste("ggplot(clusterMt, aes(x=VAF)) + 
                       theme_bw() + 
                       theme(legend.position=\'none\', ", 
                                "plot.title=element_text(size=10, hjust=1, ", 
                                "vjust=0.5, face='bold'), ", 
                                "title=element_text(size=10), ", 
                                "text=element_text(size=10), ", 
                                "panel.grid=element_blank(), ", 
                                "panel.border=element_blank(), ", 
                                "axis.line=element_line(size=0.25)) + ", 
                                "ggtitle(\"", plotOption, 
                                "\'s MATH Score: ", as.character(mathscore), 
                                "\") + ", 
                                "geom_line(size=1, colour=\"#00C0EB\", ", 
                                "stat=\"density\") + ", 
                                "geom_rug(aes(y=0, colour=cluster), sides=\"b\") + ", 
                                .vlineVAF(clusterMt, picv, tsb_ls, plotOption),
                                "ggsci::scale_color_", themeOption, "() + ", 
                                "ggsci::scale_fill_", themeOption, "()", sep="")
        } else {
            ## generate character/string for ggplot and paint the picture
            vafDrawCha <- paste("ggplot(clusterMt, aes(x=VAF)) + 
                       theme_bw() + 
                       theme(plot.title=element_text(size=16, hjust=1, ", 
                                "vjust=0.5, face='bold'), ", 
                                "title=element_text(size=16), ",
                                "text=element_text(size=18), ", 
                                "panel.grid=element_blank(), ", 
                                "panel.border=element_blank(), ", 
                                "axis.line=element_line(size=0.25)) + ",  
                                "ggtitle(\"MATH Score: ", 
                                as.character(mathscore), "\") + ", 
                                "geom_line(size=1, colour=\"#00C0EB\", ", 
                                "stat=\"density\") + ", 
                                "geom_rug(aes(y=0, colour=cluster), sides=\"b\") + ", 
                                .vlineVAF(clusterMt, picv, tsb_ls, plotOption),
                                "ggsci::scale_color_", themeOption, "() + ", 
                                "ggsci::scale_fill_", themeOption, "()", sep="")
        }
    }
    return(eval(parse(text=vafDrawCha)))
}

## Functions for specific plotOption: "compare"
## VAF painter for OFA
.ofaVAF <- function(clusterAll, themeOption, tsbLs, 
                    plotOption, mathscore, patientID, 
                    minVaf, maxVaf){
    if (is.null(mathscore)){
        vafOFACha <- paste("ggplot(clusterAll, ", 
                           "aes(x=VAF, y=Tumor_Sample_Barcode)) +
                      theme_bw() + 
                      theme(title=element_text(size=16), ", 
                           "text=element_text(size=18), ", 
                           "panel.grid=element_blank(), ", 
                           "panel.border=element_blank(), ",
                           "axis.title=element_text(size=16), ", 
                           "axis.text=element_text(size=12), ", 
                           "axis.line=element_line(size=0.25)) + ",
                           "ggridges::geom_density_ridges(fill=\"whitesmoke\", ",
                           "calc_ecdf=TRUE, alpha=0.2) + ",
                           "geom_point(aes(x=VAF, ", 
                           "y=Tumor_Sample_Barcode, ", 
                           "color=cluster), ", 
                           "alpha=0.2, show.legend=FALSE) + ", 
                           "ggridges::geom_density_ridges(color=\"#00C0EB\", ", 
                           "fill=NA, calc_ecdf=TRUE, alpha=0.2, size=1) + ", 
                           .ofaVlineVAF(clusterAll, tsbLs, plotOption),  
                           "ggsci::scale_color_", themeOption, "() + ", 
                           "ggsci::scale_fill_", themeOption, "() + ", 
                           "labs(y = \"Sample\") + ", 
                           "scale_x_continuous(limits = ", "c(", as.character(minVaf), ",", as.character(maxVaf), "))", sep="")
    } else {
        vafOFACha <- paste("ggplot(clusterAll, ", 
                           "aes(x=VAF, y=Tumor_Sample_Barcode)) +
                      theme_bw() + 
                      theme(plot.title=element_text(size=16, hjust=1, ", 
                           "vjust=0.5, face='bold'), ", 
                           "title=element_text(size=16), ", 
                           "text=element_text(size=18), ", 
                           "panel.grid=element_blank(), ", 
                           "panel.border=element_blank(), ", 
                           "axis.title=element_text(size=16), ", 
                           "axis.text=element_text(size=12), ", 
                           "axis.line=element_line(size=0.25)) + ", 
                           "ggtitle(\"VAF density plot of ", patientID, ", MATH Score: ", 
                           as.character(mathscore), "\") + ", 
                           "ggridges::geom_density_ridges(fill=\"whitesmoke\", ", 
                           "calc_ecdf=TRUE, alpha=0.2) + ",
                           "geom_point(aes(x=VAF, ", 
                           "y=Tumor_Sample_Barcode, ", 
                           "color=cluster), ", 
                           "alpha=0.2, show.legend=FALSE) + ", 
                           "ggridges::geom_density_ridges(color=\"#00C0EB\", ", 
                           "fill=NA, calc_ecdf=TRUE, alpha=0.2, size=1) + ",
                           .ofaVlineVAF(clusterAll, tsbLs, plotOption), 
                           "ggsci::scale_color_", themeOption, "() + ", 
                           "ggsci::scale_fill_", themeOption, "() + ", 
                           "labs(y = \"Sample\") + ", 
                           "geom_text(data=cbind(clusterAll %>% dplyr::group_by(Tumor_Sample_Barcode) %>% dplyr::summarise(), 
                                                 MATH=unique(clusterAll$MATH), 
                                                 VAF=(clusterAll %>% dplyr::group_by(Tumor_Sample_Barcode) %>% dplyr::summarise(VAF=max(VAF)))$VAF),
                                     aes(x=0.85*max(VAF), label=paste(\"MATH Score:\", sprintf(\"%1.3f\", MATH), sep=\"\")), 
                                     position=position_nudge(y=0.65), colour=\"black\", size=3.5) + ", 
                           "scale_x_continuous(limits = ", "c(", as.character(minVaf), ",", as.character(maxVaf), "))", sep="")
    }
    vafOFACha
}

## Draw vlines for all plotOption
.vlineVAF <- function(clusterMt, pic, 
                      tsbLs, plotOption, 
                      tsb, ingredients=NULL)
{
    ## data prepare
    vafVlineCha <- ""
    clusterLs <- unique(clusterMt$cluster)
    ## density information of the curve for a tsb
    densityInfo <- data.frame(layer_data(pic))
    
    ## OFA specific: get scaling ratio
    if (!is.null(ingredients)){
        iscale <- ingredients$iscale[1]
        scale <- ingredients$scale[1]
    }
    
    ## Obtain vline Coordinate(x, xend, y, yend)
    for (cluster_name in clusterLs){
        x_end <- max(clusterMt[which(
            clusterMt$cluster == cluster_name), ]$VAF)
        x_end_alter <- densityInfo$x[which.min(
            abs(outer(densityInfo$x,x_end,FUN="-")))]
        y_end <- densityInfo$y[which(
            densityInfo$x == x_end_alter)]
        if (plotOption == "compare"){
            ## Scale and draw lines
            density <- densityInfo$density[which(
                densityInfo$x == x_end_alter)]
            vafVlineCha <- paste(
                vafVlineCha, 
                "geom_segment(data=clusterMt_", which(tsbLs == tsb), 
                " ,aes(x=", x_end_alter, 
                ", xend=", x_end_alter, 
                ", y=", which(tsbLs == tsb), 
                ", yend=", which(tsbLs == tsb) + density*iscale*scale, "), ", 
                "size=0.5, colour=\"grey\", linetype=\"dashed\") + ",sep="")
        }else{
            vafVlineCha <- paste(
                vafVlineCha, 
                "geom_segment(aes(x=", x_end_alter,", xend=", x_end_alter, 
                ", y=0, yend=", y_end,"), ", 
                "size=0.5, colour=\"grey\", linetype=\"dashed\") + ",sep="")
        }
    }
    vafVlineCha
}


## VAF draw vlines for ofa
.ofaVlineVAF <- function(clusterAll, tsbLs, 
                         plotOption)
{
    ## data prepare
    .ofaVlineVAF <- ""
    ## density information of the curve for all tsbs
    gr <- ggplot(clusterAll, aes(x=VAF, y=Tumor_Sample_Barcode)) + 
        ggridges::geom_density_ridges() 
    ingredients <- ggplot_build(gr) %>% purrr::pluck("data", 1)
    
    for (tsb in tsbLs$samples)
    {
        ## renew tsb's data
        VAFVlineCha <- ""
        xEndLs <- data.frame()
        yEndLs <- data.frame()
        clusterMt <- clusterAll[which(
            clusterAll$Tumor_Sample_Barcode == tsb), ]
        clusterLs <- unique(clusterMt$cluster)
        ## A draft for density infomation(density_info) of ggplot
        picv <- ggplot(clusterMt, aes(x=VAF)) + 
            geom_line(size=1, colour="#00C0EB", stat="density")
        densityInfo <- data.frame(layer_data(picv))
        ## collect vlines for a single tsb
        VAFVlineCha <- .vlineVAF(clusterMt, picv, 
                                 tsbLs, plotOption, 
                                 tsb, ingredients)
        ## collect vlines for all tsbs
        .ofaVlineVAF <- paste(.ofaVlineVAF, VAFVlineCha)
    }
    .ofaVlineVAF
}

