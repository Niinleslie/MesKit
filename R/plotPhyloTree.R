#' @title plotPhyloTree
#' 
#' @param phyloTree a phyloTree object generated by getphyloTree function.
#' @param show.mutSig logical. Whether to show mutational signature on tree. Default is TRUE.
#' @param show.heatmap logical. Whether to show heatmap of somatic mutations. Default is TRUE.
#' @param heatmap.type character. "binary" (default) for printing a binary heatmap of mutations; or "CCF" for printing a cancer cell frequency (CCF) heatmap. This parameter is only useful when show.mutSig = TRUE.
#' @param show.bootstrap logical.Whether to add bootstrap value on internal nodes.Default is TRUE.
#' @param use.box logical.Whether to add box around bootstrap value on tree. Default is TRUE.
#' @examples
#' plotPhyloTree(phyloTree)
#' ## Use ccf 
#' plotPhyloTree(phyloTree, heatmap.type = 'CCF')
#
#' @return Prints plot.
#' @import reshape2 ape ggplot2 deconstructSigs ggrepel
#' @export plotPhyloTree
#' 


plotPhyloTree <- function(phyloTree = NULL, show.mutSig = TRUE, show.heatmap = TRUE,
                          heatmap.type = 'binary',show.bootstrap = TRUE, use.box = TRUE){
   set.seed(123)
   heatmap.options <- c('binary','CCF')
   if(!heatmap.type %in% heatmap.options){
      stop("Type of heatmap can only be 'binary' or 'CCF'")
   }
   if(heatmap.type == 'binary'){
     use.ccf = FALSE
   }else if(heatmap.type == 'CCF'){
      if(nrow(phyloTree@ccf.matrix) > 1){
         use.ccf = TRUE
      }else{
         warning("CCF information not found")
         use.ccf = FALSE
      }
   }
   ## get phylotree data
   rootLabel <- 'NORMAL'
   treeData <- getTreeDat(phyloTree, show.mutSig)
   treeData <- treeData[distance!= 0|sample == rootLabel,]
   if(show.mutSig){
      colorScale <- colorSet(unique(treeData$signature))
   }
   myBoots <- phyloTree@bootstrap.value
   patientID <- phyloTree@patientID
   ## plot phylotree
   samplePointsSize <- 3
   sampleTextSize <- 3
   nodePointsSize <- 1.7
   segmentSize <- 1.5
   # nodeStrokeSize <- 0.5
   # sampleStrokeSize <- 1
   nodeStrokeSize <- 0.25
   sampleStrokeSize <- 1.5
   bootLabelSize <- 2.2
   bootTextSize <- 2.2
   bootPaddingSize <- 0.35
   samplesLength <- nrow(treeData[sample != "internal node",]) 
   if(samplesLength > 7){
      samplePointsSize <- 1.5 
      sampleTextSize <- 2
      segmentSize <- 0.8
      nodePointsSize <- 0.8
      # nodeStrokeSize <- 0.25
      # sampleStrokeSize <- 0.5
      nodeStrokeSize <- 0.15
      sampleStrokeSize <- 0.8
      bootLabelSize <- 1.5
      bootTextSize <- 1.5
      bootPaddingSize <- 0.1
   }
   rootNode <- treeData[sample == rootLabel,]$node
   if(length(myBoots) == 1){
      bootsData <- data.frame(x2 = 0, y2 = 0, node = rootNode, end_num = rootNode, boots = myBoots)
   }
   else{
      sub <- data.table::data.table(x2 = 0, y2 = 0,node = rootNode, end_num = rootNode)
      bootsData <- rbind(treeData[sample == 'internal node',][,.(x2,y2,node,end_num)],sub)
      boots <- c()
      LN <- min(bootsData$node)-1
      for(i in 1:nrow(bootsData)){      
         if(i == nrow(bootsData)){
            boots <- append(boots,  myBoots[rootNode - LN])
            next
         }
         boots <- append(boots, myBoots[bootsData$end_num[i] - LN])
         
      }
      bootsData <- cbind(bootsData, boots = boots)
   }
   p <- ggplot(data = treeData)
   textAdjust <- mean(as.numeric(treeData$distance))
   # maxy <- max(abs(treeData$y2))
   # maxx <- max(abs(treeData$x2)))
   ratecoord <- maxy/maxx
   if(show.mutSig){
      p <- p + geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2, color = signature), size=segmentSize)
      p <- p + scale_color_manual(values = colorScale)
   }
   else{
      p <- p + geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2, color = sample),
                            data = treeData[!sample %in% c("internal node",rootLabel),], 
                            size=segmentSize, show.legend = T)
      p <- p + geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2), color = 'black',
                            data = treeData[sample == rootLabel,], 
                            size = segmentSize, show.legend = F )
      p <- p + geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2), color = '#67001F',
                            data = treeData[sample == 'internal node',], 
                            size = segmentSize, show.legend = F )
   }
   p <- p + theme(axis.title.x = element_blank(),
                  axis.text.x = element_blank(),
                  axis.ticks.x = element_blank(),
                  axis.title.y = element_blank(),
                  axis.text.y = element_blank(),
                  axis.ticks.y = element_blank(),
                  axis.line = element_blank(),
                  panel.grid.major = element_blank(),
                  panel.grid.minor = element_blank(), panel.background = element_blank(),
                  panel.border = element_blank(),
                  legend.title = element_text(face="bold"),
                  legend.position = 'top',
                  legend.direction = "horizontal") + 
                  guides(color = guide_legend(nrow=1))+
                  coord_fixed(ratio= 1) +
                  scale_x_discrete(expand = expand_scale(add = 10))
                  
   p <- p + geom_text_repel(aes(x = x2, y = y2, label = sample),
                            nudge_y = 2,
                            # segment.alpha = 0,
                            # direction = "x"
                            segment.color = "grey",
                            segment.size = 0.25,
                            data = treeData[!sample %in% c("internal node",rootLabel), ],
                            fontface = 'bold', size = sampleTextSize ,force = 10)
   p <- p + geom_text_repel(aes(x = x2,y = y2), label = rootLabel, vjust = 0, 
                            nudge_y = -textAdjust/5,
                            segment.alpha = 0,
                            data = treeData[sample == rootLabel,], 
                            fontface = 'bold', size = sampleTextSize,force = 5)
   p <- p + geom_point(aes(x = x2,y = y2),
                       data = treeData[sample == 'internal node',],
                       size = nodePointsSize, color = "#8c510a", fill = "white", shape = 21,
                       stroke = nodeStrokeSize)
   p <- p + geom_point(aes(x = x2, y = y2), 
                       data = treeData[sample != 'internal node',],
                       size = samplePointsSize,color = "#67001F", fill = 'white', shape = 21, stroke = sampleStrokeSize)
   Nd <- treeData[sample == rootLabel,]$distance
   if(length(Nd)!=0){
      if(Nd != 0){
         # p <- p + geom_point(aes(x =0 , y = 0), size = 1.7, color = "grey50",
         #                     fill = 'grey50', shape = 21, stroke = 0.5)
         p <- p + geom_point(aes(x =0 , y = 0), size = nodePointsSize, color = "#8c510a",
                             fill = 'white', shape = 21, stroke = nodeStrokeSize)
      }
   }
   if(show.bootstrap){
      if(use.box){
         p <- p + geom_label_repel(aes(x = x2, y = y2,label = boots),
                                   data = bootsData,
                                   # nudge_y = textAdjust/6,
                                   fontface = 'bold', size = bootLabelSize, box.padding = unit(bootPaddingSize, "lines"), point.padding = unit(0.5, "lines"),
                                   segment.colour = "grey50", segment.size = 0.25, force = 5)
      }else{
         p <- p + geom_text_repel(aes(x = x2, y = y2,label = boots),
                                  data = bootsData,
                                  fontface = 'bold', size = bootTextSize, box.padding = unit(bootPaddingSize, "lines"), point.padding = unit(0.5, "lines"),
                                  segment.colour = "grey50", segment.size = 0.25, force = 5)
      }
   }
   if(show.heatmap){
      h <- mutHeatmap(phyloTree, use.ccf)
      pm <- getPrivateMutation(phyloTree)
      totalMutSum <- pm[[1]]
      privateMutProportion <- pm[[2]]
      PH <- ggdraw(xlim = c(0.1,0.7)) + 
            draw_plot(p, x = -0.05,y = 0, width = 0.7) + 
            draw_plot(h, x = 0.48,y = -0.12, width = 0.15)
      # PH <- ggdraw(xlim = c(0,1),ylim = c(0,1)) + 
      #       draw_plot(p, x = 0,y = 0, width = 0.7) + 
      #       draw_plot(h, x = 0.6,y = 0, width = 0.15)
      title <- ggdraw() + 
              draw_label(paste(patientID,"\n(n = " ,totalMutSum ,"; ",privateMutProportion,")",sep = ""),
                         fontface = "bold")
      PH <- plot_grid(title,PH,ncol = 1,rel_heights=c(0.09, 1)) + 
            theme(plot.margin=grid::unit(c(0,0,0,0), "mm"))
      # ggsave(filename = paste0(patientID,".pdf"),plot = PH,width = 10,height = 6.5)
      return(PH)
   }
   else{
      return(p)
   }
}

getTreeDat <- function(phyloTree, show.mutSig){
   tree <- phyloTree@tree
   signature <- c()
   rootLabel <- "NORMAL"
   if(show.mutSig){
      signature <- treeMutSig(phyloTree)$mutSigsOutput  
   }
   tree <- ape::root(tree, tree$tip.label[which(tree$tip.label == rootLabel)])
   treeEdge <- data.table::data.table(node = tree$edge[,1], endNum = tree$edge[,2], length = tree$edge.length)
   numNORMAL <- which(tree$tip.label == rootLabel)
   #the position of NORMAL in edge 
   rootRow <- which(treeEdge$endNum == numNORMAL)
   # the  Node connected to NORMAL
   rootNode <- treeEdge$node[rootRow]
   rootEdge <- treeEdge$length[rootRow]
   branchLabel <- labelBranch(tree)
   mainTrunk <- calMainTrunk(tree, rootNode = rootNode, rootLabel = rootLabel)
   nodeOnTree <- mainTrunk[mainTrunk > length(tree$tip.label)]
   ccn <- calChildNodeNum(tree, mainTrunk, rootNode = rootNode)
   numList <- ccn[[1]]
   lrnumList <- ccn[[2]]
   nodeNoOnTree <- ccn[[3]]
   nodeOnTree <- ccn[[4]]
   if(length(mainTrunk) != 0){
      gta <- getTrunkAngles(tree, mainTrunk, numList, rootNode, horizon = pi/2, W = pi, numNORMAL = numNORMAL)
      collateralWs <- gta[[1]]
      collateralAngles <- gta[[2]]
      collateralPoints <- gta[[3]]
   }
   #X1, y1 are the starting point, x2 and y2 are the end point.Horizon stands for the Angle between the line and the positive x axis;W stands for the Angle occupied by branches (explained in the paper)
   #Distance means distance;Node is the internal node with the start;End_num is the number of each node in edge;
   treeData <- data.table::data.table('x1'= 0, 'y1' = 0,
                                      'x2' = 0, 'y2' = 0,
                                      'horizon' = pi/2, 'W' = 2/3*pi,
                                      'angle' = 0,'distance' = 0,
                                      'node' = rootNode, 'end_num' = rootNode)
   treeData <- setPhyloTree(tree, treeData, rootNode, mainTrunk, collateralPoints, collateralWs, collateralAngles,
                            horizon = pi/2 , W = pi, ft = NULL)
   subTrees <- ape::subtrees(tree)
   subroot <- unlist(lapply(subTrees, function(x){return(x$name)}))
   if(length(nodeNoOnTree)!=0){
      t <- 1
      while(TRUE){
         node <- nodeNoOnTree[t]
         subtree <- subTrees[[which(subroot == node)]]
         rootNode <- length(subtree$tip.label)+1
         rootNode1 <- subtree$node.label[1]
         numNORMAL <- NULL
         mainTrunk <- calMainTrunk(subtree, rootNode = rootNode, rootLabel = "")
         ccn <- calChildNodeNum(subtree, mainTrunk, rootNode = rootNode, ft = TRUE)
         numList <- ccn[[1]]
         lrnumList <- ccn[[2]]
         nodeNoOnTree <- append(nodeNoOnTree,ccn[[3]])
         nodeOnTree <- append(nodeOnTree,ccn[[4]])
         horizon <- treeData[end_num == rootNode1,]$angle
         W <- treeData[end_num == rootNode1,]$W
         gta <- getTrunkAngles(subtree, mainTrunk, numList, rootNode, horizon = horizon, W = W, numNORMAL = NULL)
         collateralWs <- gta[[1]]
         collateralAngles <- gta[[2]]
         collateralPoints <- gta[[3]]
         treeData <- setPhyloTree(subtree, treeData, rootNode, mainTrunk, collateralPoints, collateralWs, collateralAngles,
                                  horizon = horizon , W = W, ft = tree)
         if(length(nodeOnTree) == tree$Nnode){
            break
         }
         t <- t + 1
      }
   }
   ## bind NORMAL
   rootNode <- treeData[1,]$node
   treeData[1,]$end_num <- which(tree$tip.label == "NORMAL")
   treeData[1,]$y2 <- -rootEdge
   treeData[1,]$distance <- rootEdge
   treeData[,sample := ""]
   for(i in 1:nrow(treeData)){
      if(treeData$end_num[i] > length(tree$tip.label)){
         treeData$sample[i] <- "internal node"
      }
      else{
         pos <- treeData$end_num[i]
         treeData$sample[i] <- tree$tip.label[pos]
      }
   }
   if(nrow(treeData) == 3){
      angleList <- c(pi/3, 2*pi/3)
      rows <- which(treeData$sample != "NORMAL")
      i = 1
      for(row in rows){
         angle <- angleList[i]
         treeData$angle[row] <- angle
         treeData$x2[row] <- treeData$distance[row]*cos(angle)
         treeData$y2[row] <- treeData$distance[row]*sin(angle)
         i = i+1
      }
   }
   if(nrow(treeData[x2 > 0,]) == 0){
      maxy <- which.max(treeData$y2)
      angle <- treeData$angle[maxy] - pi/18
      treeData$angle[maxy] <- angle
      treeData$y2[maxy] <- treeData$distance[maxy]*sin(angle) + treeData$y1[maxy]
      treeData$x2[maxy] <- treeData$distance[maxy]*cos(angle) + treeData$x1[maxy]
   }else if(nrow(treeData[x2 < 0,]) == 0){
      maxy <- which.max(treeData$y2)
      angle <- treeData$angle[maxy] + pi/18
      treeData$angle[maxy] <- angle
      treeData$y2[maxy] <- treeData$distance[maxy]*sin(angle) + treeData$y1[maxy]
      treeData$x2[maxy] <- treeData$distance[maxy]*cos(angle) + treeData$x1[maxy]
   }
   if(show.mutSig){
      treeData$label <- ""
      for(i in 1:nrow(treeData)){
         if(treeData$sample[i] == "NORMAL"){
            treeData$label[i] <- branchLabel[[rootNode]]
         }else{
            if(treeData$end_num[i] > length(tree$tip.label)){
               treeData$label[i] <- branchLabel[[treeData$end_num[i]]]
            }
            else{
               treeData$label[i] <- as.character(treeData$sample[i]) 
            }
         }
      }
      treeData <- addSignature(tree, treeData, signature)
   }
   return(treeData)
}


setPhyloTree <- function(tree, treeData, rootNode, mainTrunk, collateralPoints, collateralWs, collateralAngles,
                         horizon = pi/2 , W = 2*pi/3, ft = NULL){
   trunkPath <- rev(c(mainTrunk,rootNode))
   if(!is.null(ft)){
      for(i in 1:length(trunkPath)){
         point <- trunkPath[i]
         if(point > tree$Ntip){
            trunkPath[i] <- tree$node.label[point - tree$Ntip]
         }
         else{
            name <- tree$tip.label[point]
            trunkPath[i] <- which(ft$tip.label == name)
         }
      }
   }
   # if(is.null(mt)){
   #    startPos <- 0
   # }
   if(length(trunkPath) > 0){
      for(i in 2:length(trunkPath)){
         x1 <- treeData[end_num == trunkPath[i-1],]$x2
         y1 <- treeData[end_num == trunkPath[i-1],]$y2
         W <- W
         angle <- horizon
         if(is.null(ft)){
            distance <- tree$edge.length[which(tree$edge[,2] == trunkPath[i])] 
         }else{
            distance <- ft$edge.length[which(ft$edge[,2] == trunkPath[i])]
         }
         if(horizon == pi/2){
            x2 <- x1
            y2 <- y1 + distance
         }else{
            x2 <- x1 + distance*cos(angle)
            y2 <- y1 + distance*sin(angle)
         }
         subdat <- data.table::data.table('x1'= x1, 'y1' = y1,
                                          'x2' = x2, 'y2' = y2,
                                          'horizon' = horizon,'W' = W,
                                          'distance' = distance, 'angle' = horizon,
                                          'node' = trunkPath[i-1],'end_num' = trunkPath[i])
         treeData <- rbind(treeData, subdat)
      }
   }
   if(length(collateralPoints) > 0){
      for(i in 1:length(collateralPoints)){
         point <- collateralPoints[i]
         if(!is.null(ft)){
            if(point > tree$Ntip){
               point1 <- tree$node.label[point - tree$Ntip]
            }else{
               name <- tree$tip.label[point]
               point1 <- which(ft$tip.label == name)
            }
            startnode <- ft$edge[which(ft$edge[,2] == point1),1]
         }else{
            startnode <- tree$edge[which(tree$edge[,2] == point),1] 
         }
         x1 <- treeData[end_num == startnode,]$x2
         y1 <- treeData[end_num == startnode,]$y2
         W <- collateralWs[point]
         angle <- collateralAngles[point]
         distance <- tree$edge.length[which(tree$edge[,2] == point)] 
         x2 <- x1 + distance*cos(angle)
         y2 <- y1 + distance*sin(angle)
         if(is.null(ft)){
            endNum <- point
         }
         else{
            endNum <- point1
         }
         subdat <- data.table::data.table('x1'= x1, 'y1' = y1,
                                          'x2' = x2, 'y2' = y2,
                                          'horizon' = horizon,'W' = W,
                                          'distance' = distance, 'angle' = angle,
                                          'node' = startnode,'end_num' = endNum)
         treeData <- rbind(treeData, subdat)
      }
   }
   return(treeData)
}

calMainTrunk <- function(tree, rootNode, rootLabel = "NORMAL"){
   #Generate the adjacency matrix
   edge <-  tree$edge
   #Add the third column of the matrix to the node distance
   distance <- tree$edge.length
   edge <- matrix(c(edge, distance), nrow = length(edge[, 1]))
   distanceTable <- data.frame(x = 0)
   for(i in 1:(length(tree$tip.label))){
    distanceTable <- cbind(distanceTable, -1)
   }
   distanceTable <- distanceTable[,(-1)]
   names(distanceTable) <- tree$tip.label
   t <- 1
   path <- list()
   while(t <= length(distanceTable)){
    subPath <- c()
    end <- which(tree$tip.label == names(distanceTable)[t])
    dis <- 0
    while (TRUE) {
     p <- which(edge[,2] == end)
     dis <- dis + edge[p,3]
     start <- edge[p,1]
     subPath <- append(subPath,end)
     end <- start
     if(start == rootNode){
      break
     }
    }
    path[[t]] <- subPath
    distanceTable[t] <- dis
    t <- t + 1
   }
   if(rootLabel == "NORMAL"){
    numNORMAL <- which(tree$tip.label == rootLabel)
    distanceTable <- distanceTable[-numNORMAL]
   }
   result <- path[[which.max(distanceTable)]]
}

getTrunkAngles <- function(tree, mainTrunk, numList, rootNode, horizon = pi/2, W = pi ,numNORMAL = NULL){
   treeEdge <- data.table::data.table(start =  tree$edge[,1], end = tree$edge[,2])
   if(!is.null(numNORMAL)){
      treeEdge <- treeEdge[end != numNORMAL,]    
   }
   nodes <- factor(rev(c(mainTrunk,rootNode)), levels = rev(c(mainTrunk,rootNode)))
   collateralPoints <- c()
   for(n in nodes){
      p <- treeEdge[start == n,][,end] %>% setdiff(nodes)
      collateralPoints <- append(collateralPoints,p)
   }
   left <- c()
   right <- c()
   leftList <- c()
   rightList <- c()
   i <- 1
   for(point in collateralPoints){
    if(i == 1){
     if(horizon < pi/2){
         leftList <- append(leftList, point)
         left <- append(left,numList[point])  
     }else{
         rightList <- append(rightList, point)
         right <- append(right,numList[point])  
     }
    }else{
     if(sum(right) <= sum(left)){
      rightList <- append(rightList, point)
      right <- append(right,numList[point]) 
     }else{
      leftList <- append(leftList, point)
      left <- append(left,numList[point])
     }
    }
    i <- i+1
   }
   collateralWs <- rep(0,length(tree$edge.length)+1)
   collateralAngles <- rep(0,length(tree$edge.length)+1)
   if(length(rightList) > 0){
    startr <- horizon - W/2
    wrt <- W/2
    totalR <- sum(right)
    
    for(i in 1:length(rightList)){
     if(rightList[i] <=  length(tree$tip.label)){
      n <- 1
     }else{
      n <- right[i]
     }
     wr <- wrt*n/totalR
     collateralWs[rightList[i]] <- wr
     if(i == 1){
      angler <- wr/2 + startr
      collateralAngles[rightList[i]] <- angler
      startr <- angler
     }else{
      angler <- wr/2 + startr + collateralWs[rightList[i-1]]/2
      collateralAngles[rightList[i]] <- angler
      startr <- angler
     }
    }
   }
   if(length(leftList) > 0){
    wlt <- W/2
    startl <- horizon + wlt
    totalL <- sum(left)
    for(i in 1:length(leftList)){
     if(leftList[i] <=  length(tree$tip.label)){
        n <- 1
     }
     else{
        n <- left[i]
     }
     wl <- wlt*n/totalL
     collateralWs[leftList[i]] <- wl
     if(i == 1){
      anglel <- startl - wl/2
      collateralAngles[leftList[i]] <- anglel
      startl <- anglel
     }
     else{
      anglel <- startl- wl/2 - collateralWs[leftList[i-1]]/2
      collateralAngles[leftList[i]] <- anglel
      startl <- anglel
     }
    }
   }
   return(list(collateralWs,collateralAngles, collateralPoints))
}


calChildNodeNum <- function(tree, mainTrunk, rootNode, ft = FALSE){
   edge <- tree$edge
   num <- length(tree$edge.length)+1
   numList <- c()
   lrnumList <- c()
   for(i in 1:num){
    numList[i] <- 1
    lrnumList[i] <- 0
   }
   for(i in 1:num){
    if(i == rootNode){
     next
    }
    startNum <- i
    endNum <- as.numeric(edge[which(tree$edge[,2] == i),1])
    while(TRUE){
     numList[endNum] <- numList[endNum] + 1
     if(endNum == rootNode){
      break
     }
     startNum <- as.numeric(edge[which(tree$edge[,2] == endNum),2])
     endNum <- as.numeric(edge[which(tree$edge[,2] == endNum),1]) 
    }
    # if(count > 1){
    #     numList[i] <- 0
    # }
   }
   ## samples are not in mainTrunk
   nodeRange <- (length(tree$tip.label) + 1): length(numList)
   idxs <- edge[,2][which(!edge[,1] %in% c(mainTrunk,rootNode))]
   nodeOnTree <- edge[,2][edge[,1] %in% c(mainTrunk,rootNode)] %>% setdiff(mainTrunk) %>% intersect(nodeRange)
   nodeNoOnTree <- c(mainTrunk,rootNode) %>% intersect(nodeRange)
   idxNode <- setdiff(nodeRange, mainTrunk)
   lrnumList <- numList
   lrnumList[idxs] <- 0
   if(ft){
      nodeOnTree <- tree$node.label[nodeOnTree - tree$Ntip]
      nodeNoOnTree <- tree$node.label[nodeNoOnTree - tree$Ntip]
   }   
   return(list(numList,lrnumList, nodeOnTree, nodeNoOnTree))
}



addSignature <- function(tree, treeData, signature){
    #add signature to treeData
    treeData$signature <- ''
    treeData$alias <- ''
    sigs <- strsplit(as.character(signature$branch),"∩")
    sigs <- lapply(sigs, function(x){return(paste(sort(x,decreasing = T),collapse = "∩"))})
    t <- 1
    while(t<=length(sigs)){
        pos <- which(treeData$label == sigs[[t]])
        treeData$signature[pos] <- as.character(signature$sig[t]) 
        treeData$alias[pos] <- as.character(signature$alias[t])
        t <- t + 1
    }
    if(treeData$signature[which(treeData$sample == 'NORMAL')] == ''){
        treeData$signature[which(treeData$sample == 'NORMAL')] = as.character(signature$sig[1])
        treeData$signature[which(treeData$alias == 'NORMAL')] = as.character(signature$alias[1])
    }
    treeData <- treeData[order(treeData$signature), ]
    treeData$signature <- gsub('No Signature', 'No signature', treeData$signature)
    treeData$signature <- gsub('Signature ', '', treeData$signature)
    return(treeData)
}

colorSet <- function(signatures){
    allColorScale <- c("#E41A1C","#377EB8","#7F0000",
                       "#35978f","#FC8D62","#2166ac",
                       "#E78AC3","#A6D854","#FFD92F",
                       "#E5C494","#8DD3C7", "#6E016B" ,
                       "#BEBADA", "#e08214", "#80B1D3",
                       "#d6604d","#ffff99","#FCCDE5",
                       "#FF6A5A","#BC80BD","#CCEBC5" ,
                       "#fb9a99","#B6646A", "#9F994E", 
                       "#7570B3" ,"#c51b7d" ,"#66A61E" ,
                       "#E6AB02" ,"#003c30", "#666666",'black')
    allSignature <- append(gsub('Signature.', '',row.names(deconstructSigs::signatures.cosmic)), 'No signature')
    colorScale <- c()
    for(i in 1:length(signatures)){
        color <- allColorScale[which(allSignature == signatures[i])]
        colorScale <- append(colorScale, color)
    }
    if('black' %in% colorScale){
        num <- which(colorScale == 'black')
        colorScale <- colorScale[-num]
        colorScale <- append(colorScale, 'black')
    }
    return(colorScale)
}

getPrivateMutation <- function(phyloTree){
    totalMut <- phyloTree@mut.branches
    privateOrder <- unlist(lapply(names(totalMut),
                                  function(x){return(length(strsplit(x,"∩")[[1]]) == 1)})) 
    privateMut <- totalMut[privateOrder]
    countMutation <- function(mut){
        sum <- 0
        for(i in 1:length(mut)){
            count <- nrow(mut[[i]])
            sum <- sum + count
        }
        return(sum)
    }
    totalMutSum <- countMutation(totalMut)
    privateMutSum <- countMutation(privateMut)
    privateMutProportion <- paste(round((privateMutSum/totalMutSum)*100,1),"%",sep = "")
    return(list(totalMutSum, privateMutProportion))
}

labelBranch <- function(tree){
    Root <- which(tree$tip.label == "NORMAL")
    internalNodes <- sort(unique(tree$edge[,1]))
    result <- list()
    for(i in 1:(length(tree$edge.length)+1)){
        result[[i]] <- NA
    }
    end <- tree$edge[which(tree$edge[,2] == Root),1]
    for(i in 1:length(tree$tip.label)){
        row <- tree$edge[which(tree$edge[,2] == i), ]
        if(i == Root){
            next
        }
        while (TRUE) {
            node <- row[1]
            if(node == end){
                result[[node]] <- append(result[[node]], i)
                break
            }
            else{
                result[[node]] <- append(result[[node]], i)
                row <- tree$edge[which(tree$edge[,2] == node),]
            }
        }
    }
    g <- lapply(result, function(x){return(paste(sort(tree$tip.label[x[-1]], decreasing = T),collapse = "∩"))})
    return(g)
}
