#' @title plotPhyloTree
#' 
#' @param phyloTree object generated by getPhyloTree function.
#' @param branchCol character."mutSig" for coloring branches by mutation signature; "mutType" for coloring branches by branch tumor type; NULL for coloring automatically.Default is 'mutSig'.
#' @param show.bootstrap logical.Whether to add bootstrap value on internal nodes.Default is TRUE.
#' @param use.box logical.Whether to add box around bootstrap value on tree. Default is TRUE.
#' @param min.ratio double (Default:1/20). If min.ratio is not NULL,
#'  all edge length of a phylogenetic tree should be greater than
#'  min.ratio*the longest edge length.
#'  If not, the edge length will be reset as min.ratio*longest edge length.
#' @param min.mut.count the threshold for the variants in a branch. Default 15.
#' @param signaturesRef The parameter used for deconstructSig. Default "cosmic_v2". Option: "genome_cosmic_v3","exome_cosmic_v3","nature2013".
#' @param patient.id select the specific patients. Default: NULL, all patients are included
#' @param common.col color of common branch which is used for function compareTree.
#' 
#' are mapped along the trees as indicated
#' @examples
#' plotPhyloTree(phyloTree)
#
#' @return return a list of phylotree graph .
#' @import ape ggplot2 ggrepel
#' @export plotPhyloTree
#' 


plotPhyloTree <- function(phyloTree = NULL,
                          patient.id = NULL,
                          branchCol = "mutSig",
                          show.bootstrap = TRUE,
                          use.box = TRUE,
                          common.col = "red",
                          min.ratio = 1/20,
                          min.mut.count = 15,
                          signaturesRef = "cosmic_v2"){
   
   if(!is.null(branchCol)){
       branchCol.options <- c("mutSig","mutType")
       if(!branchCol %in% branchCol.options){
           stop("Type of branchCol can only be 'mutSig','mutType' or NULL")
       }
   }
   if(class(phyloTree) == "phyloTree"){
       phyloTree_list <- list(phyloTree)
   }else if(class(phyloTree) == "phyloTree_list"){
       if(!is.null(patient.id)){
           phyloTree_list <- subset_phyloTree_list(phyloTree,patient.id = patient.id)
       }else{
           phyloTree_list <- phyloTree@patient.list
       }
   }else{
       stop("phyloTree should be class 'phyloTree' or class 'phyloTree_list' generated by function getPhyloTree")
   }
    
    tree_list <- list()
   
   for(phyloTree in phyloTree_list){
       
       patient <- phyloTree@patientID
       
       if(min.ratio <= 0|min.ratio > 1){
           stop("min ratio should be within (0,1]")
       }
       min.len <- max(phyloTree@tree$edge.length)*min.ratio
       phyloTree@tree$edge.length[phyloTree@tree$edge.length < min.len] <- min.len
       
       ## whether plot phylotree for comparing
       if(!is.null(phyloTree@tree$data)){
           treeData <- phyloTree@tree$data
           compare <- TRUE
       }else{
           compare <- FALSE
           treeData <- getTreeData(phyloTree = phyloTree,
                                   branchCol = branchCol,
                                   min.mut.count = min.mut.count,
                                   signaturesRef = signaturesRef)
       }

       ## get title 
       pm <- getPrivateMutation(phyloTree = phyloTree)
       totalMutSum <- pm[[1]]
       privateMutProportion <- pm[[2]]
       
       set.seed(1234)
       myBoots <- phyloTree@bootstrap.value
       rootLabel <- "NORMAL"
       ## plot phylotree
       samplePointsSize <- 3
       sampleTextSize <- 3
       nodePointsSize <- 1.7
       segmentSize <- 1.5
       # nodeStrokeSize <- 0.5
       # sampleStrokeSize <- 1
       nodeStrokeSize <- 0.25
       sampleStrokeSize <- 1.5
       bootLabelSize <- 2.2
       bootTextSize <- 2.2
       bootPaddingSize <- 0.35
       samplesLength <- nrow(treeData[sample != "internal node",]) 
       if(samplesLength > 7){
           samplePointsSize <- 1.5 
           sampleTextSize <- 2
           segmentSize <- 0.8
           nodePointsSize <- 0.8
           # nodeStrokeSize <- 0.25
           # sampleStrokeSize <- 0.5
           nodeStrokeSize <- 0.15
           sampleStrokeSize <- 0.8
           bootLabelSize <- 1.5
           bootTextSize <- 1.5
           bootPaddingSize <- 0.1
       }
       rootNode <- treeData[sample == rootLabel,]$node
       if(length(myBoots) == 1){
           bootsData <- data.frame(x2 = 0, y2 = 0, node = rootNode, end_num = rootNode, boots = myBoots)
       }else{
           sub <- data.table::data.table(x2 = 0, y2 = 0,node = rootNode, end_num = rootNode)
           bootsData <- rbind(treeData[sample == 'internal node',][,.(x2,y2,node,end_num)],sub)
           boots <- c()
           LN <- min(bootsData$node)-1
           for(i in 1:nrow(bootsData)){      
               if(i == nrow(bootsData)){
                   boots <- append(boots,  myBoots[rootNode - LN])
                   next
               }
               boots <- append(boots, myBoots[bootsData$end_num[i] - LN])
               
           }
           bootsData <- cbind(bootsData, boots = boots)
       }
       ## get the max value of X axis 
       x_max <- max(abs(treeData$x2))
       p <- ggplot(data = treeData) + 
           ## balance the space on the left and right sides
           geom_segment(aes(x = 0, y = 0, xend = x_max, yend = 0),color = "white",size = 0.01)+
           geom_segment(aes(x = 0, y = 0, xend = -x_max, yend = 0),color = "white",size = 0.01)
       
       textAdjust <- mean(as.numeric(treeData$distance))
       
       if(!is.null(branchCol)){
           if(branchCol == "mutSig"){
                   color_scale <- getSigColors(unique(treeData$Signature))
                   p <- p + geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2, color = Signature), size=segmentSize)
                   p <- p + scale_color_manual(values = color_scale) + 
                       theme(legend.title = element_text())
           }
           else{
               ## sort branch tumor type 
               all.types <- unique(treeData$Branch_Tumor_ID) 
               public <- all.types[grep("Public", all.types)] 
               shared <- all.types[grep("Shared", all.types)] 
               private <- all.types[grep("Private", all.types)]
               type.level <- c(public, shared, private)
               
               ## get colors
               type_all_colors <- c("#7fc97f","#fdc086", "#E64B35FF", "#1C9F95",
                                    "#186D0E","#519F9D","#950B9F","#78339F",
                                    "#2F4D49", "#439F18", "#971D37","#8C9F3C")
               if(length(type.level) > length(type_all_colors)){
                   left_colors <- sample(colors(),
                                         length(type.level)-length(type_all_colors),
                                         replace = FALSE)
                   type_all_colors <- append(type_all_colors,left_colors)
               }else{
                   type_all_colors <- type_all_colors[1:length(type.level)] 
               }
               names(type_all_colors) <- type.level
               treeData$Branch_Tumor_ID <- factor(treeData$Branch_Tumor_ID, levels = type.level)
               p <- p + geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2, color = factor(Branch_Tumor_ID)), size=segmentSize)
               ## remove legend title
               p <- p +  theme(legend.title = element_blank()) + 
                   scale_color_manual(breaks = type.level, values = type_all_colors)
               # if(identical(type.level,c("Public","Shared","Private"))){
               #     cols <-  c("#7fc97f","#fdc086","#E64B35FF")
               #     p <- p +
               #         scale_color_manual(breaks = type.level,values = cols,
               #                            labels = c("Public","Shared","Private"))
               # }else{
               #     p <- p + scale_fill_discrete(breaks = type.level)
               # }
           }
       }
       else{
           if(compare){
                   p <- p + geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2),
                                         color = common.col,
                                         data = treeData[is.match != "NO"],
                                         size = segmentSize)
                   p <- p + geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2),
                                         color = "black",
                                         data = treeData[is.match == "NO"],size = segmentSize)
           }else{
               p <- p + geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2, color = sample),
                                     data = treeData[!sample %in% c("internal node",rootLabel),], 
                                     size=segmentSize, show.legend = T)
               p <- p + geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2), color = 'black',
                                     data = treeData[sample == rootLabel,], 
                                     size = segmentSize, show.legend = F )
               p <- p + geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2), color = '#67001F',
                                     data = treeData[sample == 'internal node',], 
                                     size = segmentSize, show.legend = F )
           }
       }
       p <- p + theme(axis.title.x = element_blank(),
                      axis.text.x = element_blank(),
                      axis.ticks.x = element_blank(),
                      axis.title.y = element_blank(),
                      axis.text.y = element_blank(),
                      axis.ticks.y = element_blank(),
                      axis.line = element_blank(),
                      panel.grid.major = element_blank(),
                      panel.grid.minor = element_blank(), panel.background = element_blank(),
                      panel.border = element_blank(),
                      # legend.title = element_text(),
                      # legend.title = element_blank(),
                      # legend.direction = "horizontal",
                      legend.position = 'right') + 
           # guides(color = guide_legend(nrow=1))+
           coord_fixed(ratio= 1) +
           scale_x_discrete(expand = expansion(add = mean(treeData$distance)))+
           scale_y_discrete(expand = expansion(add = mean(treeData$distance)/5))
       p <- p + geom_text_repel(aes(x = x2, y = y2, label = sample),
                                nudge_y = textAdjust/10,
                                nudge_x = textAdjust/10,
                                segment.color = "grey",
                                segment.size = 0.25,
                                data = treeData[(!sample %in% c("internal node",rootLabel)) &
                                                    x2 >= 0, ],
                                size = sampleTextSize ,force = 10)
       p <- p + geom_text_repel(aes(x = x2, y = y2, label = sample),
                                nudge_y = textAdjust/10,
                                nudge_x = -textAdjust/10,
                                segment.color = "grey",
                                segment.size = 0.25,
                                data = treeData[(!sample %in% c("internal node",rootLabel)) &
                                                    x2 < 0, ],
                                size = sampleTextSize ,force = 10)
       ## label NORMAL
       p <- p + geom_text(aes(x = x2,y = y2-textAdjust/5),
                          label = rootLabel,
                          data = treeData[sample == rootLabel,], 
                          size = sampleTextSize)
       # }
       
       p <- p + geom_point(aes(x = x2,y = y2),
                           data = treeData[sample == 'internal node',],
                           size = nodePointsSize, color = "#8c510a", fill = "white", shape = 21,
                           stroke = nodeStrokeSize)
       p <- p + geom_point(aes(x = x2, y = y2), 
                           data = treeData[sample != 'internal node',],
                           size = samplePointsSize,color = "#67001F", fill = 'white', shape = 21, stroke = sampleStrokeSize)
       Nd <- treeData[sample == rootLabel,]$distance
       if(length(Nd)!=0){
           if(Nd != 0){
               p <- p + geom_point(aes(x =0 , y = 0), size = nodePointsSize, color = "#8c510a",
                                   fill = 'white', shape = 21, stroke = nodeStrokeSize)
           }
       }
       if(show.bootstrap){
           if(use.box){
               p <- p + geom_label_repel(aes(x = x2, y = y2,label = boots),
                                         data = bootsData,
                                         # nudge_y = textAdjust/6,
                                         fontface = 'bold', size = bootLabelSize, box.padding = unit(bootPaddingSize, "lines"), point.padding = unit(0.5, "lines"),
                                         segment.colour = "grey50", segment.size = 0.25, force = 5)
           }else{
               p <- p + geom_text_repel(aes(x = x2, y = y2,label = boots),
                                        data = bootsData,
                                        fontface = 'bold', size = bootTextSize, box.padding = unit(bootPaddingSize, "lines"), point.padding = unit(0.5, "lines"),
                                        segment.colour = "grey50", segment.size = 0.25, force = 5)
           }
       }
       if(compare){
           p <- p + geom_label_repel(aes(x = x1 + (x2-x1)/2 , y = y1 + (y2 - y1)/2,label = is.match),
                                     data = treeData[is.match != "NO",],
                                     fontface = 'bold', size = bootLabelSize, box.padding = unit(bootPaddingSize, "lines"), point.padding = unit(0.5, "lines"),
                                     segment.colour = "grey50", segment.size = 0.5, force = 5)
       }
       
       if(compare){
           tree.title <- patient
       }else{
           tree.title <- paste(patient,"\n(n = " ,totalMutSum ,"; ",privateMutProportion,")",sep = "")
       }
       p <- p + 
           ggtitle(tree.title)+
           theme(plot.title = element_text(face = "bold",colour = "black", hjust = 0.5))
       
       tree_list[[patient]] <- p
       treeData <- NULL
       
   }
   
   if(length(tree_list)==1){
       return(tree_list[[1]])
   }

   
   return(tree_list)
}