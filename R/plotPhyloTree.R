#' @title plotPhyloTree
#' 
#' @param phyloTree a phyloTree object generated by getphyloTree function.
#' @param show.mutSig logical. Whether to show mutational signature on tree. Default is TRUE.
#' @param show.heatmap logical. Whether to show heatmap of somatic mutations. Default is TRUE.
#' @param heatmap.type character. "binary" (default) for printing a binary heatmap of mutations; or "CCF" for printing a cancer cell frequency (CCF) heatmap. This parameter is only useful when show.mutSig = TRUE.
#' @param use.box logical.Whether to add box arround bootstrap value on tree. Default is TRUE.
#' @examples
#' plotPhyloTree(phyloTree)
#' ## Use ccf 
#' plotPhyloTree(phyloTree, heatmap.type = 'CCF')
#
#' @return Prints plot.
#' @import reshape2 ape ggplot2 deconstructSigs RColorBrewer ggrepel
#' @export plotPhyloTree
#' 

plotPhyloTree <- function(phyloTree = NULL, show.mutSig = TRUE, show.heatmap = TRUE, heatmap.type = 'binary', use.box = TRUE){
  set.seed(123)
  if(heatmap.type == 'binary'){
    use.ccf = FALSE
  }else{
    use.ccf = TRUE
  }
  tree <- phyloTree@nj
  refBuild <- phyloTree@refBuild
  signature <- treeMutationalSig(phyloTree)$mutSigsOutput
  patientID <- phyloTree@patientID
  fileID <- paste(phyloTree@patientID, ".phyloTree", sep = "")
  rootLabel <- 'NORMAL'
  numRoot <- which(tree$tip.label == rootLabel)
  myBoots <- ape::boot.phylo(tree, t(phyloTree@binary.matrix), function(e) root(nj(dist.gene(e)),numRoot),B = 1000)/1000
  ## generate phylotree data
  phylotreeOutputData <- phyloTreeInput(tree, signature, show.mutSig ,rootLabel)
  phylotreeOutputData <- phylotreeOutputData[(phylotreeOutputData$distance!=0|phylotreeOutputData$sample == rootLabel),]
  if(show.mutSig){
    colorScale <- colorSet(unique(phylotreeOutputData$signature))
    fileID <- paste(fileID, ".mutsig", sep = "")
  }
  ## plot phylotree
  P <- generatePlotObject(phylotreeOutputData, colorScale, show.mutSig, rootLabel = rootLabel, myBoots = myBoots, use.box = use.box)
  if(show.heatmap){
    H <- mut.heatmap(phyloTree, use.ccf)
    pm <- getPrivateMutation(phyloTree)
    totalMutSum <- pm[[1]]
    privateMutProportion <- pm[[2]]
    PH <- ggdraw(xlim = c(0.1,0.7)) + draw_plot(P, x = -0.05,y = 0, width = 0.7) + draw_plot(H, x = 0.48,y = -0.12, width = 0.15)
    title <- ggdraw() + draw_label(paste(patientID,"\n(n = " ,totalMutSum ,"; ",privateMutProportion,")",sep = ""),fontface = "bold")
    PH <- plot_grid(title,PH,ncol = 1,rel_heights=c(0.09, 1))+theme(plot.margin=grid::unit(c(0,0,0,0), "mm"))
    # ggsave(filename = paste0(fileID,".pdf"),plot = PH, width = 10, height = 6.5)
    return(PH)
  }
  else{
    return(P)
  }
}
##generate plot data 
phyloTreeInput <- function(tree, signature = '', show.mutSig, rootLabel){
  tree <- ape::root(tree, tree$tip.label[which(tree$tip.label == rootLabel)])
  # tree$edge[which(tree$edge == tree$edge[1,2])] = tree$edge[1,1]
  # tree$edge <- tree$edge[-1,]
  # tree$edge.length <- tree$edge.length[-1]
  # tree$Nnode <- tree$Nnode - 1
  tree$edge.length <- tree$edge.length/100
  edge <-  tree$edge
  distance <- tree$edge.length
  edge <- matrix(c(edge, distance), nrow = length(edge[, 1]))
  numRoot <- which(tree$tip.label == rootLabel)
  rootTip <- numRoot
  #the position of NORMAL in edge 
  rootRow <- which(edge[,2] == numRoot)
  # the  Node connected to NORMAL
  rootNode <- edge[rootRow, 1]
  rootEdge <- edge[rootRow, 3]
  verticalPath <- calVerticalPath(tree,rootLabel)
  branchLabel <- labelBranch(tree)
  numList <- calChildNodeNum(tree)
  #store the sample name or node in a list
  nameList <- c('')
  #Store the list of nodes by plot order
  nodeList <- c(rootNode)
  #X1, y1 are the starting point, x2 and y2 are the end point.Horizon stands for the Angle between the line and the positive x axis;W stands for the Angle occupied by branches (explained in the paper)
  #Distance means distance;Node is the internal node with the start;End_num is the number of each node in edge;
  treeData <- data.frame('x1'=0, 'y1' = 0, 'x2' = 0, 'y2' = 0, 'horizon' = pi/2,
                          'w' = 1/6*pi, 'distance' = 0, 'node' = 0, 'end_num' = 0,
                          'angle' = 0)
  
  setPhyloTree <- function(subEdge, x0, y0, w, horizon, nameList,
                           treeData, pointList, targetNode, rootNode, edgeRemain){
    #total vertex of tree
    totalVertexs = 0
    #Stores the list of angles
    angleList = c()
    #Stores the list of vertexes
    vertexList = c()
    vertexSub = 0
    angle = 0
    for(i in 1 : length(pointList)){
        #if it is sample, the number of vertices plus one
        if(pointList[i] <= length(tree$tip.label)){
            totalVertexs <- totalVertexs + 1
            vertexList <- append(vertexList, 1)
        }
        else{
            totalVertexs <- totalVertexs + numList[pointList[i]]
            vertexList <- append(vertexList, numList[pointList[i]])
            vertexSub <- 0
        }
    } 
    for(i in 1 : length(vertexList)){
      angleSub <- (vertexList[i]/totalVertexs)*w
      #Assign angles and put them into a list
      angleList  <- append(angleList, angleSub)
    }
    #Calculate the Angle with the X axis
    angleList2 <- c()
    for(i in 1:length(angleList)){
      if(i == 1){
        angle=(pi-w)/2 + angleList [i]/2 + horizon - pi/2
      }else{
        angle <- angle+angleList [(i-1)]/2 + angleList [i]/2 + horizon - pi/2
      }
      # if(angle == horizon){
      #   if(horizon >= pi/2){
      #     angle <- angle + pi/144
      #   }
      #   else{
      #     angle <- angle - pi/144
      #   }
      # }
      angleList2 <- append(angleList2, angle)
    }
    # x <- which(!(subEdge[,2] %in% verticalPath))
    # if(horizon == pi/2){
    #   if(angleList2[x] < pi/2 &
    #      as.numeric(subEdge[x,2]) > length(tree$tip.label)){
    #     angleList2[x] <- angleList2[x] - pi/18
    #   }
    #   else if(angleList2[x] > pi/2 &
    #           as.numeric(subEdge[x,2]) > length(tree$tip.label)){
    #     angleList2[x] <- angleList2[x] + pi/18
    #   }
    # }
    ## Angle adjustment (select a branch Angle to align with the previous internal node)
    a <- which(subEdge[,2] %in% verticalPath)
    if(length(a) != 0){
      if(targetNode == rootNode){
        # if(subEdge[a,2] > length(tree$tip.label)){
        #   angleList2[a[1]] <- horizon
        # }
        # else{
        #   a <- which(vertexList == max(vertexList))
        #   if(length(a) > 1){
        #     a <- which(subEdge[,3] == max(subEdge[,3]))
        #   }
        #   angleList2[a[1]] <- horizon
        # }
        angleList2[a[1]] <- horizon
      }
      else{
        angleList2[a[1]] <- horizon
        ##xxx
        l <- treeData[(treeData$angle > pi/2&treeData$end_num!= numRoot),]$end_num
        left <- sum(unlist(lapply(l ,function(x){return(numList[x])})))
        r <- treeData[(treeData$angle < pi/2&treeData$end_num!= numRoot),]$end_num
        right <- sum(unlist(lapply(r,function(x){return(numList[x])})))
        if(left > right){
          if(angleList2[which(angleList2 != horizon)]> pi/2){
            angleList2[which(angleList2 != horizon)] <- abs(pi - angleList2[which(angleList2 != horizon)])
          }
        }
        else if(left < right){
          if(angleList2[which(angleList2 != horizon)] < pi/2){
            angleList2[which(angleList2 != horizon)] <- abs(pi - angleList2[which(angleList2 != horizon)])
          }
        }
      }
    }
    else{
      a <- which(vertexList == max(vertexList))
      if(length(a) > 1){
        a <- which(subEdge[,3] == max(subEdge[,3]))
      }
      angleList2[a[1]] <- horizon
    }
    x <- which(angleList2!= pi/2)
    if(length(x) == 1){
      if(horizon == pi/2){
        if(angleList2[x] < pi/2 &
           as.numeric(subEdge[x,2]) > length(tree$tip.label)){
          angleList2[x] <- angleList2[x] - pi/18
        }
        else if(angleList2[x] > pi/2 &
                as.numeric(subEdge[x,2]) > length(tree$tip.label)){
          angleList2[x] <- angleList2[x] + pi/18
        }
      }
    }
    i = 1
    while (i <= length(subEdge[,1])) {
      if(pointList[i] > length(tree$tip.label)){
        n <- 'internal node'
      }
      #If the number is greater than the length label of labels, it is an internal node, otherwise it is a sample
      else {
        n <- tree$tip.label[pointList[i]]
      }
      #Merge the sample name into a list for coloring
      nameList <- append(nameList, n)
      #get the distance 
      distance <- as.numeric(subEdge[i,3])
      #Calculate the coordinate
      angle <- angleList2[i]
      # if(angle <= 34*pi/36 & angle >= 30*pi/36){
      # angle = angle - pi/12
      # }
      # if(angle <= 8*pi/36 & angle >= 4*pi/36){
      #  angle = angle + pi/12
      # }
      if(angle == pi/2){
        x <- x0
      }
      else{
        x <- cos(angle)*distance + x0
      }
      y <- sin(angle)*distance + y0
      #Merge data
      row <- list(x0, y0, x, y, horizon, angleList[i],
                  distance, targetNode, pointList[i], angle)
      treeData <- rbind(treeData, row)
      i <- i+1
    }
    #Return the data of the plotting and the list of sample names
    result <- list(treeData, nameList)
    return(result)
  }
  t=1
  while(t <= tree$Nnode){
    #The first diagram is of the internal node connected to NORMAL
    targetNode <- nodeList[t]
    #he position of the target t node in the matrix (the first data point is to find the NORMAL)
    rowList <- c()
    for(i1 in 1:length(edge[, 1])){
      if(targetNode %in% edge[i1,1:2]){
        if(edge[i1,2] != numRoot){
          rowList <- append(rowList, i1)
        }
      }
    }
    #Filter out the submatrix with target_node
    subEdge <- matrix(edge[rowList, ], nrow = length(rowList))
    #Edge removes the sub_edge matrix
    edge <- edge[-rowList, ]
    #Extract the point that is concatenated with targe_node and put it in the list
    pointList <- c()
    for( i2 in 1 : length(subEdge[, 1])){
      point <- subEdge[i2, 1 : 2][subEdge[i2, 1 : 2] != targetNode]
      pointList <- append(pointList, point)
    }
    #first internal node(NORMAL)
    if(t == 1){
      pn <- setPhyloTree(subEdge, 0, 0, pi*2/3, pi/2, nameList, 
                          treeData, pointList, targetNode, rootNode, edge)
      treeData <- pn[[1]]
      nameList <- pn[[2]]
      rootInfo <- list(0, 0, 0, -(rootEdge), 0, pi/2, rootEdge, rootNode, numRoot, 0)
      treeData <- rbind(treeData, rootInfo)
      nameList <- append(nameList, "NORMAL")
    }
    else{
      #Find the current starting coordinate in the plot data
      rowNum <- which(treeData$end_num == targetNode)
      pn <- setPhyloTree(subEdge, treeData$x2[rowNum], treeData$y2[rowNum],
                          treeData$w[rowNum], treeData$angle[rowNum], nameList, treeData, pointList,
                          targetNode, rootNode, edge)
      treeData <- pn[[1]]
      nameList <- pn[[2]]
    }
    nodeList<-append(nodeList, pointList[pointList>length(tree$tip.label)])
    t=t+1 
  }
  #Add the sample_name to the plot data
  treeData <- cbind(treeData, sample = nameList)
  treeData <- treeData[-1, ]
  #Adjust Angle of non-NORMAL sample and internal nodes
  t=1
  while(t <= length(treeData[, 1])){
    if (all(treeData$end_num[t] <= length(tree$tip.label),
            treeData$sample[t] != 'internal node',
            treeData$sample[t] != rootLabel,
            treeData$angle[t] != treeData$horizon[t])){
      #the angles less than ninety degrees are adjust to thirty degrees
      if(treeData$x1[t] > 0){
        treeData$angle[t] <- pi*(1/6-1/36) 
        angle <- treeData$angle[t]
        treeData$x2[t] <- treeData$distance[t]*cos(angle) + treeData$x1[t]
        treeData$y2[t] <- treeData$distance[t]*sin(angle) + treeData$y1[t]}
      else if(treeData$x1[t] < 0){
        treeData$angle[t] <- pi*(5/6+1/36) 
        angle <- treeData$angle[t]
        treeData$x2[t] <- treeData$distance[t]*cos(angle) + treeData$x1[t]
        treeData$y2[t] <- treeData$distance[t]*sin(angle) + treeData$y1[t]}
      else{
        if(treeData$angle[t] < pi/2){
          treeData$angle[t] <- pi*(1/6-1/36) 
          angle <- treeData$angle[t]
          treeData$x2[t] <- treeData$distance[t]*cos(angle) + treeData$x1[t]
          treeData$y2[t] <- treeData$distance[t]*sin(angle) + treeData$y1[t]}
        else if(treeData$angle[t] > pi/2){
          treeData$angle[t] <- pi*(5/6+1/36)
          angle <- treeData$angle[t]
          treeData$x2[t] <- treeData$distance[t]*cos(angle) + treeData$x1[t]
          treeData$y2[t] <- treeData$distance[t]*sin(angle) + treeData$y1[t]}
      }
    }
    t = t + 1
  }
  #right part of tree
  sampleRight <- treeData[which(treeData$sample != 'internal node' & 
                                    treeData$sample != rootLabel &
                                    treeData$x2 >= 0&treeData$angle != treeData$horizon),]
  listRight <- as.character(sampleRight[order(sampleRight$y1,decreasing = F),]$end_num)
  listRight <- append(listRight,verticalPath[1])
  #left part of tree
  sampleLeft <- treeData[which(treeData$sample!='internal node' & 
                                   treeData$sample!=rootLabel & 
                                   treeData$x2 <= 0&treeData$angle != treeData$horizon),]
  listLeft <- as.character(sampleLeft[order(sampleLeft$y1,decreasing = F),]$end_num)
  listLeft <- append(listLeft,verticalPath[1])
  #Adjust the Angle again
  t=1
  adjustNodeList <- c()
  while(t <= length(treeData[,1])){
    row <- ''
    row1 <- ''
    if(all(treeData$end_num[t] <= length(tree$tip.label),
           treeData$sample[t] != 'internal node',
           treeData$sample[t] != rootLabel,
           treeData$angle[t] != treeData$horizon[t])){
      # if(nrow(treeData[treeData$x2 > 0,]) == 2|nrow(treeData[treeData$x2 < 0,]) == 2){
      #   break
      # }
      internalNode <- treeData$node[t]
      row1 <- which(treeData$end_num == internalNode)
      if (length(row1) != 0){
        adjustNode <- treeData$node[row1]
        if(adjustNode == rootNode){
          t <- t+1
          next
        }
        if(adjustNode %in% adjustNodeList){
          t <- t+1
          next
        }else{
          if(length(numRoot)== 0){
            break
          }
          if(treeData$distance[row1] < mean(tree$edge.length)/5){
            row <- which(treeData$node == adjustNode&
                           treeData$end_num <= length(tree$tip.label))
            row2 <- which(treeData$node == treeData$end_num[row1] &
                            treeData$angle != treeData$horizon &  
                            treeData$end_num <= length(tree$tip.label))
            if(length(row)!=0 & length(row2)!=0){
              if(treeData$angle[row] < pi/2 &
                 treeData$angle[row2] < pi/2 &
                 treeData$sample[row] == listRight[1]){
                if(nrow(treeData[treeData$x2 > 0,]) == 2){
                  break
                }
                treeData$angle[row] <- treeData$angle[row] - pi*1/10
                angle <- treeData$angle[row]
                treeData$x2[row] <- treeData$distance[row]*cos(angle) + treeData$x1[row]
                treeData$y2[row] <- treeData$distance[row]*sin(angle) + treeData$y1[row]
              }
              else if(treeData$angle[row] > pi/2 &
                      treeData$angle[row2] > pi/2 &
                      treeData$sample[row] == listLeft[length(listLeft)]){
                if(nrow(treeData[treeData$x2 < 0,]) == 2){
                  break
                }
                if(treeData$angle[row] == max(treeData$angle)){
                  treeData$angle[row] <- treeData$angle[row] + pi*1/10
                  angle <- treeData$angle[row]
                  treeData$x2[row] <- treeData$distance[row]*cos(angle)+treeData$x1[row]
                  treeData$y2[row] <- treeData$distance[row]*sin(angle)+treeData$y1[row]
                }
              }
            }
          }
          adjustNodeList <- append(adjustNodeList, adjustNode)
        }
      }
    }
    t = t + 1
  }
  ##Bisect the branches angle
  bisectBranchAngle <- function(listPart, treeData){
      t = F
      while(t == F){
          # if(length(listPart) == 1|length(listPart) == 2){
          #   break
          # }
          if(length(listPart) == 1 |length(listPart) == 2){
              break
          }
          else if(length(listPart) == 3){
              judgeAngle <- treeData$angle[which(treeData$end_num == listPart[1])]
              if(judgeAngle > 0 & judgeAngle < pi/2){
                  firstAngle <- treeData$angle[which(treeData$end_num==listPart[1])] 
                  finalAngle <- pi/2
                  row <- which(treeData$end_num == listPart[2])
                  angle <- (finalAngle - firstAngle)/2 + firstAngle
                  treeData$x2[row] <- treeData$distance[row]*cos(angle) + treeData$x1[row]
                  treeData$y2[row] <- treeData$distance[row]*sin(angle) + treeData$y1[row]
                  break
              }
              else if(judgeAngle > pi/2 & judgeAngle < pi){
                  firstAngle <- pi/2
                  finalAngle <- treeData$angle[which(treeData$end_num==listPart[1])] 
                  row <- which(treeData$end_num == listPart[2])
                  angle <- (finalAngle - firstAngle)/2 + firstAngle
                  treeData$x2[row] <- treeData$distance[row]*cos(angle) + treeData$x1[row]
                  treeData$y2[row] <- treeData$distance[row]*sin(angle) + treeData$y1[row]
                  break
              }
              else{
                  break
              }
          }else{
              #Judge whether the adjustment area is on the left or right
              judgeAngle <- treeData$angle[which(treeData$end_num == listPart[1])]
              if(length(judgeAngle != 0)){
                  if(judgeAngle < pi/2){
                      firstAngle <-treeData$angle[which(treeData$end_num == listPart[1])] 
                      finalAngle <- pi/2
                      partTotalNodes <- length(listPart)
                      averageAngle <- (finalAngle - firstAngle)/(partTotalNodes - 2)
                      angle <- firstAngle+averageAngle
                      for(i in 2:(length(listPart)-1)){
                          row <- which(treeData$end_num == listPart[i])
                          treeData$x2[row] <- treeData$distance[row]*cos(angle) + treeData$x1[row]
                          treeData$y2[row] <- treeData$distance[row]*sin(angle) + treeData$y1[row]
                          angle = angle+averageAngle
                      }
                      break
                  }
                  else{
                      firstAngle <- pi/2 
                      finalAngle <- treeData$angle[which(treeData$end_num == listPart[1])]
                      partTotalNodes <- length(listPart)
                      averageAngle <- (finalAngle - firstAngle)/(partTotalNodes - 2)
                      angle <- firstAngle+averageAngle
                      for(i in 2 : (length(listPart) - 1)){
                          row <- which(treeData$end_num == listPart[i])
                          treeData$x2[row] <- treeData$distance[row]*cos(angle) + treeData$x1[row]
                          treeData$y2[row] <- treeData$distance[ row]*sin(angle) + treeData$y1[row]
                          angle <- angle+averageAngle
                      }
                      break
                  }
              }
              else{break}
          }
      }
      return(treeData)
  }
  treeData <- bisectBranchAngle(listLeft, treeData)
  treeData <- bisectBranchAngle(listRight, treeData)
  # Adjust the Angle of data with only two samples
  if(nrow(treeData) == 3){
    angleList <- c(pi/6, 5*pi/6)
    for(i in 2:nrow(treeData)){
      angle <- angleList[i - 1]
      treeData$angle[i] <- angle
      treeData$x2[i] <- treeData$distance[i]*cos(angle)
      treeData$y2[i] <- treeData$distance[i]*sin(angle)
    }
  }
  if(show.mutSig){
    treeData$label <- ""
    for(i in 1:nrow(treeData)){
      if(treeData$sample[i] == "NORMAL"){
        treeData$label[i] <- branchLabel[[rootNode]]
      }
      else{
        if(treeData$end_num[i] > length(tree$tip.label)){
          treeData$label[i] <- branchLabel[[treeData$end_num[i]]]
        }
        else{
          treeData$label[i] <- as.character(treeData$sample[i]) 
        }
      }
    }
    treeData <- addSignature(tree, treeData, signature)
  }
  return(treeData)
}
##add signature
addSignature <- function(tree, treeData, signature){
  #add signature to treeData
  treeData$signature <- ''
  treeData$alias <- ''
  sigs <- strsplit(as.character(signature$branch),"∩")
  sigs <- lapply(sigs, function(x){return(paste(sort(x,decreasing = T),collapse = "∩"))})
  t <- 1
  while(t<=length(sigs)){
    pos <- which(treeData$label == sigs[[t]])
    treeData$signature[pos] <- as.character(signature$sig[t]) 
    treeData$alias[pos] <- as.character(signature$alias[t])
    t <- t + 1
  }
  if(treeData$signature[which(treeData$sample == 'NORMAL')] == ''){
    treeData$signature[which(treeData$sample == 'NORMAL')] = as.character(signature$sig[1])
    treeData$signature[which(treeData$alias == 'NORMAL')] = as.character(signature$alias[1])
  }
  treeData <- treeData[order(treeData$signature), ]
  treeData$signature <- gsub('No Signature', 'No signature', treeData$signature)
  treeData$signature <- gsub('Signature ', '', treeData$signature)
  return(treeData)
}
##color scale set
colorSet <- function(signatures){
  allColorScale <- c("#E41A1C","#377EB8","#7F0000",
                       "#35978f","#FC8D62","#2166ac",
                       "#E78AC3","#A6D854","#FFD92F",
                       "#E5C494","#8DD3C7", "#6E016B" ,
                       "#BEBADA", "#e08214", "#80B1D3",
                       "#d6604d","#ffff99","#FCCDE5",
                       "#FF6A5A","#BC80BD","#CCEBC5" ,
                       "#fb9a99","#B6646A", "#9F994E", 
                       "#7570B3" ,"#c51b7d" ,"#66A61E" ,
                       "#E6AB02" ,"#003c30", "#666666",'black')
  allSignature <- append(gsub('Signature.', '',row.names(deconstructSigs::signatures.cosmic)), 'No signature')
  colorScale <- c()
  for(i in 1:length(signatures)){
    color <- allColorScale[which(allSignature == signatures[i])]
    colorScale <- append(colorScale, color)
  }
  if('black' %in% colorScale){
    num <- which(colorScale == 'black')
    colorScale <- colorScale[-num]
    colorScale <- append(colorScale, 'black')
  }
  return(colorScale)
}
## plot PhyloTree 
generatePlotObject <- function(treeData, colorScale = '', show.mutSig, rootLabel, myBoots, use.box){
  myBoots <- myBoots*100
  rootNode <- treeData$node[which(treeData$sample == rootLabel)]
  bootsData <- rbind(treeData[treeData$sample == 'internal node',][,c(3,4,8,9)],c(0,0,rootNode,rootNode))
  boots <- c()
  LN <- min(bootsData$node)-1
  for(i in 1:nrow(bootsData)){      
      if(i == nrow(bootsData)){
          boots <- append(boots,  myBoots[rootNode - LN])
          next
      }
      boots <- append(boots, myBoots[bootsData$end_num[i] - LN])

  }
  bootsData <- cbind(bootsData, boots = boots)
  p <- ggplot(data = treeData)
  textAdjust <- mean(as.numeric(treeData$distance))
  dy <- max(treeData$y2)-min(treeData$y2)
  dx <- max(treeData$x2)-min(treeData$x2)
  if(show.mutSig){
    p <- p + geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2, color = signature), size=1.5)
    p <- p + scale_color_manual(values = colorScale)
  }
  else{
    p <- p + geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2, color = sample),
                          data = treeData[treeData$sample != rootLabel&treeData$sample != 'internal node',], 
                          size=1.5, show.legend = T)
    p <- p + geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2), color = 'black',
                          data = treeData[treeData$sample == rootLabel,], 
                          size = 1.5, show.legend = F )
    p <- p + geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2), color = '#67001F',
                          data = treeData[treeData$sample == 'internal node',], 
                          size = 1.5, show.legend = F )
  }
  p <- p + theme(axis.title.x = element_blank(),
                 axis.text.x = element_blank(),
                 axis.ticks.x = element_blank(),
                 axis.title.y = element_blank(),
                 axis.text.y = element_blank(),
                 axis.ticks.y = element_blank(),
                 axis.line = element_blank(),
                 panel.grid.major = element_blank(),
                 panel.grid.minor = element_blank(), panel.background = element_blank(),
                 panel.border = element_blank(),
                 legend.title = element_text(face="bold"),
                 legend.position = 'top',
                 legend.direction = "horizontal") + guides(color = guide_legend(nrow=1))+coord_fixed(ratio= 1)               
  p <- p + geom_text_repel(aes(x = x2*1.5, y = y2, label = sample),vjust = 1,
                             nudge_y = textAdjust/6, segment.alpha = 0,
                             data = treeData[(treeData$sample != 'internal node'&treeData$sample != rootLabel), ],
                             fontface = 'bold', size = 3)
  # p <- p + geom_text_repel(aes(x = x2, y = y2,label = boots),
  #                          data = bootsData[bootsData$x2 < 0,],box.padding=unit(0, "lines"),point.padding=unit(0, "lines"),
  #                          fontface = 'bold', size = 2.2,
  #                          segment.colour = "grey50",segment.size = 0.5,force = 10)
  # p <- p + geom_text(aes(x = x2, y = y2, label = boots),
  #                          data = bootsData,hjust=0, vjust=0,
  #                          fontface = 'bold', size = 2.8)
  p <- p + geom_text_repel(aes(x = x2,y = y2), label = rootLabel, vjust = 0, 
                             nudge_y = -textAdjust/5, segment.alpha = 0,
                             data = treeData[(treeData$sample == rootLabel),], 
                             fontface = 'bold', size = 3)
  #Leaf nodes and internal nodes are distinguished by point size
  # p <- p + geom_point(aes(x = x2,y = y2),
  #                     data = treeData[treeData$sample == 'internal node',],
  #                     size = 2, color = "grey50", fill = "grey50", shape = 21,
  #                     stroke = 0.5)
  p <- p + geom_point(aes(x = x2,y = y2),
                      data = treeData[treeData$sample == 'internal node',],
                      size = 1.7, color = "#8c510a", fill = "white", shape = 21,
                      stroke = 0.5)
  p <- p + geom_point(aes(x = x2, y = y2), 
                      data = treeData[treeData$sample != 'internal node',],
                      size = 3,color = "#67001F", fill = 'white', shape = 21, stroke = 1)
  # if(phylotree.type!= "phyloTree"){
  #   p <- p + geom_point(x = 0, y = 0, 
  #                       size = 3, color = "#8c510a", fill = 'white', shape = 21, stroke = 1)
  # }
  Nd <- treeData$distance[which(treeData$sample == rootLabel)]
  if(length(Nd)!=0){
    if(Nd != 0){
      # p <- p + geom_point(aes(x =0 , y = 0), size = 1.7, color = "grey50",
      #                     fill = 'grey50', shape = 21, stroke = 0.5)
      p <- p + geom_point(aes(x =0 , y = 0), size = 1.7, color = "#8c510a",
                          fill = 'white', shape = 21, stroke = 0.5)
    }
  }
  if(use.box){
      p <- p + geom_label_repel(aes(x = x2, y = y2,label = boots),
                               data = bootsData,
                               fontface = 'bold', size = 2.2,box.padding=unit(0, "lines"),point.padding=unit(0, "lines"),
                               segment.colour = "grey50",segment.size = 0.5,force = 10)
  }else{
      p <- p + geom_text_repel(aes(x = x2, y = y2,label = boots),
                               data = bootsData,
                               fontface = 'bold', size = 2.2,box.padding=unit(0, "lines"),point.padding=unit(0, "lines"),
                               segment.colour = "grey50",segment.size = 0.5,force = 10)
  }
  return(p)
}

getPrivateMutation <- function(phyloTree){
  totalMut <- phyloTree@mut.branches
  privateOrder <- unlist(lapply(names(totalMut),
                                 function(x){return(length(strsplit(x,"∩")[[1]]) == 1)})) 
  privateMut <- totalMut[privateOrder]
  countMutation <- function(mut){
    sum <- 0
    for(i in 1:length(mut)){
      count <- nrow(mut[[i]])
      sum <- sum + count
    }
    return(sum)
  }
  totalMutSum <- countMutation(totalMut)
  privateMutSum <- countMutation(privateMut)
  privateMutProportion <- paste(round((privateMutSum/totalMutSum)*100,1),"%",sep = "")
  return(list(totalMutSum, privateMutProportion))
}

calVerticalPath <- function(tree,rootLabel){
  #Generate the adjacency matrix
  edge <-  tree$edge
  #Add the third column of the matrix to the node distance
  distance <- tree$edge.length
  edge <- matrix(c(edge, distance), nrow = length(edge[, 1]))
  if(rootLabel == "NORMAL"){
    numRoot <- which(tree$tip.label == rootLabel)
    #the position of NORMAL in edge 
    rootRow <- which(edge[,2] == numRoot)
    # the  Node connected to NORMAL
    rootNode <- edge[rootRow, 1]
    edge <- edge[-rootRow,]
  }
  else{
    numRoot <- length(tree$tip.label) + 1
    # the  Node connected to NORMAL
    rootNode <- numRoot
    rootTip <- numRoot
  }
  distanceTable <- data.frame(x = 0)
  for(i in 1:(length(tree$tip.label)-1)){
    distanceTable <- cbind(distanceTable, -1)
  }
  distanceTable <- distanceTable[,(-1)]
  if(rootLabel == "NORMAL"){
    names(distanceTable) <- tree$tip.label[which(tree$tip.label != rootLabel)]
  }
  else{
    distanceTable <- cbind(distanceTable, -1)
    names(distanceTable) <- tree$tip.label
  }
  t <- 1
  path <- list()
  while(t <= length(distanceTable)){
    subPath <- c()
    end <- t
    dis <- 0
    while (TRUE) {
      p <- which(edge[,2] == end)
      dis <- dis + edge[p,3]
      start <- edge[p,1]
      subPath <- append(subPath,end)
      end <- start
      if(start == rootNode){
        break
      }
    }
    path[[t]] <- subPath
    distanceTable[t] <- dis
    t <- t + 1
  }
  result <- path[[which.max(distanceTable)]]
}
## label sample in each branch                            
labelBranch <- function(tree){
  Root <- which(tree$tip.label == "NORMAL")
  internalNodes <- sort(unique(tree$edge[,1]))
  result <- list()
  for(i in 1:(length(tree$edge.length)+1)){
    result[[i]] <- NA
  }
  end <- tree$edge[which(tree$edge[,2] == Root),1]
  for(i in 1:length(tree$tip.label)){
    row <- tree$edge[which(tree$edge[,2] == i), ]
    if(i == Root){
      next
    }
    while (TRUE) {
      node <- row[1]
      if(node == end){
        result[[node]] <- append(result[[node]], i)
        break
      }
      else{
        result[[node]] <- append(result[[node]], i)
        row <- tree$edge[which(tree$edge[,2] == node),]
      }
    }
  }
  g <- lapply(result, function(x){return(paste(sort(tree$tip.label[x[-1]], decreasing = T),collapse = "∩"))})
  return(g)
}
calChildNodeNum <- function(tree){
   edge <- tree$edge
   numRoot <- which(tree$tip.label == "NORMAL")
   rootRow <- which(edge[,2] == numRoot)
   rootNode <- edge[rootRow, 1] 
   num <- length(tree$edge.length)+1
   numList <- c()
   for(i in 1:num){
       numList[i] <- 1
   }
   for(i in 1:num){
       if(i == rootNode){
           next
       }
       startNum <- i
       endNum <- as.numeric(edge[which(tree$edge[,2] == i),1])
       while(TRUE){
           numList[endNum] <- numList[endNum] + 1
           if(endNum == rootNode){
               break
           }
           startNum <- as.numeric(edge[which(tree$edge[,2] == endNum),2]) 
           endNum <- as.numeric(edge[which(tree$edge[,2] == endNum),1]) 
       }
   }
   return(numList)
}

