#' @title plotPhyloTree
#' 
#' @param phyloTree phyloTree or phyloTreeList object generated by getPhyloTree function.
#' @param patient.id Select the specific patients. Default: NULL, all patients are included.
#' @param branchCol Specify the colors of branches (Default: NULL). Other options: "mutType" for coloring branches by branch tumor type; "mutSig" for coloring branches by mutation signature. 
#' @param show.bootstrap Logical. Whether to add bootstrap value on internal nodes.Default is TRUE.
#' @param use.box Logical. Whether to add box around bootstrap value on tree. Default is TRUE.
#' @param min.ratio Double (Default:1/20). If min.ratio is not NULL,
#'  all edge length of a phylogenetic tree should be greater than
#'  min.ratio*the longest edge length.
#'  If not, the edge length will be reset as min.ratio*longest edge length.
#' @param signaturesRef Signature reference,Users can upload their own reference. Default "cosmic_v2". Option:"exome_cosmic_v3","nature2013".
#' @param min.mut.count The threshold for the variants in a branch. Default 15.
#' 
#' are mapped along the trees as indicated
#' @examples
#' plotPhyloTree(phyloTree)
#
#' @return return a list of phylotree graph .
#' @import ape ggplot2 ggrepel
#' @export plotPhyloTree
#' 


plotPhyloTree <- function(phyloTree,
                          patient.id = NULL,
                          branchCol = "mutType",
                          show.bootstrap = TRUE,
                          use.box = TRUE,
                          min.ratio = 1/20,
                          signaturesRef = "cosmic_v2",
                          min.mut.count = 15){
   
   if(!is.null(branchCol)){
       branchCol.options <- c("mutSig","mutType")
       if(!branchCol %in% branchCol.options){
           stop("Error: branchCol can only be NULL, 'mutType' or 'mutSig'.")
       }
   }
    ## check input data
    phyloTree_list <- checkPhyloTreeInput(phyloTree,patient.id = patient.id)
    
    tree_list <- list()
   
   for(phyloTree in phyloTree_list){
       
       patient <- getPhyloTreePatient(phyloTree)
       
       if(min.ratio <= 0|min.ratio > 1){
           stop("Error: min.ratio should be within (0,1]")
       }
       
       ## adjust length of branches  by min.ratio
       tree <- getTree(phyloTree)
       min.len <- max(tree$edge.length)*min.ratio
       tree$edge.length[tree$edge.length < min.len] <- min.len
       phyloTree@tree <- tree
       
       ## inner parameter for function compareTree 
       if(!is.null(tree$data)){
           treeData <- tree$data
           common.col <- tree$common.col
           compare <- TRUE
       }else{
           compare <- FALSE
           treeData <- getTreeData(phyloTree = phyloTree,
                                   branchCol = branchCol,
                                   signaturesRef = signaturesRef,
                                   min.mut.count = min.mut.count)
       }

       ## get title 
       set.seed(1234)
       boot_value <- getBootstrapValue(phyloTree)
       rootLabel <- "NORMAL"
       ## plot phylotree
       samplePointsSize <- 3
       sampleTextSize <- 3
       nodePointsSize <- 1.7
       segmentSize <- 1.5
       # nodeStrokeSize <- 0.5
       # sampleStrokeSize <- 1
       nodeStrokeSize <- 0.25
       sampleStrokeSize <- 1.5
       bootLabelSize <- 2.2
       bootTextSize <- 2.2
       bootPaddingSize <- 0.35
       samplesLength <- nrow(treeData[sample != "internal node",]) 
       if(samplesLength > 7){
           samplePointsSize <- 1.5 
           sampleTextSize <- 3
           segmentSize <- 0.8
           nodePointsSize <- 0.8
           # nodeStrokeSize <- 0.25
           # sampleStrokeSize <- 0.5
           nodeStrokeSize <- 0.15
           sampleStrokeSize <- 0.8
           bootLabelSize <- 2
           bootTextSize <- 1.5
           bootPaddingSize <- 0.1
       }
       rootNode <- treeData[sample == rootLabel,]$node
       if(length(boot_value) == 1){
           bootsData <- data.frame(x2 = 0, y2 = 0, node = rootNode, end_num = rootNode, boots = boot_value)
       }else{
           sub <- data.table::data.table(x2 = 0, y2 = 0,node = rootNode, end_num = rootNode)
           bootsData <- rbind(treeData[sample == 'internal node',][,.(x2,y2,node,end_num)],sub)
           boots <- c()
           LN <- min(bootsData$node)-1
           for(i in 1:nrow(bootsData)){      
               if(i == nrow(bootsData)){
                   boots <- append(boots,  boot_value[rootNode - LN])
                   next
               }
               boots <- append(boots, boot_value[bootsData$end_num[i] - LN])
               
           }
           bootsData <- cbind(bootsData, boots = boots)
       }
       ## get the max value of X axis 
       x_max <- max(abs(treeData$x2))
       p <- ggplot(data = treeData) + 
           ## balance the space on the left and right sides
           geom_segment(aes(x = 0, y = 0, xend = x_max, yend = 0),color = "white",size = 0.01)+
           geom_segment(aes(x = 0, y = 0, xend = -x_max, yend = 0),color = "white",size = 0.01)
       
       textAdjust <- mean(as.numeric(treeData$distance))
       
       if(!is.null(branchCol)){
           if(branchCol == "mutSig"){
                   color_scale <- getSigColors(as.character(unique(treeData$Signature)) )
                   sig_level <- levels(treeData$Signature)
                   p <- p + geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2, color = Signature), size=segmentSize)
                   p <- p + scale_color_manual(breaks = sig_level ,values = color_scale) + 
                       theme(legend.title = element_text())
           }
           else{
               ## sort branch tumor type 
               all.types <- unique(treeData$Mutation_Type) 
               public <- all.types[grep("Public", all.types)] 
               shared <- all.types[grep("Shared", all.types)] 
               private <- all.types[grep("Private", all.types)]
               type.level <- c(public, shared, private)
               
               ## get colors
               type_all_colors <- c("#7fc97f","#fdc086", "#E64B35FF", "#82166E",
                                    "#B77B42","#6349B7","#D5017D","#B77562",
                                    "#88A4FF", "#439F18", "#971D37","#8C9F3C")
               if(length(type.level) > length(type_all_colors)){
                   left_colors <- sample(colors(),
                                         length(type.level)-length(type_all_colors),
                                         replace = FALSE)
                   type_all_colors <- append(type_all_colors,left_colors)
               }else{
                   type_all_colors <- type_all_colors[1:length(type.level)] 
               }
               names(type_all_colors) <- type.level
               treeData$Mutation_Type <- factor(treeData$Mutation_Type, levels = type.level)
               p <- p + geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2, color = factor(Mutation_Type)), size=segmentSize)
               ## remove legend title
               p <- p +  theme(legend.title = element_blank()) + 
                   scale_color_manual(breaks = type.level, values = type_all_colors)
               # if(identical(type.level,c("Public","Shared","Private"))){
               #     cols <-  c("#7fc97f","#fdc086","#E64B35FF")
               #     p <- p +
               #         scale_color_manual(breaks = type.level,values = cols,
               #                            labels = c("Public","Shared","Private"))
               # }else{
               #     p <- p + scale_fill_discrete(breaks = type.level)
               # }
           }
       }
       else{
           if(compare){
                   p <- p + geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2),
                                         color = common.col,
                                         data = treeData[is.match != "NO"],
                                         size = segmentSize)
                   p <- p + geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2),
                                         color = "black",
                                         data = treeData[is.match == "NO"],size = segmentSize)
           }else{
               p <- p + geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2), color = "black",
                                     data = treeData, 
                                     size=segmentSize, show.legend = F)
               # p <- p + geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2, color = sample),
               #                       data = treeData[!sample %in% c("internal node",rootLabel),], 
               #                       size=segmentSize, show.legend = T)
               # p <- p + geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2), color = 'black',
               #                       data = treeData[sample == rootLabel,], 
               #                       size = segmentSize, show.legend = F )
               # p <- p + geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2), color = '#67001F',
               #                       data = treeData[sample == 'internal node',], 
               #                       size = segmentSize, show.legend = F )
               
           }
       }
       p <- p + theme(axis.title.x = element_blank(),
                      axis.text.x = element_blank(),
                      axis.ticks.x = element_blank(),
                      axis.title.y = element_blank(),
                      axis.text.y = element_blank(),
                      axis.ticks.y = element_blank(),
                      axis.line = element_blank(),
                      panel.grid.major = element_blank(),
                      panel.grid.minor = element_blank(), panel.background = element_blank(),
                      panel.border = element_blank(),
                      # legend.margin = margin(0),
                      # legend.title = element_blank(),
                      # legend.direction = "horizontal",
                      legend.position = 'right') + 
           # guides(color = guide_legend(nrow=1))+
           scale_x_discrete(expand = expansion(add = mean(treeData$distance)))+
           # scale_y_discrete(expand = expansion(add = mean(treeData$distance)/5)) + 
           coord_fixed(ratio= 1)
       p <- p + geom_text_repel(aes(x = x2, y = y2, label = sample),
                                nudge_y = textAdjust/10,
                                nudge_x = textAdjust/10,
                                segment.color = "grey",
                                segment.size = 0.25,
                                data = treeData[(!sample %in% c("internal node",rootLabel)) &
                                                    x2 >= 0, ],
                                size = sampleTextSize ,force = 10)
       p <- p + geom_text_repel(aes(x = x2, y = y2, label = sample),
                                nudge_y = textAdjust/10,
                                nudge_x = -textAdjust/10,
                                segment.color = "grey",
                                segment.size = 0.25,
                                data = treeData[(!sample %in% c("internal node",rootLabel)) &
                                                    x2 < 0, ],
                                size = sampleTextSize ,force = 10)
       ## label NORMAL
       p <- p + geom_text(aes(x = x2,y = y2-textAdjust/5),
                          label = rootLabel,
                          data = treeData[sample == rootLabel,], 
                          size = sampleTextSize)
       # }
       
       p <- p + geom_point(aes(x = x2,y = y2),
                           data = treeData[sample == 'internal node',],
                           size = nodePointsSize, color = "#8c510a", fill = "white", shape = 21,
                           stroke = nodeStrokeSize)
       p <- p + geom_point(aes(x = x2, y = y2), 
                           data = treeData[sample != 'internal node',],
                           size = samplePointsSize,color = "#67001F", fill = 'white', shape = 21, stroke = sampleStrokeSize)
       Nd <- treeData[sample == rootLabel,]$distance
       if(length(Nd)!=0){
           if(Nd != 0){
               p <- p + geom_point(aes(x =0 , y = 0), size = nodePointsSize, color = "#8c510a",
                                   fill = 'white', shape = 21, stroke = nodeStrokeSize)
           }
       }
       if(show.bootstrap){
           if(use.box){
               p <- p + geom_label_repel(aes(x = x2, y = y2,label = boots),
                                         data = bootsData,
                                         # nudge_y = textAdjust/6,
                                         fontface = 'bold', size = bootLabelSize, box.padding = unit(bootPaddingSize, "lines"), point.padding = unit(0.5, "lines"),
                                         segment.colour = "grey50", segment.size = 0.25, force = 5)
           }else{
               p <- p + geom_text_repel(aes(x = x2, y = y2,label = boots),
                                        data = bootsData,
                                        fontface = 'bold', size = bootTextSize, box.padding = unit(bootPaddingSize, "lines"), point.padding = unit(0.5, "lines"),
                                        segment.colour = "grey50", segment.size = 0.25, force = 5)
           }
       }
       if(compare){
           p <- p + geom_label_repel(aes(x = x1 + (x2-x1)/2 , y = y1 + (y2 - y1)/2,label = is.match),
                                     data = treeData[is.match != "NO",],
                                     fontface = 'bold', size = bootLabelSize, box.padding = unit(bootPaddingSize, "lines"), point.padding = unit(0.5, "lines"),
                                     segment.colour = "grey50", segment.size = 0.5, force = 5)
       }
       
       if(compare){
           tree.title <- patient
       }else{
           tree.title <- paste(patient," (n=" ,nrow(getBinaryMatrix(phyloTree)) ,")",sep = "")
       }
       p <- p + 
           ggtitle(tree.title)+
           theme(plot.title = element_text(face = "bold",colour = "black", hjust = 0.5,size = 13.5))
       
       tree_list[[patient]] <- p
       treeData <- NULL
       
   }
   
   if(length(tree_list)==1){
       return(tree_list[[1]])
   }else if(length(tree_list) == 0){
       return(NA)
   }else{
       return(tree_list)
   }

}