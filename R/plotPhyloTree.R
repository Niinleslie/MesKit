#' A phylogenetic tree painter
#' 
#' 
#' @param njtree a njtree object generated by NJtree function.
#' @param showMutSig logical. Whether to show mutational signature on tree. Default is TRUE.
#' @param sigName Choose "alias" when you want showing alias in branch.
#' @param showHeatmap logical. Whether to show heatmap of somatic mutations. Default is TRUE.
#' @param heatmapType character. "binary" (default) for printing a binary heatmap of mutations; or "CCF" for printing a cancer cell frequency (CCF) heatmap. This parameter is only useful when show.mutSig = TRUE.
#' @examples
#' plotPhyloTree(njtree)
#' ## Use ccf 
#' plotPhyloTree(njtree, heatmap.type = 'CCF')
#
#' @return Prints plot.
#' @import reshape2 ape ggplot2 deconstructSigs RColorBrewer ggrepel
#' @export plotPhyloTree
#' 

plotPhyloTree <- function(njtree = NULL, showMutSig = TRUE, sigName = "default", showHeatmap = TRUE, heatmapType = 'binary'){
  if(heatmapType == 'binary'){
    use.ccf = FALSE
  }else{
    use.ccf = TRUE
  }
  # if(is.null(njtree)){
  #     stop("You need to generate njtree using NJtree.R")
  # }
  phylo <- njtree@nj
  refBuild <- njtree@refBuild
  signature <- treeMutationalSig(njtree)$mutSigsOutput
  patientID <- njtree@patientID
  fileID <- paste(njtree@patientID, ".NJtree", sep = "")
  rootLabel <- 'NORMAL'
  # generate phylotree data
  phylotreeOutputData <- phylotreeInput(phylo, signature, showMutSig ,rootLabel)
  phylotreeOutputData <- phylotreeOutputData[(phylotreeOutputData$distance!=0|phylotreeOutputData$sample == rootLabel),]
  if(showMutSig){
    #Set the color
    colorScale <- colorSet(unique(phylotreeOutputData$signature))
    fileID <- paste(fileID, ".mutsig", sep = "")
  }
  #plot phylotree
  phylotree <- generatePlotObject(phylotreeOutputData, colorScale, showMutSig, sigName = sigName, rootLabel = rootLabel)
  if(showHeatmap){
    heatmap <- mut.heatmap(njtree, use.ccf)
    pm <- getPrivateMutation(njtree)
    totalMutSum <- pm[[1]]
    privateMutProportion <- pm[[2]]
    PH <- ggdraw(xlim = c(0.1,0.7)) + draw_plot(phylotree, x = -0.05,y = 0, width = 0.7) + draw_plot(heatmap, x = 0.46,y = -0.12, width = 0.15)
    title <- ggdraw() + draw_label(paste(patientID,"\n(n = " ,totalMutSum ,"; ",privateMutProportion,")",sep = ""),fontface = "bold")
    PH <- plot_grid(title,PH,ncol = 1,rel_heights=c(0.09, 1))+theme(plot.margin=grid::unit(c(0,0,0,0), "mm"))
    # ggsave(filename = "./tree",plot = PH, width = 10, height = 6.5)
    return(PH)
  }
  else{
    return(phylotree)
  }
}
##generate plot data 
phylotreeInput <- function(phylo, signature = '', showMutSig, rootLabel){
  phylo <- ape::root(phylo, phylo$tip.label[which(phylo$tip.label == rootLabel)])
  # phylo$edge[which(phylo$edge == phylo$edge[1,2])] = phylo$edge[1,1]
  # phylo$edge <- phylo$edge[-1,]
  # phylo$edge.length <- phylo$edge.length[-1]
  # phylo$Nnode <- phylo$Nnode - 1
  phylo$edge.length <- phylo$edge.length/100
  edge <-  phylo$edge
  distance <- phylo$edge.length
  edge <- matrix(c(edge, distance), nrow = length(edge[, 1]))
  numRoot <- which(phylo$tip.label == rootLabel)
  rootTip <- numRoot
  #the position of NORMAL in edge 
  rootRow <- which(edge[,2] == numRoot)
  # the  Node connected to NORMAL
  rootNode <- edge[rootRow, 1]
  rootEdge <- edge[rootRow, 3]
  verticalPath <- calVerticalPath(phylo,rootLabel)
  branchLabel <- labelBranch(phylo)
  #store the sample name or node in a list
  nameList <- c('')
  #Store the list of nodes by plot order
  nodeList <- c(rootNode)
  #X1, y1 are the starting point, x2 and y2 are the end point.Horizon stands for the Angle between the line and the positive x axis;W stands for the Angle occupied by branches (explained in the paper)
  #Distance means distance;Node is the internal node with the start;End_num is the number of each node in edge;
  plotData <- data.frame('x1'=0, 'y1' = 0, 'x2' = 0, 'y2' = 0, 'horizon' = pi/2,
                          'w' = 1/6*pi, 'distance' = 0, 'node' = 0, 'end_num' = 0,
                          'angle' = 0)
  
  setPhylotree <- function(subEdge, x0, y0, w, horizon, nameList,
                           plotData, pointList, targetNode, rootNode, edgeRemain){
    #total vertex of tree
    totalVertexs = 0
    #Stores the list of angles
    angleList = c()
    #Stores the list of vertexes
    vertexList = c()
    vertexSub = 0
    angle = 0
    for(i in 1 : length(pointList)){
      #if it is sample, the number of vertices plus one
      if(pointList[i] <= length(phylo$tip.label)){
        totalVertexs <- totalVertexs + 1
        vertexList <- append(vertexList, 1)
      }
      #If it is an internal node, it counts several vertices connected to the internal node
      else{
        if(length(pointList[pointList > length(phylo$tip.label )]) == 1){
          totalVertexs <- totalVertexs+length(edgeRemain[, 1])
          vertexSub <- length(edgeRemain[, 1])
        }
        else{
          for(i1 in 1 : length(edgeRemain[, 1])){
            if(pointList[i] %in% edgeRemain[i1, ]){
              totalVertexs <- totalVertexs + 1
              vertexSub <- vertexSub + 1
            } 
          }
        }
        vertexList <- append(vertexList, (vertexSub))
        vertexSub <- 0
      }
    }
    #if(w <= pi/6 ){
    #w <- w + pi/6
    #}
    #The Angle assignment is based on the proportion of the number of vertices
    for(i in 1 : length(vertexList)){
      angleSub <- (vertexList[i]/totalVertexs)*w
      #Assign angles and put them into a list
      angleList  <- append(angleList, angleSub)
    }
    #Calculate the Angle with the X axis
    angleList2 <- c()
    for(i in 1:length(angleList)){
      if(i == 1){
        angle=(pi-w)/2 + angleList [i]/2 + horizon - pi/2
      }else{
        angle <- angle+angleList [(i-1)]/2 + angleList [i]/2 + horizon - pi/2
      }
      # if(angle == horizon){
      #   if(horizon >= pi/2){
      #     angle <- angle + pi/144
      #   }
      #   else{
      #     angle <- angle - pi/144
      #   }
      # }
      angleList2 <- append(angleList2, angle)
    }
    # x <- which(!(subEdge[,2] %in% verticalPath))
    # if(horizon == pi/2){
    #   if(angleList2[x] < pi/2 &
    #      as.numeric(subEdge[x,2]) > length(phylo$tip.label)){
    #     angleList2[x] <- angleList2[x] - pi/18
    #   }
    #   else if(angleList2[x] > pi/2 &
    #           as.numeric(subEdge[x,2]) > length(phylo$tip.label)){
    #     angleList2[x] <- angleList2[x] + pi/18
    #   }
    # }
    ## Angle adjustment (select a branch Angle to align with the previous internal node)
    a <- which(subEdge[,2] %in% verticalPath)
    if(length(a) != 0){
      if(targetNode == rootNode){
        # if(subEdge[a,2] > length(phylo$tip.label)){
        #   angleList2[a[1]] <- horizon
        # }
        # else{
        #   a <- which(vertexList == max(vertexList))
        #   if(length(a) > 1){
        #     a <- which(subEdge[,3] == max(subEdge[,3]))
        #   }
        #   angleList2[a[1]] <- horizon
        # }
        angleList2[a[1]] <- horizon
      }
      else{
        angleList2[a[1]] <- horizon
        ##xxx
        left <- nrow(plotData[(plotData$angle > pi/2&plotData$end_num!= numRoot),])
        right <- nrow(plotData[(plotData$angle < pi/2&plotData$end_num!= numRoot),])-1
        if(left > right){
          if(angleList2[which(angleList2 != horizon)]> pi/2){
            angleList2[which(angleList2 != horizon)] <- abs(pi - angleList2[which(angleList2 != horizon)])
          }
        }
        else if(left < right){
          if(angleList2[which(angleList2 != horizon)] < pi/2){
            angleList2[which(angleList2 != horizon)] <- abs(pi - angleList2[which(angleList2 != horizon)])
          }
        }
      }
    }
    else{
      a <- which(vertexList == max(vertexList))
      if(length(a) > 1){
        a <- which(subEdge[,3] == max(subEdge[,3]))
      }
      angleList2[a[1]] <- horizon
    }
    x <- which(angleList2!= pi/2)
    if(length(x) == 1){
      if(horizon == pi/2){
        if(angleList2[x] < pi/2 &
           as.numeric(subEdge[x,2]) > length(phylo$tip.label)){
          angleList2[x] <- angleList2[x] - pi/18
        }
        else if(angleList2[x] > pi/2 &
                as.numeric(subEdge[x,2]) > length(phylo$tip.label)){
          angleList2[x] <- angleList2[x] + pi/18
        }
      }
    }
    i = 1
    while (i <= length(subEdge[,1])) {
      if(pointList[i] > length(phylo$tip.label)){
        n <- 'internal node'
      }
      #If the number is greater than the length label of labels, it is an internal node, otherwise it is a sample
      else {
        n <- phylo$tip.label[pointList[i]]
      }
      #Merge the sample name into a list for coloring
      nameList <- append(nameList, n)
      #get the distance 
      distance <- as.numeric(subEdge[i,3])
      #Calculate the coordinate
      angle <- angleList2[i]
      # if(angle <= 34*pi/36 & angle >= 30*pi/36){
      # angle = angle - pi/12
      # }
      # if(angle <= 8*pi/36 & angle >= 4*pi/36){
      #  angle = angle + pi/12
      # }
      if(angle == pi/2){
        x <- x0
      }
      else{
        x <- cos(angle)*distance + x0
      }
      y <- sin(angle)*distance + y0
      #Merge data
      row <- list(x0, y0, x, y, horizon, angleList[i],
                  distance, targetNode, pointList[i], angle)
      plotData <- rbind(plotData, row)
      i <- i+1
    }
    #Return the data of the plotting and the list of sample names
    result <- list(plotData, nameList)
    return(result)
  }
  t=1
  while(t <= phylo$Nnode){
    #The first diagram is of the internal node connected to NORMAL
    targetNode <- nodeList[t]
    #he position of the target t node in the matrix (the first data point is to find the NORMAL)
    rowList <- c()
    for(i1 in 1:length(edge[, 1])){
      if(targetNode %in% edge[i1,1:2]){
        if(edge[i1,2] != numRoot){
          rowList <- append(rowList, i1)
        }
      }
    }
    #Filter out the submatrix with target_node
    subEdge <- matrix(edge[rowList, ], nrow = length(rowList))
    #Edge removes the sub_edge matrix
    edge <- edge[-rowList, ]
    #Extract the point that is concatenated with targe_node and put it in the list
    pointList <- c()
    for( i2 in 1 : length(subEdge[, 1])){
      point <- subEdge[i2, 1 : 2][subEdge[i2, 1 : 2] != targetNode]
      pointList <- append(pointList, point)
    }
    #first internal node(NORMAL)
    if(t == 1){
      pn <- setPhylotree(subEdge, 0, 0, pi*2/3, pi/2, nameList, 
                          plotData, pointList, targetNode, rootNode, edge)
      plotData <- pn[[1]]
      nameList <- pn[[2]]
      rootInfo <- list(0, 0, 0, -(rootEdge), 0, pi/2, rootEdge, rootNode, numRoot, 0)
      plotData <- rbind(plotData, rootInfo)
      nameList <- append(nameList, "NORMAL")
    }
    else{
      #Find the current starting coordinate in the plot data
      rowNum <- which(plotData$end_num == targetNode)
      pn <- setPhylotree(subEdge, plotData$x2[rowNum], plotData$y2[rowNum],
                          plotData$w[rowNum], plotData$angle[rowNum], nameList, plotData, pointList,
                          targetNode, rootNode, edge)
      plotData <- pn[[1]]
      nameList <- pn[[2]]
    }
    nodeList<-append(nodeList, pointList[pointList>length(phylo$tip.label)])
    t=t+1 
  }
  #Add the sample_name to the plot data
  plotData <- cbind(plotData, sample = nameList)
  plotData <- plotData[-1, ]
  #Adjust Angle of non-NORMAL sample and internal nodes
  t=1
  while(t <= length(plotData[, 1])){
    if (all(plotData$end_num[t] <= length(phylo$tip.label),
            plotData$sample[t] != 'internal node',
            plotData$sample[t] != rootLabel,
            plotData$angle[t] != plotData$horizon[t])){
      #the angles less than ninety degrees are adjust to thirty degrees
      if(plotData$x1[t] > 0){
        plotData$angle[t] <- pi*(1/6-1/36) 
        angle <- plotData$angle[t]
        plotData$x2[t] <- plotData$distance[t]*cos(angle) + plotData$x1[t]
        plotData$y2[t] <- plotData$distance[t]*sin(angle) + plotData$y1[t]}
      else if(plotData$x1[t] < 0){
        plotData$angle[t] <- pi*(5/6+1/36) 
        angle <- plotData$angle[t]
        plotData$x2[t] <- plotData$distance[t]*cos(angle) + plotData$x1[t]
        plotData$y2[t] <- plotData$distance[t]*sin(angle) + plotData$y1[t]}
      else{
        if(plotData$angle[t] < pi/2){
          plotData$angle[t] <- pi*(1/6-1/36) 
          angle <- plotData$angle[t]
          plotData$x2[t] <- plotData$distance[t]*cos(angle) + plotData$x1[t]
          plotData$y2[t] <- plotData$distance[t]*sin(angle) + plotData$y1[t]}
        else if(plotData$angle[t] > pi/2){
          plotData$angle[t] <- pi*(5/6+1/36)
          angle <- plotData$angle[t]
          plotData$x2[t] <- plotData$distance[t]*cos(angle) + plotData$x1[t]
          plotData$y2[t] <- plotData$distance[t]*sin(angle) + plotData$y1[t]}
      }
    }
    t = t + 1
  }
  #right part of tree
  t=1
  sampleRight <- plotData[which(plotData$sample != 'internal node' & 
                                    plotData$sample != rootLabel &
                                    plotData$angle <= pi/2 & 
                                    plotData$angle > 0&
                                    plotData$angle != plotData$horizon), ]
  while(t <= length(sampleRight[, 1])){
    u=1
    while(u <= (length(sampleRight[, 1]) - 1)){
      if (sampleRight$y1[u] == sampleRight$y1[(u + 1)]){
        if (sampleRight$angle[u] < sampleRight$angle[(u + 1)]){
          u <- u+1
          next
        }else{
          dataOne <- sampleRight[u, ]
          dataTwo <- sampleRight[(u+1), ]
          sampleRight[(u+1), ] <- dataOne
          sampleRight[(u), ] <- dataTwo
          u <- u+1; next
        }
      }
      else if(sampleRight$y1[u]>sampleRight$y1[(u+1)]){
        dataOne <- sampleRight[u, ]
        dataTwo <- sampleRight[(u + 1),]
        sampleRight[(u+1), ] <- dataOne
        sampleRight[(u), ] <- dataTwo
        u <- u+1
        next
      }else{
        u <- u+1
        next
      }
      u <- u + 1
    }
    t <- t+ 1
  }
  listRight <- as.character(sampleRight$sample)
  #left part of tree
  t <- 1
  sampleLeft <- plotData[which(plotData$sample!='internal node' & 
                                   plotData$sample!=rootLabel & 
                                   plotData$angle >= pi/2 & 
                                   plotData$angle < pi&
                                   plotData$angle != plotData$horizon), ]
  while(t<=length(sampleLeft[, 1])){
    u=1
    while(u<=(length(sampleLeft[, 1]) - 1)){
      if(sampleLeft$y1[u] == sampleLeft$y1[(u+1)]){
        if(sampleLeft$angle[u]<sampleLeft$angle[(u+1)]){
          u=u+1
          next
        }else{
          dataOne <- sampleLeft[u, ]
          dataTwo <- sampleLeft[(u+1), ]
          sampleLeft[(u+1), ] <- dataOne
          sampleLeft[(u), ] <- dataTwo
          u <- u+1
          next
        }
      }
      else if (sampleLeft$y1[u] < sampleLeft$y1[(u + 1)]){
        dataOne <- sampleLeft[u, ]
        dataTwo <- sampleLeft[(u+1), ]
        sampleLeft[(u+1), ] <- dataOne
        sampleLeft[(u), ] <- dataTwo
        u <- u+1
        next
      }else{
        u <- u+1
        next
      }
      u <- u+1
    }
    t <- t+1
  }
  listLeft <- as.character(sampleLeft$sample)
  #Adjust the Angle again
  t=1
  adjustNodeList <- c()
  while(t <= length(plotData[,1])){
    row <- ''
    row1 <- ''
    if(all(plotData$end_num[t] <= length(phylo$tip.label),
           plotData$sample[t] != 'internal node',
           plotData$sample[t] != rootLabel,
           plotData$angle[t] != plotData$horizon[t])){
      # if(nrow(plotData[plotData$x2 > 0,]) == 2|nrow(plotData[plotData$x2 < 0,]) == 2){
      #   break
      # }
      internalNode <- plotData$node[t]
      row1 <- which(plotData$end_num == internalNode)
      if (length(row1) != 0){
        adjustNode <- plotData$node[row1]
        if(adjustNode == rootNode){
          t <- t+1
          next
        }
        if(adjustNode %in% adjustNodeList){
          t <- t+1
          next
        }else{
          if(length(numRoot)== 0){
            break
          }
          if(plotData$distance[row1] < mean(phylo$edge.length)/5){
            row <- which(plotData$node == adjustNode&
                           plotData$end_num <= length(phylo$tip.label))
            row2 <- which(plotData$node == plotData$end_num[row1] &
                            plotData$angle != plotData$horizon &  
                            plotData$end_num <= length(phylo$tip.label))
            if(length(row)!=0 & length(row2)!=0){
              if(plotData$angle[row] < pi/2 &
                 plotData$angle[row2] < pi/2 &
                 plotData$sample[row] == listRight[1]){
                if(nrow(plotData[plotData$x2 > 0,]) == 2){
                  break
                }
                plotData$angle[row] <- plotData$angle[row] - pi*1/10
                angle <- plotData$angle[row]
                plotData$x2[row] <- plotData$distance[row]*cos(angle) + plotData$x1[row]
                plotData$y2[row] <- plotData$distance[row]*sin(angle) + plotData$y1[row]
              }
              else if(plotData$angle[row] > pi/2 &
                      plotData$angle[row2] > pi/2 &
                      plotData$sample[row] == listLeft[length(listLeft)]){
                if(nrow(plotData[plotData$x2 < 0,]) == 2){
                  break
                }
                if(plotData$angle[row] == max(plotData$angle)){
                  plotData$angle[row] <- plotData$angle[row] + pi*1/10
                  angle <- plotData$angle[row]
                  plotData$x2[row] <- plotData$distance[row]*cos(angle)+plotData$x1[row]
                  plotData$y2[row] <- plotData$distance[row]*sin(angle)+plotData$y1[row]
                }
              }
            }
          }
          adjustNodeList <- append(adjustNodeList, adjustNode)
        }
      }
    }
    t = t + 1
  }
  ##Bisect the branches angle
  bisectBranchAngle <- function(listPart, plotData){
    t = F
    while(t == F){
      # if(length(listPart) == 1|length(listPart) == 2){
      #   break
      # }
      if(length(listPart) == 1){
        break
      }
      else if(length(listPart) == 2){
        judgeAngle <- plotData$angle[which(plotData$sample == listPart[1])]
        if(judgeAngle > 0 & judgeAngle < pi/2 & nrow(plotData[plotData$x2 > 0,]) == 2){
          firstAngle <- plotData$angle[which(plotData$sample==listPart[1])] 
          finalAngle <- pi/2
          row <- which(plotData$sample == listPart[2])
          angle <- (finalAngle - firstAngle)/2 + firstAngle
          plotData$x2[row] <- plotData$distance[row]*cos(angle) + plotData$x1[row]
          plotData$y2[row] <- plotData$distance[row]*sin(angle) + plotData$y1[row]
          break
        }
        else if(judgeAngle > pi/2 & judgeAngle < pi & nrow(plotData[plotData$x2 < 0,]) == 2){
          firstAngle <- pi/2
          finalAngle <- plotData$angle[which(plotData$sample==listPart[2])] 
          row <- which(plotData$sample == listPart[1])
          angle <- (finalAngle - firstAngle)/2 + firstAngle
          plotData$x2[row] <- plotData$distance[row]*cos(angle) + plotData$x1[row]
          plotData$y2[row] <- plotData$distance[row]*sin(angle) + plotData$y1[row]
          break
        }
        else{
          break
        }
      }
      else if(length(listPart)==3){
        firstAngle <-plotData$angle[which(plotData$sample==listPart[1])] 
        finalAngle <- plotData$angle[which(plotData$sample==listPart[length(listPart)])]
        partTotalNodes <- length(listPart)
        averageAngle <- (finalAngle - firstAngle)/partTotalNodes
        angle <- firstAngle+averageAngle
        for(i in 2 : (length(listPart) - 1)){
          row <- which(plotData$sample == listPart[i])
          plotData$x2[row] <- plotData$distance[row]*cos(angle) + plotData$x1[row]
          plotData$y2[row] <- plotData$distance[row]*sin(angle) + plotData$y1[row]
          angle <- angle + averageAngle
        }
        break
      }else{
        #Judge whether the adjustment area is on the left or right
        judgeAngle <- plotData$angle[which(plotData$sample == listPart[2])]
        if(length(judgeAngle != 0)){
          if(judgeAngle > pi/2){
            firstAngle <-plotData$angle[which(plotData$sample == listPart[1])] 
            finalAngle <- plotData$angle[which(plotData$sample == listPart[length(listPart) - 2])]
            partTotalNodes <- length(listPart)
            averageAngle <- (finalAngle - firstAngle)/(partTotalNodes - 2)
            angle <- firstAngle+averageAngle
            for(i in 2:(length(listPart)-2)){
              row <- which(plotData$sample == listPart[i])
              plotData$x2[row] <- plotData$distance[row]*cos(angle) + plotData$x1[row]
              plotData$y2[row] <- plotData$distance[row]*sin(angle) + plotData$y1[row]
              angle = angle+averageAngle
            }
            break
          }
          else{
            firstAngle <- plotData$angle[which(plotData$sample == listPart[2])] 
            finalAngle <- plotData$angle[which(plotData$sample == listPart[length(listPart)])]
            partTotalNodes <- length(listPart)
            averageAngle <- (finalAngle - firstAngle)/(partTotalNodes - 2)
            angle <- firstAngle+averageAngle
            for(i in 3 : (length(listPart) - 1)){
              row <- which(plotData$sample == listPart[i])
              plotData$x2[row] <- plotData$distance[row]*cos(angle) + plotData$x1[row]
              plotData$y2[row] <- plotData$distance[ row]*sin(angle) + plotData$y1[row]
              angle <- angle+averageAngle
            }
            break
          }
        }
        else{break}
      }
    }
    return(plotData)
  }
  plotData <- bisectBranchAngle(listLeft, plotData)
  plotData <- bisectBranchAngle(listRight, plotData)
  # Adjust the Angle of data with only two samples
  if(nrow(plotData) == 3){
    angleList <- c(pi/6, 5*pi/6)
    for(i in 2:nrow(plotData)){
      angle <- angleList[i - 1]
      plotData$angle[i] <- angle
      plotData$x2[i] <- plotData$distance[i]*cos(angle)
      plotData$y2[i] <- plotData$distance[i]*sin(angle)
    }
  }
  if(showMutSig){
    plotData$label <- ""
    for(i in 1:nrow(plotData)){
      if(plotData$sample[i] == "NORMAL"){
        plotData$label[i] <- branchLabel[[rootNode]]
      }
      else{
        if(plotData$end_num[i] > length(phylo$tip.label)){
          plotData$label[i] <- branchLabel[[plotData$end_num[i]]]
        }
        else{
          plotData$label[i] <- as.character(plotData$sample[i]) 
        }
      }
    }
    plotData <- addSignature(phylo, plotData, signature)
  }
  return(plotData)
}
##add signature
addSignature <- function(phylo, plotData, signature){
  #add signature to plotData
  plotData$signature <- ''
  plotData$alias <- ''
  sigs <- strsplit(as.character(signature$branch),"∩")
  sigs <- lapply(sigs, function(x){return(paste(sort(x,decreasing = T),collapse = "∩"))})
  t <- 1
  while(t<=length(sigs)){
    pos <- which(plotData$label == sigs[[t]])
    plotData$signature[pos] <- as.character(signature$sig[t]) 
    plotData$alias[pos] <- as.character(signature$alias[t])
    t <- t + 1
  }
  if(plotData$signature[which(plotData$sample == 'NORMAL')] == ''){
    plotData$signature[which(plotData$sample == 'NORMAL')] = as.character(signature$sig[1])
    plotData$signature[which(plotData$alias == 'NORMAL')] = as.character(signature$alias[1])
  }
  plotData <- plotData[order(plotData$signature), ]
  plotData$signature <- gsub('No Signature', 'No signature', plotData$signature)
  plotData$signature <- gsub('Signature ', '', plotData$signature)
  return(plotData)
}
##color scale set
colorSet <- function(signatures){
  allColorScale <- c("#E41A1C","#377EB8","#7F0000",
                       "#35978f","#FC8D62","#2166ac",
                       "#E78AC3","#A6D854","#FFD92F",
                       "#E5C494","#8DD3C7", "#6E016B" ,
                       "#BEBADA", "#e08214", "#80B1D3",
                       "#d6604d","#ffff99","#FCCDE5",
                       "#FF6A5A","#BC80BD","#CCEBC5" ,
                       "#fb9a99","#B6646A", "#9F994E", 
                       "#7570B3" ,"#c51b7d" ,"#66A61E" ,
                       "#E6AB02" ,"#003c30", "#666666",'black')
  allSignature <- append(gsub('Signature.', '',row.names(deconstructSigs::signatures.cosmic)), 'No signature')
  colorScale <- c()
  for(i in 1:length(signatures)){
    color <- allColorScale[which(allSignature == signatures[i])]
    colorScale <- append(colorScale, color)
  }
  if('black' %in% colorScale){
    num <- which(colorScale == 'black')
    colorScale <- colorScale[-num]
    colorScale <- append(colorScale, 'black')
  }
  return(colorScale)
}
## plot PhyloTree 
generatePlotObject <- function(plotData, colorScale = '', showMutSig, sigName, rootLabel){
  p <- ggplot(data = plotData)
  textAdjust <- mean(as.numeric(plotData$distance))
  dy <- max(plotData$y2)-min(plotData$y2)
  dx <- max(plotData$x2)-min(plotData$x2)
  if(showMutSig){
    p <- p + geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2, color = signature), size=1.5)
    p <- p + scale_color_manual(values = colorScale)
  }
  else{
    p <- p + geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2, color = sample),
                          data = plotData[plotData$sample != rootLabel&plotData$sample != 'internal node',], 
                          size=1.5, show.legend = T)
    p <- p + geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2), color = 'black',
                          data = plotData[plotData$sample == rootLabel,], 
                          size = 1.5, show.legend = F )
    p <- p + geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2), color = '#67001F',
                          data = plotData[plotData$sample == 'internal node',], 
                          size = 1.5, show.legend = F )
  }
  p <- p + theme(axis.title.x = element_blank(),
                 axis.text.x = element_blank(),
                 axis.ticks.x = element_blank(),
                 axis.title.y = element_blank(),
                 axis.text.y = element_blank(),
                 axis.ticks.y = element_blank(),
                 axis.line = element_blank(),
                 panel.grid.major = element_blank(),
                 panel.grid.minor = element_blank(), panel.background = element_blank(),
                 panel.border = element_blank(),
                 legend.title = element_text(face="bold"),
                 legend.position = 'top',
                 legend.direction = "horizontal") + guides(color = guide_legend(nrow=1))+coord_fixed(ratio= 1)               
  if(sigName == "default"){
    p <- p + geom_text_repel(aes(x = x2*1.5, y = y2, label = sample),vjust = 1,
                             nudge_y = textAdjust/5, segment.alpha = 0,
                             data = plotData[(plotData$sample != 'internal node'&plotData$sample != rootLabel), ],
                             fontface = 'bold', size = 3)
  }
  else{
    p <- p + geom_text_repel(aes(x = x2*1.2, y = y2, label = alias),vjust = 1,
                             nudge_y = textAdjust/8, segment.alpha = 0,
                             data = plotData[(plotData$sample != 'internal node'&plotData$sample != rootLabel), ],
                             fontface = 'bold', size = 4) 
  }
  if(sigName == "default"){
    p <- p + geom_text_repel(aes(x = x2,y = y2), label = rootLabel, vjust = 0, 
                             nudge_y = -textAdjust/5, segment.alpha = 0,
                             data = plotData[(plotData$sample == rootLabel),], 
                             fontface = 'bold', size = 3)
  }
  else{
    p <- p + geom_text_repel(aes(x = x2,y = y2), label = "T", vjust = 0, 
                             nudge_y = -textAdjust/5, segment.alpha = 0,
                             data = plotData[(plotData$sample == rootLabel),], 
                             fontface = 'bold', size = 4)
  }
  #Leaf nodes and internal nodes are distinguished by point size
  p <- p + geom_point(aes(x = x2,y = y2), 
                      data = plotData[plotData$sample == 'internal node',],
                      size = 1.7, color = "#8c510a", fill = "#8c510a", shape = 21, 
                      stroke = 0.5)
  p <- p + geom_point(aes(x = x2, y = y2), 
                      data = plotData[plotData$sample != 'internal node',],
                      size = 3,color = "#67001F", fill = 'white', shape = 21, stroke = 1)
  # if(phylotree.type!= "njtree"){
  #   p <- p + geom_point(x = 0, y = 0, 
  #                       size = 3, color = "#8c510a", fill = 'white', shape = 21, stroke = 1)
  # }
  Nd <- plotData$distance[which(plotData$sample == rootLabel)]
  if(length(Nd)!=0){
    if(Nd != 0){
      p <- p + geom_point(aes(x =0 , y = 0), size = 1.7, color = "#8c510a",
                          fill = '#8c510a', shape = 21, stroke = 0.5)
    }
  }
  return(p)
}

getPrivateMutation <- function(njtree){
  totalMut <- njtree@mut_branches
  privateOrder <- unlist(lapply(names(totalMut),
                                 function(x){return(length(strsplit(x,"∩")[[1]]) == 1)})) 
  privateMut <- totalMut[privateOrder]
  countMutation <- function(mut){
    sum <- 0
    for(i in 1:length(mut)){
      count <- nrow(mut[[i]])
      sum <- sum + count
    }
    return(sum)
  }
  totalMutSum <- countMutation(totalMut)
  privateMutSum <- countMutation(privateMut)
  privateMutProportion <- paste(round((privateMutSum/totalMutSum)*100,1),"%",sep = "")
  return(list(totalMutSum, privateMutProportion))
}

calVerticalPath <- function(phylo,rootLabel){
  #Generate the adjacency matrix
  edge <-  phylo$edge
  #Add the third column of the matrix to the node distance
  distance <- phylo$edge.length
  edge <- matrix(c(edge, distance), nrow = length(edge[, 1]))
  if(rootLabel == "NORMAL"){
    numRoot <- which(phylo$tip.label == rootLabel)
    numRoot <- which(phylo$tip.label == rootLabel)
    #the position of NORMAL in edge 
    rootRow <- which(edge[,2] == numRoot)
    # the  Node connected to NORMAL
    rootNode <- edge[rootRow, 1]
    edge <- edge[-rootRow,]
  }
  else{
    numRoot <- length(phylo$tip.label) + 1
    # the  Node connected to NORMAL
    rootNode <- numRoot
    rootTip <- numRoot
  }
  distanceTable <- data.frame(x = 0)
  for(i in 1:(length(phylo$tip.label)-1)){
    distanceTable <- cbind(distanceTable, -1)
  }
  distanceTable <- distanceTable[,(-1)]
  if(rootLabel == "NORMAL"){
    names(distanceTable) <- phylo$tip.label[which(phylo$tip.label != rootLabel)]
  }
  else{
    distanceTable <- cbind(distanceTable, -1)
    names(distanceTable) <- phylo$tip.label
  }
  t <- 1
  path <- list()
  while(t <= length(distanceTable)){
    subPath <- c()
    end <- t
    dis <- 0
    while (TRUE) {
      p <- which(edge[,2] == end)
      dis <- dis + edge[p,3]
      start <- edge[p,1]
      subPath <- append(subPath,end)
      end <- start
      if(start == rootNode){
        break
      }
    }
    path[[t]] <- subPath
    distanceTable[t] <- dis
    t <- t + 1
  }
  result <- path[[which.max(distanceTable)]]
}
## label sample in each branch                            
labelBranch <- function(phylo){
  Root <- which(phylo$tip.label == "NORMAL")
  internalNodes <- sort(unique(phylo$edge[,1]))
  result <- list()
  for(i in 1:(length(phylo$edge.length)+1)){
    result[[i]] <- NA
  }
  end <- phylo$edge[which(phylo$edge[,2] == Root),1]
  for(i in 1:length(phylo$tip.label)){
    row <- phylo$edge[which(phylo$edge[,2] == i), ]
    if(i == Root){
      next
    }
    while (TRUE) {
      node <- row[1]
      if(node == end){
        result[[node]] <- append(result[[node]], i)
        break
      }
      else{
        result[[node]] <- append(result[[node]], i)
        row <- phylo$edge[which(phylo$edge[,2] == node),]
      }
    }
  }
  g <- lapply(result, function(x){return(paste(sort(phylo$tip.label[x[-1]], decreasing = T),collapse = "∩"))})
  return(g)
}

