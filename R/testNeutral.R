#' testNeutral
#' @description Evaluat whether a tumor follows neutral evolution or under strong selection
#' during the growth based on variant frequency distribution (VAF) of subclonal 
#' The subclonal mutant allele frequencies of a follow a simple power-law distribution predicted by neutral growth.  
#' 
#' @references Williams MJ, Werner B, Barnes CP, Graham TA, Sottoriva A. Identification of neutral tumor evolution across cancer types. 
#' Nat Genet. 2016;48(3):238â€“244. doi:10.1038/ng.3489
#' 
#' @param maf the Maf object generated by readMaf
#' @param patient.id select the specific patients. Default: NULL, all patients are included
#' @param min.depth the minimun depth of coverage. Defalut: 10
#' @param R2.threshold the threshod of R2 to decide whether a tumor follows neutral evolution. Default: 0.98
#' @param min.vaf the minimum value of adjusted VAF value (1/2CCF). Default: 0.1
#' @param max.vaf the maximum value of adjusted VAF value (1/2CCF). Default: 0.3
#' @param min.mut.count the minimun number of subclonal mutations used to fit model. Default: 20
#' @param plot logical, whether to print model fitting plot of each sample. Default: TRUE
#' 
#' @examples
#' testNeutral(maf)
#' @export testNeutral

testNeutral <- function(maf, patient.id = NULL,withinType = FALSE, 
    min.depth = 10, R2.threshold = 0.98,
    min.vaf = 0.1, max.vaf = 0.3,
    plot = TRUE,
    min.mut.count = 20){
	
	mafData <- maf@data

    if(! "CCF" %in% colnames(mafData)){
        stop(paste0("Error: inferring whether a tumor follows neutral evolution requires CCF data.",
            "No CCF data was found when generate Maf object."))
    }

    if(is.null(patient.id)){
        patient.id = unique(mafData$Patient_ID)
    }else{
        patient.setdiff <- setdiff(patient.id, unique(mafData$Patient_ID))
        if(length(patient.setdiff) > 0){
            stop(paste0("Patient ", patient.setdiff, " can not be found in your data"))
        }
    }
	
	if(min.vaf <= 0){
	    stop("Error: min.vaf must greater than 0")
	}
	if(max.vaf < min.vaf){
	    stop("Error: max.vaf must greater than min.vaf")
	}
	if(min.depth <= 0){
	    stop("Error: min.depth must greater than 0")
	}
	if(max.depth < min.depth){
	    stop("Error: max.depth must greater than min.depth")
	}


	neutrality.list <- mafData %>%
	    dplyr::group_by(Patient_ID) %>%
	    dplyr::group_map(~testPowerLaw(.,
	        min.vaf, 
	        max.vaf, 
	        min.depth, 
	        R2.threshold, 
	        min.mut.count,
	        plot,
	        withinType = withinType), 
	        keep = TRUE) %>%
	    rlang::set_names(unique(mafData$Patient_ID))    	
	
	testNeutral.out = list(
	    neutrality.metrics = lapply(neutrality.list, 
	                                function(x){
	                                    d <- do.call(rbind, lapply(x, function(y)y$model.fitting.out))
	                                    if(nrow(d) >= 1){
	                                        rownames(d) <- 1:nrow(d) 
	                                    }
	                                    return(d)
	                                    }
	    ),
	    model.fitting.plot = lapply(neutrality.list, 
	                                function(x) lapply(x, function(y) y$model.fitting.plot))
	)
	# if(plot){
	#     ## combind data of all patients
	#     violin.data <- do.call(plyr::rbind.fill, testNeutral.out$neutrality.metrics)
	#     if(nrow(violin.data) != 0){
	#         y.min <- floor(min(violin.data$R2)*10)/10 
	#         breaks.y <-  seq(y.min, 1, (1-y.min)/3)
	#         p.violin <- ggplot(data = violin.data,aes(x = Patient, y = R2, fill = Patient))+
	#             geom_violin(trim=T,color="black")+
	#             geom_boxplot(width=0.05,position=position_dodge(0.9))+
	#             geom_hline(yintercept = R2.threshold,linetype = 2,color = "red")+
	#             theme_bw() + 
	#             ylab(expression(italic(R)^2))+
	#             scale_y_continuous(breaks = breaks.y, labels = round(breaks.y,3),
	#                                limits = c(breaks.y[1],1))+
	#             ## line of axis y
	#             geom_segment(aes(y = y.min ,
	#                              yend = 1,
	#                              x=-Inf,
	#                              xend=-Inf),
	#                          size = 1.5)+
	#             theme(axis.text.x=element_text(vjust = .3 ,size=10,color = "black",angle = 90), 
	#                   axis.text.y=element_text(size=10,color = "black"), 
	#                   axis.line.x = element_blank(),
	#                   axis.ticks.x = element_blank(),
	#                   axis.ticks.length = unit(.25, "cm"),
	#                   axis.line.y = element_blank(),
	#                   axis.ticks.y = element_line(size = 1),
	#                   axis.title.y=element_text(size = 15), 
	#                   axis.title.x=element_blank(), 
	#                   panel.border = element_blank(),axis.line = element_line(colour = "black",size=1),
	#                   legend.text=element_text( colour="black", size=10),
	#                   legend.title= element_blank(),
	#                   panel.grid.major = element_line(linetype = 2),
	#                   panel.grid.minor = element_blank()) 
	#         testNeutral.out$R2.values.plot <- p.violin
	#     }
	#     else{
	#         p.violin <- NA
	#     }
	#     
	# }

    return(testNeutral.out)
}



