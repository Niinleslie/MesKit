#' testNeutral
#' @description Evaluat whether a tumor follows neutral evolution or under strong selection
#' during the growth based on variant frequency distribution (VAF) of subclonal 
#' The subclonal mutant allele frequencies of a follow a simple power-law distribution predicted by neutral growth.  
#' 
#' @references Williams MJ, Werner B, Barnes CP, Graham TA, Sottoriva A. Identification of neutral tumor evolution across cancer types. 
#' Nat Genet. 2016;48(3):238â€“244. doi:10.1038/ng.3489
#' 
#' @param maf the Maf object generated by readMaf
#' @param patient.id select the specific patients. Default: NULL, all patients are included
#' @param min.depth the minimun depth of coverage. Defalut: 10
#' @param R2.threshold the threshod of R2 to decide whether a tumor follows neutral evolution. Default: 0.98
#' @param min.vaf the minimum value of adjusted VAF value. Default: 0.1
#' @param max.vaf the maximum value of adjusted VAF value. Default: 0.3
#' @param min.mut.count the minimun number of subclonal mutations used to fit model. Default: 20
#' @param plot logical, whether to print model fitting plot of each sample. Default: TRUE
#' 
#' @examples
#' testNeutral(maf)
#' @export testNeutral

testNeutral <- function(maf, patient.id = NULL, withinTumor = FALSE, 
                        min.depth = 10, R2.threshold = 0.98,
                        min.vaf = 0.1, max.vaf = 0.3,
                        plot = TRUE,
                        min.mut.count = 20){
   
   mafData <- maf@data
   
   if(! "CCF" %in% colnames(mafData)){
      stop(paste0("Error: inferring whether a tumor follows neutral evolution requires CCF data.",
                  "No CCF data was found when generate Maf object."))
   }
   
   if(is.null(patient.id)){
      patient.id = unique(mafData$Patient_ID)
   }else{
      patient.setdiff <- setdiff(patient.id, unique(mafData$Patient_ID))
      if(length(patient.setdiff) > 0){
         stop(paste0("Patient ", patient.setdiff, " can not be found in your data"))
      }
      mafData <- mafData[Patient_ID %in% patient.id]
   }
   
   if(min.vaf <= 0){
      stop("Error: min.vaf must be greater than 0")
   }
   if(max.vaf < min.vaf){
      stop("Error: max.vaf must be greater than min.vaf")
   }
   if(min.depth < 0){
      stop("Error: min.depth must be greater than 0")
   }
   
   # if(withinTumor){
   #    group.data <- mafData %>%
   #       dplyr::group_by(Patient_ID,Tumor_ID)
   # 
   #    group.names <- dplyr::groups(group.data)
   # }else{
   #    group.data <- mafData %>%
   #       dplyr::group_by(Patient_ID,Tumor_Sample_Barcode)
   # }
   neutrality.metrics <- data.frame()
   if(plot){
      model.fitting.plot <- list()
   }else{
      model.fitting.plot <- NA
   }

   for(patient in patient.id){
      patient.data <- mafData[Patient_ID == patient]
      if(withinTumor){
         ids <- unique(patient.data$Tumor_ID)
      }else{
         ids <- unique(patient.data$Tumor_Sample_Barcode)
      }
      
      for(id in ids){
         
         if(withinTumor){
            subdata <- patient.data[Tumor_ID == id]
            subdata$VAF_adj <- subdata$Tumor_Average_VAF_adj
         }else{
            subdata <- patient.data[Tumor_Sample_Barcode == id]
         }
         
         subdata <- subdata %>%
            dplyr::filter(
                  Clonal_Status == "Subclonal",
                  Ref_allele_depth + Alt_allele_depth > min.depth,
                  VAF_adj > min.vaf,
                  VAF_adj < max.vaf,
                  !is.na(VAF_adj)
         )
         
         ## warning
         if(nrow(subdata) < min.mut.count){
            warning(paste0("Sample ", id, ": There is no enough eligible mutations can be used."))
            next
         }
         
         vaf <- subdata$VAF_adj
         
         breaks <- seq(max.vaf, min.vaf, -0.005)
         mut.count <- sapply(breaks,function(x,vaf){sum(vaf > x)},vaf = vaf)
         vafCumsum <- data.frame(count = mut.count, f = breaks)
         vafCumsum$inv_f <- 1/vafCumsum$f - 1/max.vaf
         vafCumsum$n_count <- vafCumsum$count/max(vafCumsum)
         vafCumsum$t_count <- vafCumsum$inv_f/(1/min.vaf - 1/max.vaf)
         
         ## area of theoretical curve
         theoryA <- integrate(approxfun(vafCumsum$inv_f,vafCumsum$t_count),
                              min(vafCumsum$inv_f),
                              max(vafCumsum$inv_f),stop.on.error = F)$value
         # area of emprical curve
         dataA <- integrate(approxfun(vafCumsum$inv_f,vafCumsum$n_count),
                            min(vafCumsum$inv_f),
                            max(vafCumsum$inv_f),stop.on.error = F)$value
         # Take absolute difference between the two
         area <- abs(theoryA - dataA)
         # Normalize so that metric is invariant to chosen limits
         area<- area / (1 / min.vaf - 1 / max.vaf)
         
         
         ## calculate mean distance
         meandist <- mean(abs(vafCumsum$n_count - vafCumsum$t_count))
         
         ## calculate kolmogorovdist 
         n = length(vaf)
         cdfs <- 1 - ((1/sort(vaf) - 1/max.vaf) /(1/min.vaf - 1/max.vaf))
         dp <- max((1:n) / n - cdfs)
         dn <- - min((0:(n-1)) / n - cdfs)
         kolmogorovdist  <- max(c(dn, dp))
         
         ## R squared
         lmModel <- lm(vafCumsum$count ~ vafCumsum$inv_f + 0)
         lmLine = summary(lmModel)
         R2 = lmLine$adj.r.squared
         
         if(withinTumor){
            test.df <- data.frame(
               Patient_ID = patient,
               Tumor_ID = id,
               Eligible_Mut_Count = nrow(subdata),
               Area = area,
               Kolmogorov_Distance = kolmogorovdist,
               Mean_Distance = meandist,
               R2 = R2, 
               Type = dplyr::if_else(
                  R2 >= R2.threshold,
                  "neutral",
                  "non-neutral") 
            )
         }else{
            test.df <- data.frame(
               Patient_ID = patient,
               Tumor_Sample_Barcode = id,
               Eligible_Mut_Count = nrow(subdata ),
               Area = area,
               Kolmogorov_Distance = kolmogorovdist,
               Mean_Distance = meandist,
               R2 = R2, 
               Type = dplyr::if_else(
                  R2 >= R2.threshold,
                  "neutral",
                  "non-neutral") 
            ) 
         }
         
         if(plot){
            
            Arealabel <- as.character(paste0("italic(Area) == ", round(area,4)))
            KDlabel <- as.character(paste0("italic(Kolmogorov_Distance) ==", round(kolmogorovdist,4) ))
            Mdlabel <- as.character(paste0("italic(Mean_Distance) == ", round(meandist,4) ))
            R2label <- as.character(paste0("italic(R)^2 == ", round(R2,4) ))
            
            x.min <- min(vafCumsum$f)
            x.max <- max(vafCumsum$f)
            x.breaks <- seq(x.min,x.max,(x.max-x.min)/2)
            x.breaks.pos <- 1/x.breaks - 1/max.vaf
            x.breaks.label <- paste("1/", round(x.breaks,2),sep="")
            y.min <- min(vafCumsum$count)
            y.max <- max(vafCumsum$count,
                         (max(vafCumsum$inv_f)*lmModel$coefficients[1]))
            test.plot <- ggplot(data = vafCumsum, mapping = aes(x = inv_f, y = count)) +
               geom_point()+
               geom_smooth(method=lm,formula = y ~ x + 0, color="red",se = FALSE)+
               theme(panel.grid =element_blank(),
                     panel.border = element_blank(),
                     panel.background = element_blank(),
                     axis.line = element_blank(),
                     axis.ticks = element_line(size = 1),
                     axis.title = element_text(size = 13,face = "bold",colour = "black"),
                     axis.text = element_text(size = 10,face = "bold",colour = "black"),
                     axis.ticks.length = unit(.25, "cm"))+
               geom_segment(aes(x = min(inv_f),xend= max(inv_f), y=-Inf,yend=-Inf), size = 1)+
               geom_segment(aes(y = y.min ,yend = y.max,x=-Inf,xend=-Inf), size = 1.5)+
               scale_x_continuous(breaks = x.breaks.pos,
                                  labels = x.breaks.label)+
               scale_y_continuous(breaks = seq(y.min,y.max,(y.max-y.min)/4),
                                  labels = round(seq(y.min,y.max,(y.max-y.min)/4)))+
               # labels = c(round(y.min),
               #            round(y.min+(y.max-y.min)/4),
               #            round(y.min+(y.max-y.min)*2/4),
               #            round(y.max)))+
               labs(title= unique(subdata$Tumor_Sample_Barcode),
                    x="Inverse allelic frequency 1/vaf",
                    y="Cumulative number of SSNVs")+
               annotate("text",
                        x = x.min,
                        y = y.max,
                        label = Arealabel,
                        size = 4,
                        fontface = "bold",
                        parse = TRUE,
                        hjust = 0)+
               annotate("text",
                        x = x.min,
                        y = y.max*0.9,
                        label = KDlabel,
                        size = 4,
                        fontface = "bold",
                        parse = TRUE,
                        hjust = 0)+
               annotate("text",
                        x = x.min,
                        y = y.max*0.8,
                        label = Mdlabel,
                        size = 4,
                        fontface = "bold",
                        parse = TRUE,
                        hjust = 0)+
               annotate("text",
                        x = x.min,
                        y = y.max*0.7,
                        label = R2label,
                        size = 4,
                        fontface = "bold",
                        parse = TRUE,
                        hjust = 0)
            
            if(withinTumor){
               test.plot <- test.plot +  
                  labs(title= id,
                       x="Inverse allelic frequency 1/vaf",
                       y="Cumulative number of SSNVs")
            }
            else{
               test.plot <- test.plot + 
                  labs(title= id,
                     x="Inverse allelic frequency 1/vaf",
                     y="Cumulative number of SSNVs")
            }
            
            model.fitting.plot[[patient]][[id]] <- test.plot
         }
         neutrality.metrics <- rbind(neutrality.metrics,test.df)
      }
   }
   
   if(nrow(neutrality.metrics) == 0){
      return(NA)
   }
   
   
   testNeutral.out = list(
      neutrality.metrics = neutrality.metrics ,
      model.fitting.plot = model.fitting.plot
   )
   # if(plot){
   #     ## combind data of all patients
   #     violin.data <- do.call(plyr::rbind.fill, testNeutral.out$neutrality.metrics)
   #     if(nrow(violin.data) != 0){
   #         y.min <- floor(min(violin.data$R2)*10)/10 
   #         breaks.y <-  seq(y.min, 1, (1-y.min)/3)
   #         p.violin <- ggplot(data = violin.data,aes(x = Patient, y = R2, fill = Patient))+
   #             geom_violin(trim=T,color="black")+
   #             geom_boxplot(width=0.05,position=position_dodge(0.9))+
   #             geom_hline(yintercept = R2.threshold,linetype = 2,color = "red")+
   #             theme_bw() + 
   #             ylab(expression(italic(R)^2))+
   #             scale_y_continuous(breaks = breaks.y, labels = round(breaks.y,3),
   #                                limits = c(breaks.y[1],1))+
   #             ## line of axis y
   #             geom_segment(aes(y = y.min ,
   #                              yend = 1,
   #                              x=-Inf,
   #                              xend=-Inf),
   #                          size = 1.5)+
   #             theme(axis.text.x=element_text(vjust = .3 ,size=10,color = "black",angle = 90), 
   #                   axis.text.y=element_text(size=10,color = "black"), 
   #                   axis.line.x = element_blank(),
   #                   axis.ticks.x = element_blank(),
   #                   axis.ticks.length = unit(.25, "cm"),
   #                   axis.line.y = element_blank(),
   #                   axis.ticks.y = element_line(size = 1),
   #                   axis.title.y=element_text(size = 15), 
   #                   axis.title.x=element_blank(), 
   #                   panel.border = element_blank(),axis.line = element_line(colour = "black",size=1),
   #                   legend.text=element_text( colour="black", size=10),
   #                   legend.title= element_blank(),
   #                   panel.grid.major = element_line(linetype = 2),
   #                   panel.grid.minor = element_blank()) 
   #         testNeutral.out$R2.values.plot <- p.violin
   #     }
   #     else{
   #         p.violin <- NA
   #     }
   #     
   # }
   
   return(testNeutral.out)
}


