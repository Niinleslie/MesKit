<<<<<<< HEAD
#' testNeutral
#' @description Evaluat whether a tumor follows neutral evolution or under strong selection
#' during the growth based on variant frequency distribution (VAF) of subclonal 
#' The subclonal mutant allele frequencies of a follow a simple power-law distribution predicted by neutral growth.  
#' 
#' @references Williams MJ, Werner B, Barnes CP, Graham TA, Sottoriva A. Identification of neutral tumor evolution across cancer types. Nat Genet. 2016;48(3):238â€“244. doi:10.1038/ng.3489
#' 
#' @param maf the Maf object generated by readMaf
#' @param patient.id select the specific patients. Default: NULL, all patients are included.
#' @param chrSilent Select chromosomes needed to be dismissed. Default NULL.
#' @param mutType select Proper variant classification you need. Default "All". Option: "nonSilent".
#' @param use.indel Logical value. Whether to use INDELs besides somatic SNVs. Default: TRUE.
#' @param min.depth the minimun depth of coverage. Defalut: 10
#' @param R2.threshold the threshod of R2 to decide whether a tumor follows neutral evolution. Default: 0.98
#' @param min.vaf the minimum value of adjusted VAF value. Default: 0.1
#' @param max.vaf the maximum value of adjusted VAF value. Default: 0.3
#' @param min.mut.count the minimun number of subclonal mutations used to fit model. Default: 20
#' @param plot logical, whether to print model fitting plot of each sample. Default: TRUE
#' 
#' @examples
#' testNeutral(maf)
#' @export testNeutral

testNeutral <- function(maf,
                        patient.id = NULL,
                        chrSilent = NULL,
                        mutType = "All",
                        use.indel = TRUE,
                        withinTumor = FALSE, 
                        min.depth = 10, R2.threshold = 0.98,
                        min.vaf = 0.1, max.vaf = 0.3,
                        plot = TRUE,
                        min.mut.count = 20){
    if(min.vaf <= 0){
        stop("Error: min.vaf must be greater than 0")
    }
    if(max.vaf < min.vaf){
        stop("Error: max.vaf must be greater than min.vaf")
    }
    maf <- subsetMaf(maf,
                     patient.id = patient.id,
                     chrSilent = chrSilent,
                     mutType = mutType,
                     use.indel = use.indel,
                     min.vaf = min.vaf,
                     max.vaf = max.vaf,
                     min.total.depth = min.depth,
                     clonalStatus = "Subclonal")
    mafData <- maf@data
    if(! "CCF" %in% colnames(mafData)){
        stop(paste0("Error: inferring whether a tumor follows neutral evolution requires CCF data.",
                    "No CCF data was found when generate Maf object."))
    }
    
    
    patient.id <- unique(mafData$Patient_ID)
    
    neutrality.metrics <- data.frame()
    if(plot){
        model.fitting.plot <- list()
    }else{
        model.fitting.plot <- NA
    }
    
    for(patient in patient.id){
        patient.data <- subset(mafData, Patient_ID == patient)
        if(withinTumor){
            ids <- unique(patient.data$Tumor_ID)
        }else{
            ids <- unique(patient.data$Tumor_Sample_Barcode)
        }
        
        for(id in ids){
            
            if(withinTumor){
                subdata <- subset(patient.data, Tumor_ID == id&!is.na(Tumor_Average_VAF_adj))
                subdata$VAF_adj <- subdata$Tumor_Average_VAF_adj
            }else{
                subdata <- subset(patient.data, Tumor_Sample_Barcode == id&!is.na(VAF_adj))
            }
            ## warning
            if(nrow(subdata) < min.mut.count){
                warning(paste0("Sample ", id, ": There is no enough eligible mutations can be used."))
                next
            }
            
            vaf <- subdata$VAF_adj
            breaks <- seq(max.vaf, min.vaf, -0.005)
            mut.count <- sapply(breaks,function(x,vaf){sum(vaf > x)},vaf = vaf)
            vafCumsum <- data.frame(count = mut.count, f = breaks)
            vafCumsum$inv_f <- 1/vafCumsum$f - 1/max.vaf
            vafCumsum$n_count <- vafCumsum$count/max(vafCumsum)
            vafCumsum$t_count <- vafCumsum$inv_f/(1/min.vaf - 1/max.vaf)
            ## area of theoretical curve
            theoryA <- integrate(approxfun(vafCumsum$inv_f,vafCumsum$t_count),
                                 min(vafCumsum$inv_f),
                                 max(vafCumsum$inv_f),stop.on.error = F)$value
            # area of emprical curve
            dataA <- integrate(approxfun(vafCumsum$inv_f,vafCumsum$n_count),
                               min(vafCumsum$inv_f),
                               max(vafCumsum$inv_f),stop.on.error = F)$value
            # Take absolute difference between the two
            area <- abs(theoryA - dataA)
            # Normalize so that metric is invariant to chosen limits
            area<- area / (1 / min.vaf - 1 / max.vaf)
            
            
            ## calculate mean distance
            meandist <- mean(abs(vafCumsum$n_count - vafCumsum$t_count))
            
            ## calculate kolmogorovdist 
            n = length(vaf)
            cdfs <- 1 - ((1/sort(vaf) - 1/max.vaf) /(1/min.vaf - 1/max.vaf))
            dp <- max((1:n) / n - cdfs)
            dn <- - min((0:(n-1)) / n - cdfs)
            kolmogorovdist  <- max(c(dn, dp))
            
            ## R squared
            lmModel <- lm(vafCumsum$count ~ vafCumsum$inv_f + 0)
            lmLine = summary(lmModel)
            R2 = lmLine$adj.r.squared
            
            if(withinTumor){
                test.df <- data.frame(
                    Patient_ID = patient,
                    Tumor_ID = id,
                    Eligible_Mut_Count = nrow(subdata),
                    Area = area,
                    Kolmogorov_Distance = kolmogorovdist,
                    Mean_Distance = meandist,
                    R2 = R2, 
                    Type = dplyr::if_else(
                        R2 >= R2.threshold,
                        "neutral",
                        "non-neutral") 
                )
            }else{
                test.df <- data.frame(
                    Patient_ID = patient,
                    Tumor_Sample_Barcode = id,
                    Eligible_Mut_Count = nrow(subdata),
                    Area = area,
                    Kolmogorov_Distance = kolmogorovdist,
                    Mean_Distance = meandist,
                    R2 = R2, 
                    Type = dplyr::if_else(
                        R2 >= R2.threshold,
                        "neutral",
                        "non-neutral") 
                ) 
            }
            
            if(plot){
                p <- plotPowerLaw(vafCumsum, test.df, id, max.vaf, lmModel)
                model.fitting.plot[[patient]][[id]] <- p
            }
            neutrality.metrics <- rbind(neutrality.metrics,test.df)
        }
    }
    
    if(nrow(neutrality.metrics) == 0){
        return(NA)
    }
    
    
    testNeutral.out = list(
        neutrality.metrics = neutrality.metrics ,
        model.fitting.plot = model.fitting.plot
    )
    # if(plot){
    #     ## combind data of all patients
    #     violin.data <- do.call(plyr::rbind.fill, testNeutral.out$neutrality.metrics)
    #     if(nrow(violin.data) != 0){
    #         y.min <- floor(min(violin.data$R2)*10)/10 
    #         breaks.y <-  seq(y.min, 1, (1-y.min)/3)
    #         p.violin <- ggplot(data = violin.data,aes(x = Patient, y = R2, fill = Patient))+
    #             geom_violin(trim=T,color="black")+
    #             geom_boxplot(width=0.05,position=position_dodge(0.9))+
    #             geom_hline(yintercept = R2.threshold,linetype = 2,color = "red")+
    #             theme_bw() + 
    #             ylab(expression(italic(R)^2))+
    #             scale_y_continuous(breaks = breaks.y, labels = round(breaks.y,3),
    #                                limits = c(breaks.y[1],1))+
    #             ## line of axis y
    #             geom_segment(aes(y = y.min ,
    #                              yend = 1,
    #                              x=-Inf,
    #                              xend=-Inf),
    #                          size = 1.5)+
    #             theme(axis.text.x=element_text(vjust = .3 ,size=10,color = "black",angle = 90), 
    #                   axis.text.y=element_text(size=10,color = "black"), 
    #                   axis.line.x = element_blank(),
    #                   axis.ticks.x = element_blank(),
    #                   axis.ticks.length = unit(.25, "cm"),
    #                   axis.line.y = element_blank(),
    #                   axis.ticks.y = element_line(size = 1),
    #                   axis.title.y=element_text(size = 15), 
    #                   axis.title.x=element_blank(), 
    #                   panel.border = element_blank(),axis.line = element_line(colour = "black",size=1),
    #                   legend.text=element_text( colour="black", size=10),
    #                   legend.title= element_blank(),
    #                   panel.grid.major = element_line(linetype = 2),
    #                   panel.grid.minor = element_blank()) 
    #         testNeutral.out$R2.values.plot <- p.violin
    #     }
    #     else{
    #         p.violin <- NA
    #     }
    #     
    # }
    
    return(testNeutral.out)
}
=======
#' testNeutral
#' @description Evaluat whether a tumor follows neutral evolution or under strong selection during the growth based on variant frequency distribution (VAF) of subclonal The subclonal mutant allele frequencies of a follow a simple power-law distribution predicted by neutral growth.  
#' 
#' 
#' @param maf the Maf object generated by readMaf
#' @param patient.id select the specific patients. Default: NULL, all patients are included.
#' @param chrSilent Select chromosomes needed to be dismissed. Default NULL.
#' @param mutType select Proper variant classification you need. Default "All". Option: "nonSyn".
#' @param use.indel Logical value. Whether to use INDELs besides somatic SNVs. Default: TRUE.
#' @param min.depth the minimun depth of coverage. Defalut: 10
#' @param R2.threshold the threshod of R2 to decide whether a tumor follows neutral evolution. Default: 0.98
#' @param min.vaf the minimum value of adjusted VAF value. Default: 0.1
#' @param max.vaf the maximum value of adjusted VAF value. Default: 0.3
#' @param min.mut.count the minimun number of subclonal mutations used to fit model. Default: 20
#' @param plot logical, whether to print model fitting plot of each sample. Default: TRUE
#' 
#' @examples
#' testNeutral(maf)
#' @export testNeutral

testNeutral <- function(maf,
                        patient.id = NULL,
                        chrSilent = NULL,
                        mutType = "All",
                        use.indel = TRUE,
                        withinTumor = FALSE, 
                        min.depth = 10, 
                        min.vaf = 0.1, 
                        max.vaf = 0.3,
                        R2.threshold = 0.98,
                        min.mut.count = 20,
                        plot = TRUE){
    if(min.vaf <= 0){
        stop("Error: min.vaf must be greater than 0")
    }
    if(max.vaf < min.vaf){
        stop("Error: max.vaf must be greater than min.vaf")
    }
   maf <- subsetMaf(maf,
                    patient.id = patient.id,
                    chrSilent = chrSilent,
                    mutType = mutType,
                    use.indel = use.indel,
                    min.vaf = min.vaf,
                    max.vaf = max.vaf,
                    min.total.depth = min.depth,
                    clonalStatus = "Subclonal")
   mafData <- maf@data
   if(! "CCF" %in% colnames(mafData)){
      stop(paste0("Error: inferring whether a tumor follows neutral evolution requires CCF data.",
                  "No CCF data was found when generate Maf object."))
   }
   
   
   patient.id <- unique(mafData$Patient_ID)
   
   neutrality.metrics <- data.frame()
   if(plot){
      model.fitting.plot <- list()
   }else{
      model.fitting.plot <- NA
   }
   
   for(patient in patient.id){
      patient.data <- subset(mafData, Patient_ID == patient)
      if(withinTumor){
         ids <- unique(patient.data$Tumor_ID)
      }else{
         ids <- unique(patient.data$Tumor_Sample_Barcode)
      }
      
      for(id in ids){
         
         if(withinTumor){
            subdata <- subset(patient.data, Tumor_ID == id&!is.na(Tumor_Average_VAF_adj))
            subdata$VAF_adj <- subdata$Tumor_Average_VAF_adj
         }else{
            subdata <- subset(patient.data, Tumor_Sample_Barcode == id&!is.na(VAF_adj))
         }
         ## warning
         if(nrow(subdata) < min.mut.count){
            warning(paste0("Sample ", id, ": There is no enough eligible mutations can be used."))
            next
         }
         
         vaf <- subdata$VAF_adj
         breaks <- seq(max.vaf, min.vaf, -0.005)
         mut.count <- sapply(breaks,function(x,vaf){sum(vaf > x)},vaf = vaf)
         vafCumsum <- data.frame(count = mut.count, f = breaks)
         vafCumsum$inv_f <- 1/vafCumsum$f - 1/max.vaf
         vafCumsum$n_count <- vafCumsum$count/max(vafCumsum)
         vafCumsum$t_count <- vafCumsum$inv_f/(1/min.vaf - 1/max.vaf)
         ## area of theoretical curve
         theoryA <- integrate(approxfun(vafCumsum$inv_f,vafCumsum$t_count),
                              min(vafCumsum$inv_f),
                              max(vafCumsum$inv_f),stop.on.error = F)$value
         # area of emprical curve
         dataA <- integrate(approxfun(vafCumsum$inv_f,vafCumsum$n_count),
                            min(vafCumsum$inv_f),
                            max(vafCumsum$inv_f),stop.on.error = F)$value
         # Take absolute difference between the two
         area <- abs(theoryA - dataA)
         # Normalize so that metric is invariant to chosen limits
         area<- area / (1 / min.vaf - 1 / max.vaf)
         
         
         ## calculate mean distance
         meandist <- mean(abs(vafCumsum$n_count - vafCumsum$t_count))
         
         ## calculate kolmogorovdist 
         n = length(vaf)
         cdfs <- 1 - ((1/sort(vaf) - 1/max.vaf) /(1/min.vaf - 1/max.vaf))
         dp <- max((1:n) / n - cdfs)
         dn <- - min((0:(n-1)) / n - cdfs)
         kolmogorovdist  <- max(c(dn, dp))
         
         ## R squared
         lmModel <- lm(vafCumsum$count ~ vafCumsum$inv_f + 0)
         lmLine = summary(lmModel)
         R2 = lmLine$adj.r.squared
         
         if(withinTumor){
            test.df <- data.frame(
               Patient_ID = patient,
               Tumor_ID = id,
               Eligible_Mut_Count = nrow(subdata),
               Area = area,
               Kolmogorov_Distance = kolmogorovdist,
               Mean_Distance = meandist,
               R2 = R2, 
               Type = dplyr::if_else(
                  R2 >= R2.threshold,
                  "neutral",
                  "non-neutral") 
            )
         }else{
            test.df <- data.frame(
               Patient_ID = patient,
               Tumor_Sample_Barcode = id,
               Eligible_Mut_Count = nrow(subdata),
               Area = area,
               Kolmogorov_Distance = kolmogorovdist,
               Mean_Distance = meandist,
               R2 = R2, 
               Type = dplyr::if_else(
                  R2 >= R2.threshold,
                  "neutral",
                  "non-neutral") 
            ) 
         }
         
         if(plot){
            p <- plotPowerLaw(vafCumsum, test.df, id, max.vaf, lmModel)
            model.fitting.plot[[patient]][[id]] <- p
         }
         neutrality.metrics <- rbind(neutrality.metrics,test.df)
      }
   }
   
   if(nrow(neutrality.metrics) == 0){
      return(NA)
   }
   
   
   testNeutral.out = list(
      neutrality.metrics = neutrality.metrics ,
      model.fitting.plot = model.fitting.plot
   )
   # if(plot){
   #     ## combind data of all patients
   #     violin.data <- do.call(plyr::rbind.fill, testNeutral.out$neutrality.metrics)
   #     if(nrow(violin.data) != 0){
   #         y.min <- floor(min(violin.data$R2)*10)/10 
   #         breaks.y <-  seq(y.min, 1, (1-y.min)/3)
   #         p.violin <- ggplot(data = violin.data,aes(x = Patient, y = R2, fill = Patient))+
   #             geom_violin(trim=T,color="black")+
   #             geom_boxplot(width=0.05,position=position_dodge(0.9))+
   #             geom_hline(yintercept = R2.threshold,linetype = 2,color = "red")+
   #             theme_bw() + 
   #             ylab(expression(italic(R)^2))+
   #             scale_y_continuous(breaks = breaks.y, labels = round(breaks.y,3),
   #                                limits = c(breaks.y[1],1))+
   #             ## line of axis y
   #             geom_segment(aes(y = y.min ,
   #                              yend = 1,
   #                              x=-Inf,
   #                              xend=-Inf),
   #                          size = 1.5)+
   #             theme(axis.text.x=element_text(vjust = .3 ,size=10,color = "black",angle = 90), 
   #                   axis.text.y=element_text(size=10,color = "black"), 
   #                   axis.line.x = element_blank(),
   #                   axis.ticks.x = element_blank(),
   #                   axis.ticks.length = unit(.25, "cm"),
   #                   axis.line.y = element_blank(),
   #                   axis.ticks.y = element_line(size = 1),
   #                   axis.title.y=element_text(size = 15), 
   #                   axis.title.x=element_blank(), 
   #                   panel.border = element_blank(),axis.line = element_line(colour = "black",size=1),
   #                   legend.text=element_text( colour="black", size=10),
   #                   legend.title= element_blank(),
   #                   panel.grid.major = element_line(linetype = 2),
   #                   panel.grid.minor = element_blank()) 
   #         testNeutral.out$R2.values.plot <- p.violin
   #     }
   #     else{
   #         p.violin <- NA
   #     }
   #     
   # }
   
   return(testNeutral.out)
}

>>>>>>> 6fb7d00d577426782728070dbcc363222020402f
