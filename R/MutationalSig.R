#' TreeMutationalSig
#' @description Figure out the intersection of the variants on different branches 
#' in njtree object and output the treeMSOutput for further summary and plot functions.
#' 
#' @import reshape2 dplyr
#' 
#' @param njtree The njtree object generated by NJtree function.
#' @param driverGenesFile The file with driver gene list. Default NULL.
#' @param mutThreshold the threshold for the variants in a branch. Default 50.
#' @param signaturesRef The parameter used for deconstructSig. Default "cosmic". Option: "nature2013". 
#' 
#' @return The data frame, treeMSOutput, containing information about each set/branch's mutational signature.
#' 
#' @examples
#' treeMSOutput <- treeMutationalSig(njtree, driverGenesFile=NULL, mutThreshold=50, signaturesRef="cosmic")
#' 
#' @export treeMutationalSig


## Mutational Signature function
treeMutationalSig <- function(njtree, driverGenesFile=NULL, mutThreshold=50, signaturesRef="cosmic"){
    ## refBuild limitation: only hg19 or hg38
    refBuild <- njtree@refBuild
    if (!((refBuild == "hg19") | (refBuild == "hg38"))){
        stop(error="Error: refBuild's value may be incorrect. 
             refBuild could be only set as \"hg19\" or \"hg38\".")
    } else {
        refBuild <- paste("BSgenome.Hsapiens.UCSC.", refBuild, sep = "")
    }
    
    ## get branches information from njtree object
    mutBranches <- njtree@mut_branches
    patientID <- njtree@patientID
    branchesName <- names(mutBranches)
    branchesNameList <- strsplit(branchesName, split='∩')
    
    ## regain the data frame of all branches with Sample
    mutSigRef <- data.frame()
    for (branchName in branchesName){
        mutBranch <- mutBranches[[branchName]]
        mutSigRef <- rbind(mutBranch, mutSigRef)
    }
    colnames(mutSigRef) <- c("Sample",  "chr", "pos", "pos_end", 
                             "ref", "alt", "Hugo_Symbol", "mut_id", 
                             "alias")
    ## get the mutational signature of the branch 
    mutSigsOutput <- data.frame()
    lsPicName <- c()
    ## deconstructSigs
    sigsInput <- suppressWarnings(
        deconstructSigs::mut.to.sigs.input(mut.ref=mutSigRef, 
                                           sample.id="Sample", 
                                           chr="chr", 
                                           pos="pos", 
                                           ref="ref", 
                                           alt="alt",
                                           bsg=get(refBuild)))
    for (branchCounter in length(branchesNameList):1){
        ## generate a single branch
        branch <- Filter(Negate(is.na), 
                         branchesNameList[[branchCounter]])
        branchName <- branchesName[branchCounter]
        ## get the mutational signature of the branch
        if (length(mutSigRef[which(
            mutSigRef$Sample == branchName), 1]) < mutThreshold){
            sigsMaxName <- "No Signature"
            sigsMaxProb <- 0
            message(paste("Branch ", branchName,
                          ": Number of mutations is less than mutThreshold.",
                          sep = ""))
            # next()
        }else{

            if (signaturesRef == "cosmic") {
                sigsWhich <- deconstructSigs::whichSignatures(tumor.ref=sigsInput, 
                                                              signatures.ref=deconstructSigs::signatures.cosmic, 
                                                              sample.id=branchName,
                                                              contexts.needed=TRUE)
            } else if (signaturesRef == "nature2013") {
                sigsWhich <- deconstructSigs::whichSignatures(tumor.ref=sigsInput, 
                                                              signatures.ref=deconstructSigs::signatures.nature2013, 
                                                              sample.id=branchName,
                                                              contexts.needed=TRUE)
            }
            
            
            ## get mutational signature with max weight
            sigsMax <- sigsWhich[["weights"]][which.max(sigsWhich[["weights"]])]
            sigsMaxName <- colnames(sigsMax)
            sigsMaxName <- gsub('[.]', ' ', sigsMaxName)
            sigsMaxProb <- sigsMax[,1]
        }
        
        ## vectorize branch name
        # branch <- gsub(paste(patientID,"-",sep=""), "", branch)
        
        ## figure out putative driver genes
        if (!is.null(driverGenesFile)){
            ## read putative driver genes' list
            driverGenes <- as.character(read.table(
                driverGenesFile, header = TRUE, quote="", sep="\n")[,1])
            ## filter potative driver genes of each branch
            pdgMut <- mutSigRef[which(
                mutSigRef$Sample == branchName &
                    as.character(mutSigRef$Hugo_Symbol) %in% driverGenes),]
            pdgBranch <- as.character(pdgMut$Hugo_Symbol)
            ## collect branches' mutataional signature and potative driver genes
            mutSigsBranch <- data.frame(
                branch=c(branchName), 
                alias=as.character(unique(mutSigRef[which(mutSigRef$Sample == branchName), ]$alias)), 
                sig=sigsMaxName, 
                mut.num=length(
                    mutSigRef[which(
                        mutSigRef$Sample == branchName), 1]), 
                sig.prob=format(round(sigsMaxProb, digits = 3), nsmall = 3), 
                putative_driver_genes=c(paste(pdgBranch, collapse = ",")))
        } else{
            mutSigsBranch <- data.frame(
                branch=c(branchName), 
                alias=as.character(unique(mutSigRef[which(mutSigRef$Sample == branchName), ]$alias)), 
                sig=sigsMaxName, 
                mut.num=length(mutSigRef[which(
                    mutSigRef$Sample == branchName), 1]), 
                sig.prob=format(round(sigsMaxProb, digits = 3), nsmall = 3))
        }
        ## collect branches' mutataional signature information
        mutSigsOutput <- rbind(mutSigsOutput, mutSigsBranch)
    }
    
    
    ## calculation process(maybe could be replaced by lapply)
    if (signaturesRef =="cosmic") {
        ## Aetiology from https://cancer.sanger.ac.uk/cosmic/signatures_v2 emm actually the additional feature may matter
        df.aetiology <- data.frame(
            aeti=c(
                "An endogenous mutational process initiated by spontaneous deamination of 5-methylcytosine",
                "Activity of the AID/APOBEC family of cytidine deaminases", 
                "Failure of DNA double-strand break-repair by homologous recombination",
                "Tobacco mutagens", 
                "Unknown", 
                "Defective DNA mismatch repair and is found in microsatellite unstable tumours",
                "Ultraviolet light exposure", 
                "Unknown", 
                "Polymerase η, which is implicated with the activity of AID during somatic hypermutation", 
                "Recurrent POLE somatic mutations, viz., Pro286Arg and Val411Leu.",
                "Treatments with the alkylating agent temozolomide", 
                "Unknown", 
                "Activity of the AID/APOBEC family of cytidine deaminases(C > U)",
                "Unknown", 
                "Defective DNA mismatch repair", 
                "Unknown", 
                "Unknown",
                "Unknown", 
                "Unknown", 
                "Defective DNA mismatch repair", 
                "Unknown",
                "Exposures to aristolochic acid", 
                "Unknown", 
                "Exposures to aflatoxin",
                "Unknown", 
                "Defective DNA mismatch repair", 
                "Unknown", 
                "Unknown",
                "Tobacco chewing habit", 
                "Unknown", 
                "Unknown"), 
            sig=c("Signature 1", "Signature 2", "Signature 3", "Signature 4", "Signature 5", "Signature 6",
                  "Signature 7", "Signature 8", "Signature 9", "Signature 10", "Signature 11", "Signature 12", 
                  "Signature 13", "Signature 14", "Signature 15", "Signature 16", "Signature 17", "Signature 18",
                  "Signature 19", "Signature 20", "Signature 21", "Signature 22", "Signature 23", "Signature 24", 
                  "Signature 25", "Signature 26", "Signature 27", "Signature 28", "Signature 29", "Signature 30", 
                  "No Signature")
        )
    } else if (signaturesRef =="nature2013") {
        ## Aetiology from https://www.nature.com/articles/nature12477#s1
        df.aetiology <- data.frame(
            aeti=c(
                "Deamination of 5-methyl-cytosine",
                "Deamination of 5-methyl-cytosine", 
                "AID/APOBEC family of cytidine deaminases",
                "Defective homologous-recombination-based DNA double-strand break repair", 
                "Tobacco carcinogens", 
                "Smoking history, C>T and T>C mutations",
                "Defective DNA mismatch repair", 
                "Ultraviolet-light-induced mutations",
                "Exogenous carcinogens, transcription-coupled nucleotide excision repair acting on bulky DNA adducts", 
                "Polymerase η, which is implicated with the activity of AID during somatic hypermutation",
                "Polymerase ε, altered activity of the error-prone polymerase Pol ε", 
                "Alkylating agent temozolomide", 
                "Exogenous carcinogens, transcription-coupled nucleotide excision repair acting on bulky DNA adducts",
                "AID/APOBEC family of cytidine deaminases", 
                "Uncharacterized defects in DNA maintenance", 
                "Uncharacterized defects in DNA maintenance", 
                "Exogenous carcinogens, transcription-coupled nucleotide excision repair acting on bulky DNA adducts",
                "Unknown", 
                "Unknown", 
                "Unknown",
                "Unknown",
                "Uncharacterized defects in DNA maintenance", 
                "Unknown",
                "Unknown",
                "Unknown", 
                "Unknown", 
                "Unknown", 
                "Unknown"), 
            sig=c("Signature 1A", "Signature 1B", "Signature 2", "Signature 3", "Signature 4", "Signature 5", "Signature 6",
                  "Signature 7", "Signature 8", "Signature 9", "Signature 10", "Signature 11", "Signature 12", "Signature 13", 
                  "Signature 14", "Signature 15", "Signature 16", "Signature 17", "Signature 18", "Signature 19", "Signature 20", 
                  "Signature 21", "Signature R1", "Signature R2", "Signature R3", "Signature U1", "Signature U2", "No Signature"
            )
        )
    }
    
    message(paste(njtree@patientID, " mutational signature information generation done!", sep=""))
    treeMSOutput <- list(sigsInput=sigsInput, mutSigsOutput=mutSigsOutput, df.aetiology=df.aetiology)
    return(treeMSOutput)
}

## Branches' mutation collection
.treeMutationalBranches <- function(maf.dat, branchAlias, mut_sort.id){
    ## get mutationalSigs-related  infomation
    maf_input <- maf.dat
    branchChar <- as.character(branchAlias$Branch)
    datChr <- data.frame(chr=as.character(maf_input$Chromosome), stringsAsFactors=FALSE)
    datChr$chr <- paste("chr", datChr$chr, sep="")
    datMutgene <-  maf_input$Hugo_Symbol
    mutId <- dplyr::select(tidyr::unite(maf_input, "mut.id", 
                                        Hugo_Symbol, Chromosome, 
                                        Start_Position, 
                                        Reference_Allele, Tumor_Seq_Allele2, 
                                        sep=":"), mut.id)
    mutSigRef <- data.frame(as.character(maf_input$Tumor_Sample_Barcode), 
                            datChr, maf_input$Start_Position, 
                            maf_input$End_Position, maf_input$Reference_Allele, 
                            maf_input$Tumor_Seq_Allele2, datMutgene, 
                            mutId, stringsAsFactors=FALSE)
    colnames(mutSigRef) <- c("Sample", 
                             "chr", "pos", 
                             "pos_end", "ref", 
                             "alt", "Hugo_Symbol", 
                             "mut_id")
    
    ## get branch infomation
    ls.branch <- branchChar[order(nchar(branchChar), branchChar)]
    branches <- strsplit(ls.branch, split='∩')
    
    ## generate mutational intersections for each branch
    mutBranchesOutput <- list()
    for (branch in branches){
        ## generate intersection's mut.id and get the mutation information in mutSigRef
        branch <- unlist(branch)
        ## generate the branch name
        branchName <- paste(branch, collapse="∩")
        branch.id <- append(branch, "mut.id")
        unbranch <- names(mut_sort.id)[which(!(names(mut_sort.id) %in% branch.id))]
        ## generate mutation intersection for specific branch
        branch.intersection <- dplyr::intersect(
            mut_sort.id %>% dplyr::filter_at(branch, dplyr::all_vars(. == 1)), 
            mut_sort.id %>% dplyr::filter_at(unbranch, dplyr::all_vars(. == 0))) 
        if (nrow(branch.intersection) == 0){
            message(paste(branchName, ": Mutation Intersection Missing \n", sep=""))
            next()
        }
        branch.mut.id <- branch.intersection$mut.id
        
        ## data duplication
        branch.mut <- mutSigRef[which(mutSigRef$mut_id %in% branch.mut.id), ]
        branch.mut$Sample <- branchName
        branch.mut <- branch.mut[!duplicated(branch.mut),]
        branch.mut$Alias <- as.character(branchAlias[which(branchAlias$Branch == branchName), ]$Alias)
        
        ## generate branch mutation list
        mutBranchesOutput[[branchName]] <- branch.mut
    }
    return(mutBranchesOutput)
}

.dataProcessBT <- function(treeMSOutput) {
    ## input data from treeMSOutput
    sigsInput <- treeMSOutput$sigsInput
    mutSigsOutput <- treeMSOutput$mutSigsOutput
    
    ## label the Trunk
    if (any(mutSigsOutput$alias == "T")){
        trunkName <- mutSigsOutput[which(mutSigsOutput$alias == "T"), ]$branch
    } else {
        stop("Trunk ERROR: There is no trunk mutation and the branch-trunk plot could not be plotted.
             Warnings and outputs from function getNJtree should be checked.")
    } 
    
    ## separate trunk and branch data
    sigsInput.trunk <- sigsInput[which(rownames(sigsInput) == trunkName), ]
    sigsInput.branch <- sigsInput[which(rownames(sigsInput) != trunkName), ]
    sigsInput.branch <- colSums(sigsInput.branch)
    sigsInputBT <- rbind(Trunk=sigsInput.trunk, Branch=sigsInput.branch)
    sigsInputBTTrans <- data.frame(Mutational_Type=colnames(sigsInputBT), t(sigsInputBT))
    ls.mutationGroup <- c("C>A", "C>G", "C>T", "T>A", "T>C", "T>G")
    
    ## generate Mutation Type for every column
    for (mutationGroup in ls.mutationGroup) {
        sigsInputBTTrans$Group[which(grepl(mutationGroup, sigsInputBTTrans$Mutational_Type))] <- mutationGroup
    }
    
    sigsInputBSum <- sigsInputBTTrans %>% dplyr::group_by(Group) %>% dplyr::summarise(sum = sum(Branch))
    sigsInputTSum <- sigsInputBTTrans %>% dplyr::group_by(Group) %>% dplyr::summarise(sum = sum(Trunk))
    
    sigsInputBTTrans <- cbind(sigsInputBTTrans, 
                              BranchFrac=rep(0, nrow(sigsInputBTTrans)), 
                              TrunkFrac=rep(0, nrow(sigsInputBTTrans)))
    for (mutationGroup in ls.mutationGroup) {
        groupBSum <- sigsInputBSum$sum[which(sigsInputBSum$Group == mutationGroup)]
        if (groupBSum == 0) {
            sigsInputBTTrans[which(sigsInputBTTrans$Group == mutationGroup), ]$Branch <- 0
        }
        groupTSum <- sigsInputTSum$sum[which(sigsInputTSum$Group == mutationGroup)]
        if (groupBSum == 0) {
            sigsInputBTTrans[which(sigsInputBTTrans$Group == mutationGroup), ]$Trunk <- 0
        }
        
        sigsInputBTTrans[which(sigsInputBTTrans$Group == mutationGroup), ]$BranchFrac <- 
            100*sigsInputBTTrans[which(sigsInputBTTrans$Group == mutationGroup), ]$Branch/groupBSum
        sigsInputBTTrans[which(sigsInputBTTrans$Group == mutationGroup), ]$TrunkFrac <- 
            100*sigsInputBTTrans[which(sigsInputBTTrans$Group == mutationGroup), ]$Trunk/groupTSum
    }
    
    sigsInputBoxplot <- data.frame(matrix(nrow=0, ncol=5))
    colnames(sigsInputBoxplot) <- c("GroupBT", "Group", "BT", "mut.frac", "mut.num")
    for (mutationGroup in ls.mutationGroup) {
        dat.group <- sigsInputBTTrans[which(sigsInputBTTrans$Group == mutationGroup), ]
        df.groupB <- data.frame(rep(paste(mutationGroup, "Branch", sep=" "), nrow(dat.group)), 
                                rep(mutationGroup, nrow(dat.group)), 
                                rep("Branch", nrow(dat.group)), 
                                dat.group$BranchFrac, 
                                dat.group$Branch)
        df.groupT <- data.frame(rep(paste(mutationGroup, "Trunk", sep=" "), nrow(dat.group)), 
                                rep(mutationGroup, nrow(dat.group)), 
                                rep("Trunk", nrow(dat.group)),
                                dat.group$TrunkFrac, 
                                dat.group$Trunk)
        colnames(df.groupB) <- c("GroupBT", "Group", "BT", "mut.frac", "mut.num")
        colnames(df.groupT) <- c("GroupBT", "Group", "BT", "mut.frac", "mut.num")
        sigsInputBoxplot <- rbind(sigsInputBoxplot, df.groupB, df.groupT)
    }
    
    df.pValue <- data.frame(matrix(ncol = 2, nrow = 0))
    colnames(df.pValue) <- c("Group", "p.value")
    for (mutationGroup in ls.mutationGroup) {
        pValue <- wilcox.test(
            sigsInputBoxplot[
                which(sigsInputBoxplot$Group == mutationGroup & 
                          sigsInputBoxplot$BT == "Branch"), ]$mut.frac, 
            sigsInputBoxplot[
                which(sigsInputBoxplot$Group == mutationGroup & 
                          sigsInputBoxplot$BT == "Trunk"), ]$mut.frac, 
            paired=TRUE, alternative = "two.sided", conf.level=conf.level, 
            exact=FALSE
        )$p.value
        row.pValue <- data.frame(mutationGroup, pValue)
        colnames(row.pValue) <- c("Group", "p.value")
        df.pValue <- rbind(df.pValue, row.pValue)
    }
    output <- list(df.pValue=df.pValue, sigsInputBoxplot=sigsInputBoxplot)
    return(output)
}




