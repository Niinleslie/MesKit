#' Check Mutational Signature for each branch of phylogenetic tree
#' @description Figure out the intersection of the variants on different branches
#' by .treeMutationalBranches and combine the intersection information into njtree
#' object. Check the mutational signatures for each branch of phylogenetic tree
#' by using treeMutationalSig and return a data.frame about the most likely muational
#' signatures.
#' 
#' @import reshape2 BSgenome GenomeInfoDb grDevices graphics utils deconstructSigs cowplot
#' @importFrom plyr match_df
#' 
#' @param njtree the njtree object generated by NJtree function.
#' @param refBuild BSgenome.Hsapiens.UCSC reference. Default "hg19". Full genome sequences for Homo sapiens (Human) as provided by UCSC.
#' @param driverGenesFile the directory of the driver gene list. Default NULL.
#' @param mutThreshold the threshold for the variants in a branch. Default 50.
#' @return data frame of each set/branch's mutational signature.
#' 
#' @examples
#' ## data information
#' maf.File <- system.file("extdata/multi_lesion/maf", "311252.maf", package = "Meskit")
#' sampleInfo.File <- system.file("extdata/multi_lesion", "sample_info.txt", package = "Meskit")
#' pyCloneCluster <- system.file("extdata/multi_lesion/ccf", "311252.cluster.tsv", package = "Meskit")
#' pyCloneLoci <- system.file("extdata/multi_lesion/ccf", "311252.loci.tsv", package = "Meskit")
#' maf <- readMaf(patientID = "311252", mafFile = maf.File, sampleInfoFile = sampleInfo.File, refBuild = "hg19")
#' njtree <- getNJtree(maf)
#' ## general
#' signature1 <- treeMutationalSig(njtree, refBuild="hg19", driverGenesFile=NULL, mutThreshold=50)
#' ## use driverGenesFile
#' putativeDriverGenes.File <- system.file("extdata/multi_lesion", "putative_driver_genes.txt", package = "Meskit")
#' signature2 <- treeMutationalSig(njtree, refBuild="hg19", driverGenesFile=putativeDriverGenes.File, mutThreshold=50)
#' ## use different signature reference
#' signature3 <- treeMutationalSig(njtree, refBuild="hg19", driverGenesFile=NULL, mutThreshold=50, signaturesRef="signatures.nature2013")
#' 
#' @export treeMutationalSig
#'

## Mutational Signature function
treeMutationalSig <- function(njtree, driverGenesFile=NULL, mutThreshold=50, 
                              signaturesRef="signatures.cosmic",
                              plot.Signatures=FALSE){
    ## refBuild limitation: only hg19 or hg38
    refBuild <- njtree@refBuild
    if (!((refBuild == "hg19") | (refBuild == "hg38"))){
        stop(error="Error: refBuild's value may be incorrect. 
             refBuild could be only set as \"hg19\" or \"hg38\".")
    } else {
        refBuild <- paste("BSgenome.Hsapiens.UCSC.", refBuild, sep = "")
    }
    
    ## get branches information from njtree object
    mutBranches <- njtree@mut_branches
    patientID <- njtree@patientID
    branchesName <- names(mutBranches)
    branchesNameList <- strsplit(branchesName, split='∩')
    
    ## regain the data frame of all branches with Sample
    mutSigRef <- data.frame()
    for (branchName in branchesName){
        mutBranch <- mutBranches[[branchName]]
        sample <- data.frame(rep(branchName, length(mutBranch[,1])))
        mutBranch <- cbind(sample, mutBranch)
        mutSigRef <- rbind(mutBranch, mutSigRef)
    }
    colnames(mutSigRef) <- c("Sample", "ID", "chr", "pos", "pos_end",
                             "ref", "alt", "Hugo_Symbol", "mut_id")
    ## get the mutational signature of the branch 
    mutSigsOutput <- data.frame()
    lsPicName <- c()
    for (branchCounter in length(branchesNameList):1){
        ## generate a single branch
        branch <- Filter(Negate(is.na), 
                         branchesNameList[[branchCounter]])
        branchName <- branchesName[branchCounter]
        ## get the mutational signature of the branch
        if (length(mutSigRef[which(
            mutSigRef$Sample == branchName), 1]) < mutThreshold){
            sigsMaxName <- "No.Signature"
            sigsMaxProb <- 0
        }else{
            ## deconstructSigs
            sigsInput <- suppressWarnings(
                mut.to.sigs.input(mut.ref=mutSigRef, 
                                  sample.id="Sample", 
                                  chr="chr", 
                                  pos="pos", 
                                  ref="ref", 
                                  alt="alt",
                                  bsg=get(refBuild)))
            sigsWhich <- whichSignatures(tumor.ref=sigsInput, 
                                         signatures.ref=get(signaturesRef), 
                                         sample.id=branchName,
                                         contexts.needed=TRUE)
            ## plot.MuationalSiganture
            if (plot.Signatures) {
                pic_cha <- paste("branch", ".", branchCounter,
                                 " <- .plotMutationalSig(sigsWhich)", sep="")
                eval(parse(text=pic_cha))
                pic_name <- paste("branch", ".", branchCounter, sep="")
                lsPicName <- c(lsPicName, pic_name)
            }
            ## get mutational signature with max weight
            sigsMax <- sigsWhich[["weights"]][which.max(sigsWhich[["weights"]])]
            sigsMaxName <- colnames(sigsMax)
            sigsMaxProb <- sigsMax[,1]
        }
        
        ## vectorize branch name
        # branch <- gsub(paste(patientID,"-",sep=""), "", branch)
        
        ## figure out putative driver genes
        if (!is.null(driverGenesFile)){
            ## read putative driver genes' list
            driverGenes <- as.character(read.table(
                driverGenesFile, header = TRUE, quote="", sep="\n")[,1])
            ## filter potative driver genes of each branch
            pdgMut <- mutSigRef[which(
                mutSigRef$Sample == branchName &
                    as.character(mutSigRef$Hugo_Symbol) %in% driverGenes),]
            pdgBranch <- as.character(pdgMut$Hugo_Symbol)
            ## collect branches' mutataional signature and potative driver genes
            mutSigsBranch <- data.frame(
                branch=I(list(branch)), 
                sig=sigsMaxName, 
                mut.num=length(
                    mutSigRef[which(
                        mutSigRef$Sample == branchName), 1]), 
                sig.prob=sigsMaxProb, 
                putative_driver_genes=I(list(pdgBranch)))
        } else{
            mutSigsBranch <- data.frame(
                branch=I(list(branch)), 
                sig=sigsMaxName, 
                mut.num=length(mutSigRef[which(
                    mutSigRef$Sample == branchName), 1]), 
                sig.prob=sigsMaxProb)
        }
        ## collect branches' mutataional signature information
        mutSigsOutput <- rbind(mutSigsOutput, mutSigsBranch)
    }
    
    if (plot.Signatures){
        par(mfrow = c(3,1), xpd = FALSE, mar=c(5, 4, 4, 2), oma=c(0,0,0,4))
        picGrid <- eval(parse(text=paste("plot_grid(",
                              paste(lsPicName, collapse=","),
                              ", nrow=",
                              ceiling(length(lsPicName)/2), ", ncol=2, align=\"v\")" ,
                              sep="")))
        message(paste(njtree@patientID, " mutaional signature Summary Plot generation done!", sep=""))
    }
    message(paste(njtree@patientID, " mutaional signature generation done!", sep=""))
    return(mutSigsOutput)
}

## plot.MutationalSigs
.plotMutationalSig <- function(sigsWhich) {
    cur_dev <- grDevices::dev.cur()   # store current device
    pdf(NULL, width = 6, height = 6)  # open null device
    grDevices::dev.control("enable")  # turn on recording for the null device
    null_dev <- grDevices::dev.cur()  # store null device
    
    # make sure we always clean up properly, even if something causes an error
    on.exit({
        grDevices::dev.off(null_dev)
        if (cur_dev > 1) grDevices::dev.set(cur_dev) # only set cur device if not null device
    })
    
    deconstructSigs::plotSignatures(sigsWhich, sub = 'example')
    recordPlot() 
}

## Branches' mutation collection
.treeMutationalBranches <- function(maf, branch){
    ## get mutationalSigs-related  infomation
    maf_input <- maf@data
    patientID <- maf@patientID
    datSample <- data.frame(as.character(maf_input$Tumor_Sample_Barcode), stringsAsFactors=FALSE)
    datChr <- data.frame(chr=as.character(maf_input$Chromosome), stringsAsFactors=FALSE)
    datChr$chr <- paste("chr", datChr$chr, sep="")
    datPosStart <- maf_input$Start_Position
    datPosEnd <- maf_input$End_Position
    datRef <- maf_input$Reference_Allele
    datAlt <- maf_input$Tumor_Seq_Allele2
    datNum <- seq_along(datAlt)
    datMutgene <-  maf_input$Hugo_Symbol
    mutId <- dplyr::select(tidyr::unite(maf_input, "mut.id", 
                                        Hugo_Symbol, Chromosome, 
                                        Start_Position, End_Position, 
                                        Reference_Allele, Tumor_Seq_Allele2, 
                                        sep=":"), mut.id)
    mutSigRef <- data.frame(datNum, datSample, 
                            datChr, datPosStart, 
                            datPosEnd, datRef, 
                            datAlt, datMutgene, 
                            mutId)
    colnames(mutSigRef) <- c("ID", "Sample", 
                             "chr", "pos", 
                             "pos_end", "ref", 
                             "alt", "Hugo_Symbol", 
                             "mut_id")
    
    ## get branch infomation
    branch <- branch[order(nchar(branch), branch)]
    branches <- strsplit(branch, split='∩')
    
    
    ## output collection
    mutBranches <- data.frame()
    mutBranchesOutput <- list()
    listBranchName <- c()
    ## generate mutational signautres for different branches
    for (branchCounter in length(branches):1){
        ## generate a single branch
        branch <- Filter(Negate(is.na), 
                         branches[[branchCounter]])
        mutBranch <- mutSigRef[which(mutSigRef$Sample %in% branch), ]
        
        for (tsb in branch){
            ## generate the intersection of the branch
            mutTsb <- mutSigRef[which(mutSigRef$Sample %in% tsb), ]
            mutBranch <- match_df(mutBranch, mutTsb, on=c("chr", "pos", "pos_end", "ref", "alt"))
        }
        
        ## generate the branch name
        branchName <- paste(branch, collapse="∩")
        
        if (length(mutBranch[,1]) == 0){
            ## fix the problem when no intersection found
            next()
        } else{
            ## label the intersection(set) of the branch
            mutSigRef[which(
                mutSigRef[,1] %in% mutBranch[,1]), 2] <- branchName
            
            ## duplicate the same mutation
            mutBranchIntersection <- mutSigRef[which(
                mutSigRef$Sample == branchName & (!duplicated(mutSigRef$mut_id))), ]
            mutBranches <- rbind(mutBranches, mutBranchIntersection)
            mutBranchesOutput[[branchCounter]] <- subset(
                mutBranchIntersection,select=-c(Sample))
            listBranchName <- c(branchName, listBranchName)
        }
        
    }
    names(mutBranchesOutput) <- listBranchName
    ## return the data frame of mutational signature for all branches
    return(mutBranchesOutput)
}
