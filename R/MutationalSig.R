#' treeMutationalSig
#' @description Figure out the intersection of the variants on different branches
#' by .treeMutationalBranches and combine the intersection information into njtree
#' object. Check the mutational signatures for each branch of phylogenetic tree
#' by using treeMutationalSig and return a data.frame about the most likely muational
#' signatures.
#' 
#' @import dplyr ggplot2 reshape2 grDevices graphics utils cowplot grid
#' 

#' @param njtree the njtree object generated by NJtree function.
#' @param driverGenesFile the directory of the driver gene list. Default NULL.
#' @param mutThreshold the threshold for the variants in a branch. Default 50.
#' @param plot.signatures the parameter used to print the signautre summary plot by ggplot2
#' @param signaturesRef Default "cosmic". Option: "nature2013". the parameter used for deconstructSig.
#' @param plot.signatures choose whether plot signatures
#' @param plot.branchTrunk choose whether output a branch-Trunk plot.
#' @param conf.level the significance level to vertify whether the kind of mutation is significant.
#' @return data frame of each set/branch's mutational signature.
#' 
#' @examples
#' ## data information
#' maf.File <- system.file("extdata/multi_lesion/maf", "311252.maf", package = "MesKit")
#' sampleInfo.File <- system.file("extdata/multi_lesion", "sample_info.txt", package = "MesKit")
#' pyCloneCluster <- system.file("extdata/multi_lesion/ccf", "311252.cluster.tsv", package = "MesKit")
#' pyCloneLoci <- system.file("extdata/multi_lesion/ccf", "311252.loci.tsv", package = "MesKit")
#' TODO: need to be completed 
#' 
#' @export treeMutationalSig


## Mutational Signature function
treeMutationalSig <- function(njtree, driverGenesFile=NULL, mutThreshold=50, 
                              signaturesRef="cosmic"){
    ## refBuild limitation: only hg19 or hg38
    refBuild <- njtree@refBuild
    if (!((refBuild == "hg19") | (refBuild == "hg38"))){
        stop(error="Error: refBuild's value may be incorrect. 
             refBuild could be only set as \"hg19\" or \"hg38\".")
    } else {
        refBuild <- paste("BSgenome.Hsapiens.UCSC.", refBuild, sep = "")
    }
    
    ## get branches information from njtree object
    mutBranches <- njtree@mut_branches
    patientID <- njtree@patientID
    branchesName <- names(mutBranches)
    branchesNameList <- strsplit(branchesName, split='∩')
    
    ## regain the data frame of all branches with Sample
    mutSigRef <- data.frame()
    for (branchName in branchesName){
        mutBranch <- mutBranches[[branchName]]
        mutSigRef <- rbind(mutBranch, mutSigRef)
    }
    colnames(mutSigRef) <- c("Sample",  "chr", "pos", "pos_end", 
                             "ref", "alt", "Hugo_Symbol", "mut_id", 
                             "alias")
    ## get the mutational signature of the branch 
    mutSigsOutput <- data.frame()
    lsPicName <- c()
    for (branchCounter in length(branchesNameList):1){
        ## generate a single branch
        branch <- Filter(Negate(is.na), 
                         branchesNameList[[branchCounter]])
        branchName <- branchesName[branchCounter]
        ## get the mutational signature of the branch
        if (length(mutSigRef[which(
            mutSigRef$Sample == branchName), 1]) < mutThreshold){
            sigsMaxName <- "No Signature"
            sigsMaxProb <- 0
            message(paste("Branch ", branchName,
                          ": Number of mutations is less than mutThreshold.",
                          sep = ""))
            # next()
        }else{
            ## deconstructSigs
            sigsInput <- suppressWarnings(
                deconstructSigs::mut.to.sigs.input(mut.ref=mutSigRef, 
                                                   sample.id="Sample", 
                                                   chr="chr", 
                                                   pos="pos", 
                                                   ref="ref", 
                                                   alt="alt",
                                                   bsg=get(refBuild)))
            if (signaturesRef == "cosmic") {
                sigsWhich <- deconstructSigs::whichSignatures(tumor.ref=sigsInput, 
                                                              signatures.ref=deconstructSigs::signatures.cosmic, 
                                                              sample.id=branchName,
                                                              contexts.needed=TRUE)
            } else if (signaturesRef == "nature2013") {
                sigsWhich <- deconstructSigs::whichSignatures(tumor.ref=sigsInput, 
                                                              signatures.ref=deconstructSigs::signatures.nature2013, 
                                                              sample.id=branchName,
                                                              contexts.needed=TRUE)
            }
            
            
            ## get mutational signature with max weight
            sigsMax <- sigsWhich[["weights"]][which.max(sigsWhich[["weights"]])]
            sigsMaxName <- colnames(sigsMax)
            sigsMaxName <- gsub('[.]', ' ', sigsMaxName)
            sigsMaxProb <- sigsMax[,1]
        }
        
        ## vectorize branch name
        # branch <- gsub(paste(patientID,"-",sep=""), "", branch)
        
        ## figure out putative driver genes
        if (!is.null(driverGenesFile)){
            ## read putative driver genes' list
            driverGenes <- as.character(read.table(
                driverGenesFile, header = TRUE, quote="", sep="\n")[,1])
            ## filter potative driver genes of each branch
            pdgMut <- mutSigRef[which(
                mutSigRef$Sample == branchName &
                    as.character(mutSigRef$Hugo_Symbol) %in% driverGenes),]
            pdgBranch <- as.character(pdgMut$Hugo_Symbol)
            ## collect branches' mutataional signature and potative driver genes
            mutSigsBranch <- data.frame(
                branch=c(branchName), 
                alias=as.character(unique(mutSigRef[which(mutSigRef$Sample == branchName), ]$alias)), 
                sig=sigsMaxName, 
                mut.num=length(
                    mutSigRef[which(
                        mutSigRef$Sample == branchName), 1]), 
                sig.prob=format(round(sigsMaxProb, digits = 3), nsmall = 3), 
                putative_driver_genes=c(paste(pdgBranch, collapse = ",")))
        } else{
            mutSigsBranch <- data.frame(
                branch=c(branchName), 
                alias=as.character(unique(mutSigRef[which(mutSigRef$Sample == branchName), ]$alias)), 
                sig=sigsMaxName, 
                mut.num=length(mutSigRef[which(
                    mutSigRef$Sample == branchName), 1]), 
                sig.prob=format(round(sigsMaxProb, digits = 3), nsmall = 3))
        }
        ## collect branches' mutataional signature information
        mutSigsOutput <- rbind(mutSigsOutput, mutSigsBranch)
    }
    
    
    ## calculation process(maybe could be replaced by lapply)
    if (signaturesRef =="cosmic") {
        ## Aetiology from https://cancer.sanger.ac.uk/cosmic/signatures_v2 emm actually the additional feature may matter
        df.aetiology <- data.frame(
            aeti=c(
                "An endogenous mutational process initiated by spontaneous deamination of 5-methylcytosine",
                "Activity of the AID/APOBEC family of cytidine deaminases", 
                "Failure of DNA double-strand break-repair by homologous recombination",
                "Tobacco mutagens", 
                "Unknown", 
                "Defective DNA mismatch repair and is found in microsatellite unstable tumours",
                "Ultraviolet light exposure", 
                "Unknown", 
                "Polymerase η, which is implicated with the activity of AID during somatic hypermutation", 
                "Recurrent POLE somatic mutations, viz., Pro286Arg and Val411Leu.",
                "Treatments with the alkylating agent temozolomide", 
                "Unknown", 
                "Activity of the AID/APOBEC family of cytidine deaminases(C > U)",
                "Unknown", 
                "Defective DNA mismatch repair", 
                "Unknown", 
                "Unknown",
                "Unknown", 
                "Unknown", 
                "Defective DNA mismatch repair", 
                "Unknown",
                "Exposures to aristolochic acid", 
                "Unknown", 
                "Exposures to aflatoxin",
                "Unknown", 
                "Defective DNA mismatch repair", 
                "Unknown", 
                "Unknown",
                "Tobacco chewing habit", 
                "Unknown", 
                "Unknown"), 
            sig=c("Signature 1", "Signature 2", "Signature 3", "Signature 4", "Signature 5", "Signature 6",
                  "Signature 7", "Signature 8", "Signature 9", "Signature 10", "Signature 11", "Signature 12", 
                  "Signature 13", "Signature 14", "Signature 15", "Signature 16", "Signature 17", "Signature 18",
                  "Signature 19", "Signature 20", "Signature 21", "Signature 22", "Signature 23", "Signature 24", 
                  "Signature 25", "Signature 26", "Signature 27", "Signature 28", "Signature 29", "Signature 30", 
                  "No Signature")
        )
    } else if (signaturesRef =="nature2013") {
        ## Aetiology from https://www.nature.com/articles/nature12477#s1
        df.aetiology <- data.frame(
            aeti=c(
                "Deamination of 5-methyl-cytosine",
                "Deamination of 5-methyl-cytosine", 
                "AID/APOBEC family of cytidine deaminases",
                "Defective homologous-recombination-based DNA double-strand break repair", 
                "Tobacco carcinogens", 
                "Smoking history, C>T and T>C mutations",
                "Defective DNA mismatch repair", 
                "Ultraviolet-light-induced mutations",
                "Exogenous carcinogens, transcription-coupled nucleotide excision repair acting on bulky DNA adducts", 
                "Polymerase η, which is implicated with the activity of AID during somatic hypermutation",
                "Polymerase ε, altered activity of the error-prone polymerase Pol ε", 
                "Alkylating agent temozolomide", 
                "Exogenous carcinogens, transcription-coupled nucleotide excision repair acting on bulky DNA adducts",
                "AID/APOBEC family of cytidine deaminases", 
                "Uncharacterized defects in DNA maintenance", 
                "Uncharacterized defects in DNA maintenance", 
                "Exogenous carcinogens, transcription-coupled nucleotide excision repair acting on bulky DNA adducts",
                "Unknown", 
                "Unknown", 
                "Unknown",
                "Unknown",
                "Uncharacterized defects in DNA maintenance", 
                "Unknown",
                "Unknown",
                "Unknown", 
                "Unknown", 
                "Unknown", 
                "Unknown"), 
            sig=c("Signature 1A", "Signature 1B", "Signature 2", "Signature 3", "Signature 4", "Signature 5", "Signature 6",
                  "Signature 7", "Signature 8", "Signature 9", "Signature 10", "Signature 11", "Signature 12", "Signature 13", 
                  "Signature 14", "Signature 15", "Signature 16", "Signature 17", "Signature 18", "Signature 19", "Signature 20", 
                  "Signature 21", "Signature R1", "Signature R2", "Signature R3", "Signature U1", "Signature U2", "No Signature"
            )
        )
    }
    
    message(paste(njtree@patientID, " mutational signature information generation done!", sep=""))
    treeMSOutput <- list(sigsInput=sigsInput, mutSigsOutput=mutSigsOutput, df.aetiology=df.aetiology)
    return(treeMSOutput)
}

#' treeMutationalSig
#' @description Figure out the intersection of the variants on different branches
#' by .treeMutationalBranches and combine the intersection information into njtree
#' object. Check the mutational signatures for each branch of phylogenetic tree
#' by using treeMutationalSig and return a data.frame about the most likely muational
#' signatures.
#' 
#' @import dplyr ggplot2 reshape2 grDevices graphics utils cowplot grid
#' 
#' @param njtree the njtree object generated by NJtree function.
#' @param driverGenesFile the directory of the driver gene list. Default NULL.
#' @param mutThreshold the threshold for the variants in a branch. Default 50.
#' @param plot.signatures the parameter used to print the signautre summary plot by ggplot2
#' @param signaturesRef Default "cosmic". Option: "nature2013". the parameter used for deconstructSig.
#' @param plot.signatures choose whether plot signatures
#' @param plot.branchTrunk choose whether output a branch-Trunk plot.
#' @param conf.level the significance level to vertify whether the kind of mutation is significant.
#' @return data frame of each set/branch's mutational signature.
#' 
#' @examples
#' ## data information
#' maf.File <- system.file("extdata/multi_lesion/maf", "311252.maf", package = "MesKit")
#' sampleInfo.File <- system.file("extdata/multi_lesion", "sample_info.txt", package = "MesKit")
#' pyCloneCluster <- system.file("extdata/multi_lesion/ccf", "311252.cluster.tsv", package = "MesKit")
#' pyCloneLoci <- system.file("extdata/multi_lesion/ccf", "311252.loci.tsv", package = "MesKit")
#' TODO: need to be completed 
#' 
#' @export treeMutationalSig

sumMutationalSig <- function(treeMSOutput){
    mutSigsOutput <- treeMSOutput$mutSigsOutput
    df.aetiology <- treeMSOutput$df.aetiology
    
    ## list of branch names
    ls.branchesName <- mutSigsOutput$branch
    ls.aeti <- c()
    
    for (branch in ls.branchesName) {
        signature <- as.character(mutSigsOutput[which(mutSigsOutput$branch == branch), ]$sig)
        aetiology <- as.character(df.aetiology[which(df.aetiology$sig == signature), ]$aeti)
        ls.aeti <- c(ls.aeti, aetiology)
    }
    
    
    ## rearrange the order of columns
    if (is.null(driverGenesFile)) {
        mutSigsOutput <- data.frame(branch=mutSigsOutput$branch,
                                    alias=mutSigsOutput$alias, 
                                    mut.num=mutSigsOutput$mut.num, 
                                    sig=mutSigsOutput$sig, 
                                    sig.prob=mutSigsOutput$sig.prob, 
                                    aeti=ls.aeti)
        colnames(mutSigsOutput) <- c("Branch", "Alias", "Mutation quantity", "Signature", "Signature weight", "Aetiology")
    } else {
        mutSigsOutput <- data.frame(branch=mutSigsOutput$branch,
                                    alias=mutSigsOutput$alias, 
                                    mut.num=mutSigsOutput$mut.num, 
                                    sig=mutSigsOutput$sig, 
                                    sig.prob=mutSigsOutput$sig.prob,
                                    aeti=ls.aeti,
                                    putative_driver_genes=mutSigsOutput$putative_driver_genes)
        colnames(mutSigsOutput) <- c("Branch", "Alias", "Mutation quantity", "Signature", "Signature weight", "Aetiology", "Oncogene list")
    }
    return(mutSigsOutput)
}

## plot.MutationalSigs
plotMutationalSig <- function(treeMSOutput) {
    sigsInput <- treeMSOutput$sigsInput
    mutSigsOutput <- treeMSOutput$mutSigsOutput
    df.aetiology <- treeMSOutput$df.aetiology
    
    ## calculate the Mutation Probability
    sigsInputSum <- as.data.frame(apply(sigsInput, 1, function(x) sum(x)))
    sigsInputTrans <- as.data.frame(t(sigsInput))
    ls.branchesName <- as.character(rownames(sigsInput))
    ls.mutationType <-as.character(rownames(sigsInputTrans))
    ls.mutationGroup <- c("C>A", "C>G", "C>T", "T>A", "T>C", "T>G")
    sigsInputBranches <- data.frame()
    
    ## calculation process(maybe could be replaced by lapply)
    for (branch in ls.branchesName) {
        sigsInputTrans[branch] <- sigsInputTrans[branch]/sigsInputSum[branch, ]
        signature <- as.character(mutSigsOutput[which(mutSigsOutput$branch == branch), ]$sig)
        alias <- as.character(mutSigsOutput[which(mutSigsOutput$branch == branch), ]$alias)
        sigsWeight <- mutSigsOutput[which(mutSigsOutput$branch == branch), ]$sig.prob
        aetiology <- as.character(df.aetiology[which(df.aetiology$sig == signature), ]$aeti)
        sigsInputBranch <- data.frame(sigsInputTrans[branch], 
                                      rep(branch, length(sigsInputTrans[branch])), 
                                      rep(alias, length(sigsInputTrans[branch])), 
                                      rep(signature, length(sigsInputTrans[branch])), 
                                      rep(sigsWeight, length(sigsInputTrans[branch])), 
                                      rep(aetiology , length(sigsInputTrans[branch])), 
                                      stringsAsFactors = FALSE)
        colnames(sigsInputBranch) <- c("Mutation_Probability", "Branch", "Alias", "Signature", "SigsWeight", "Aetiology")
        sigsInputBranches <- rbind(sigsInputBranches, sigsInputBranch)
    }
    
    df.sigsInputTrans <- data.frame(Mutational_Type=ls.mutationType, 
                                    Group=ls.mutationType, 
                                    sigsInputBranches, 
                                    stringsAsFactors = FALSE)
    
    ## generate Mutation Type for every column
    for (mutationGroup in ls.mutationGroup) {
        df.sigsInputTrans$Group[which(grepl(mutationGroup, df.sigsInputTrans$Group))] <- mutationGroup
    }
    
    ## specific the label order of x axis
    orderlist <- c(ls.mutationType)
    df.sigsInputTrans <- transform(df.sigsInputTrans, Mutational_Type = factor(Mutational_Type, levels = orderlist))
    df.sigsInputTrans <- df.sigsInputTrans[which(df.sigsInputTrans$Signature != "No Signature"), ]
    df.sigsInputText <- dplyr::distinct(df.sigsInputTrans, Branch, .keep_all = TRUE)
    
    # group.colors <- c("#009AEC", "#000000", "#C10000", "#A5A5A5", "#00C491", "#FF4FB1")
    CA <- grid::textGrob(expression(bold("C > A")),gp=grid::gpar(fontsize=6, fontface="bold"),vjust=0,hjust=1)
    CG <- grid::textGrob(expression(bold("C > G")),gp=grid::gpar(fontsize=6, fontface="bold"),vjust=0,hjust=1)
    CT <- grid::textGrob(expression(bold("C > T")),gp=grid::gpar(fontsize=6, fontface="bold"),vjust=0,hjust=1)
    TA <- grid::textGrob(expression(bold("T > A")),gp=grid::gpar(fontsize=6, fontface="bold"),vjust=0,hjust=1)
    TC <- grid::textGrob(expression(bold("T > C")),gp=grid::gpar(fontsize=6, fontface="bold"),vjust=0,hjust=1)
    TG <- grid::textGrob(expression(bold("T > G")),gp=grid::gpar(fontsize=6, fontface="bold"),vjust=0,hjust=1)
    
    group.colors <- ggsci::pal_npg("nrc", alpha=1)(6)
    pic <- ggplot(df.sigsInputTrans, aes(x=Mutational_Type, y=Mutation_Probability, group=Group, fill=Group)) + 
        geom_bar(stat="identity") + 
        theme(panel.grid=element_blank(), 
              panel.border=element_blank(), 
              panel.background = element_blank(), 
              legend.position='none', 
              # axis.text.x=element_text(size=3, angle = 45, hjust = 1, vjust = 1), 
              axis.text.x=element_blank(), 
              axis.ticks.x=element_blank(),
              axis.text.y=element_text(size=5)) +
        ## background colors
        geom_rect(aes(xmin=0, xmax=16.5, ymin=0, ymax=Inf),
                  fill="#fce7e4", alpha=0.15) + 
        geom_rect(aes(xmin=16.5, xmax=32.5, ymin=0, ymax=Inf),
                  fill="#ecf8fa", alpha=0.25) + 
        geom_rect(aes(xmin=32.5, xmax=48.5, ymin=0, ymax=Inf),
                  fill="#dbfff9", alpha=0.05) + 
        geom_rect(aes(xmin=48.5, xmax=64.5, ymin=0, ymax=Inf),
                  fill="#e4e8f3", alpha=0.08) + 
        geom_rect(aes(xmin=64.5, xmax=80.5, ymin=0, ymax=Inf),
                  fill="#fdefeb", alpha=0.15) + 
        geom_rect(aes(xmin=80.5, xmax=96.5, ymin=0, ymax=Inf),
                  fill="#e5e8ef", alpha=0.1) + 
        ## barplot
        geom_bar(stat="identity") + 
        ## combine different results
        facet_grid(Alias ~ .) + 
        ## color setting
        scale_fill_manual(values=group.colors) + 
        ## axis setting
        xlab("Mutational type") + 
        ylab("Mutation probability") + 
        scale_y_continuous(limits=c(-0.03, 0.2), breaks=seq(0, 0.2, 0.1)) + 
        ## signature notes and text parts
        geom_text(data = df.sigsInputText, 
                  aes(x=-Inf, y=Inf, label=paste(Signature, ": ", 
                                                 round(as.numeric(levels(SigsWeight)[SigsWeight]), 3), 
                                                 "    ", 
                                                 "Aetiology: ", Aetiology, sep="")), 
                  hjust = -0.02, vjust = 1.5, colour="#2B2B2B", fontface = "bold", size=2.75) + 
        ## Mutational Type Labels
        annotation_custom(grob = CA,  xmin = 10, xmax = 10, ymin = -0.065, ymax = -0) + 
        annotation_custom(grob = CG,  xmin = 27, xmax = 27, ymin = -0.065, ymax = -0) + 
        annotation_custom(grob = CT,  xmin = 43, xmax = 43, ymin = -0.065, ymax = -0) + 
        annotation_custom(grob = TA,  xmin = 59, xmax = 59, ymin = -0.065, ymax = -0) + 
        annotation_custom(grob = TC,  xmin = 75, xmax = 75, ymin = -0.065, ymax = -0) + 
        annotation_custom(grob = TG,  xmin = 91, xmax = 91, ymin = -0.065, ymax = -0) + 
        ## x axis bar
        geom_rect(aes(xmin=0, xmax=16.405, ymin=-0.01, ymax=-0.005),
                  fill=group.colors[1], alpha=1) + 
        geom_rect(aes(xmin=16.595, xmax=32.405, ymin=-0.01, ymax=-0.005),
                  fill=group.colors[2], alpha=0.25) + 
        geom_rect(aes(xmin=32.595, xmax=48.405, ymin=-0.01, ymax=-0.005),
                  fill=group.colors[3], alpha=0.05) + 
        geom_rect(aes(xmin=48.595, xmax=64.405, ymin=-0.01, ymax=-0.005),
                  fill=group.colors[4], alpha=0.08) + 
        geom_rect(aes(xmin=64.595, xmax=80.405, ymin=-0.01, ymax=-0.005),
                  fill=group.colors[5], alpha=0.15) + 
        geom_rect(aes(xmin=80.595, xmax=96.5, ymin=-0.01, ymax=-0.005),
                  fill=group.colors[6], alpha=0.1)
    message("Mutaional signature plot generation done!")
    return(pic)
}

plotBranchTrunk <- function(treeMSOutput, conf.level=0.95) {
    sigsInput <- treeMSOutput$sigsInput
    mutSigsOutput <- treeMSOutput$mutSigsOutput
    
    if (any(mutSigsOutput$alias == "T")){
        trunkName <- mutSigsOutput[which(mutSigsOutput$alias == "T"), ]$branch
    } else {
        stop("Trunk ERROR: There is no trunk mutation and the branch-trunk plot could not be plotted.
             Warnings and outputs from function getNJtree should be checked.")
    } 
    sigsInput.trunk <- sigsInput[which(rownames(sigsInput) == trunkName), ]
    sigsInput.branch <- sigsInput[which(rownames(sigsInput) != trunkName), ]
    sigsInput.branch <- colSums(sigsInput.branch)
    sigsInputBT <- rbind(Trunk=sigsInput.trunk, Branch=sigsInput.branch)
    sigsInputBTTrans <- data.frame(Mutational_Type=colnames(sigsInputBT), t(sigsInputBT))
    ls.mutationGroup <- c("C>A", "C>G", "C>T", "T>A", "T>C", "T>G")
    
    ## generate Mutation Type for every column
    for (mutationGroup in ls.mutationGroup) {
        sigsInputBTTrans$Group[which(grepl(mutationGroup, sigsInputBTTrans$Mutational_Type))] <- mutationGroup
    }
    
    sigsInputBSum <- sigsInputBTTrans %>% group_by(Group) %>% dplyr::summarise(sum = sum(Branch))
    sigsInputTSum <- sigsInputBTTrans %>% group_by(Group) %>% dplyr::summarise(sum = sum(Trunk))
    
    for (mutationGroup in ls.mutationGroup) {
        groupBSum <- sigsInputBSum$sum[which(sigsInputBSum$Group == mutationGroup)]
        if (groupBSum == 0) {
            sigsInputBTTrans[which(sigsInputBTTrans$Group == mutationGroup), ]$Branch <- 0
        }
        groupTSum <- sigsInputTSum$sum[which(sigsInputTSum$Group == mutationGroup)]
        if (groupBSum == 0) {
            sigsInputBTTrans[which(sigsInputBTTrans$Group == mutationGroup), ]$Trunk <- 0
        }
        sigsInputBTTrans[which(sigsInputBTTrans$Group == mutationGroup), ]$Branch <- 
            100*sigsInputBTTrans[which(sigsInputBTTrans$Group == mutationGroup), ]$Branch/groupBSum
        sigsInputBTTrans[which(sigsInputBTTrans$Group == mutationGroup), ]$Trunk <- 
            100*sigsInputBTTrans[which(sigsInputBTTrans$Group == mutationGroup), ]$Trunk/groupTSum
    }
    
    sigsInputBoxplot <- data.frame(matrix(nrow=0, ncol=4))
    colnames(sigsInputBoxplot) <- c("GroupBT", "Group", "BT", "mut.frac")
    
    for (mutationGroup in ls.mutationGroup) {
        dat.group <- sigsInputBTTrans[which(sigsInputBTTrans$Group == mutationGroup), ]
        df.groupB <- data.frame(rep(paste(mutationGroup, "Branch", sep=" "), nrow(dat.group)), 
                                rep(mutationGroup, nrow(dat.group)), 
                                rep("Branch", nrow(dat.group)), 
                                dat.group$Branch)
        df.groupT <- data.frame(rep(paste(mutationGroup, "Trunk", sep=" "), nrow(dat.group)), 
                                rep(mutationGroup, nrow(dat.group)), 
                                rep("Trunk", nrow(dat.group)),
                                dat.group$Trunk)
        colnames(df.groupB) <- c("GroupBT", "Group", "BT", "mut.frac")
        colnames(df.groupT) <- c("GroupBT", "Group", "BT", "mut.frac")
        sigsInputBoxplot <- rbind(sigsInputBoxplot, df.groupB, df.groupT)
    }
    
    df.pValue <- data.frame(matrix(ncol = 2, nrow = 0))
    colnames(df.pValue) <- c("Group", "p.value")
    for (mutationGroup in ls.mutationGroup) {
        pValue <- wilcox.test(
            sigsInputBoxplot[
                which(sigsInputBoxplot$Group == mutationGroup & 
                          sigsInputBoxplot$BT == "Branch"), ]$mut.frac, 
            sigsInputBoxplot[
                which(sigsInputBoxplot$Group == mutationGroup & 
                          sigsInputBoxplot$BT == "Trunk"), ]$mut.frac, 
            paired=TRUE, alternative = "two.sided", conf.level=conf.level, 
            exact=FALSE
        )$p.value
        row.pValue <- data.frame(mutationGroup, pValue)
        colnames(row.pValue) <- c("Group", "p.value")
        df.pValue <- rbind(df.pValue, row.pValue)
    }
    
    ## p values of mutational list
    if (df.pValue[which(df.pValue$Group == "C>A"), ]$p.value <= (1-conf.level)) {
        CApV <- grid::textGrob(paste("p = ", as.character(
            round(df.pValue[which(df.pValue$Group == "C>A"), ]$p.value, 
                  digits = 3)), "*", sep=""), 
            gp=gpar(fontsize=12),vjust=0,hjust=1)    
    } else {
        CApV <- grid::textGrob(expression(""), 
                               gp=gpar(fontsize=12),vjust=0,hjust=1) 
    }
    
    if (df.pValue[which(df.pValue$Group == "C>G"), ]$p.value <= (1-conf.level)) {
        CGpV <- grid::textGrob(paste("p = ", as.character(
            round(df.pValue[which(df.pValue$Group == "C>G"), ]$p.value, 
                  digits = 3)), "*", sep=""), 
            gp=gpar(fontsize=12),vjust=0,hjust=1)
    } else {
        CGpV <- grid::textGrob(expression(""), 
                               gp=gpar(fontsize=12),vjust=0,hjust=1)
    }
    
    if (df.pValue[which(df.pValue$Group == "C>T"), ]$p.value <= (1-conf.level)) {
        CTpV <- grid::textGrob(paste("p = ", as.character(
            round(df.pValue[which(df.pValue$Group == "C>T"), ]$p.value, 
                  digits = 3)), "*", sep=""), 
            gp=gpar(fontsize=12),vjust=0,hjust=1)
    } else {
        CTpV <- grid::textGrob(expression(""), 
                               gp=gpar(fontsize=12),vjust=0,hjust=1)
    }
    
    if (df.pValue[which(df.pValue$Group == "T>A"), ]$p.value <= (1-conf.level)) {
        TApV <- grid::textGrob(paste("p = ", as.character(
            round(df.pValue[which(df.pValue$Group == "T>A"), ]$p.value, 
                  digits = 3)), "*", sep=""),
            gp=gpar(fontsize=12),vjust=0,hjust=1)
    } else {
        TApV <- grid::textGrob(expression(""), 
                               gp=gpar(fontsize=12),vjust=0,hjust=1)
    }
    
    if (df.pValue[which(df.pValue$Group == "T>C"), ]$p.value <= (1-conf.level)) {
        TCpV <- grid::textGrob(paste("p = ", as.character(
            round(df.pValue[which(df.pValue$Group == "T>C"), ]$p.value, 
                  digits = 3)), "*", sep=""),
            gp=gpar(fontsize=12),vjust=0,hjust=1)
    } else {
        TCpV <- grid::textGrob(expression(""), 
                               gp=gpar(fontsize=12),vjust=0,hjust=1)
    }
    
    if (df.pValue[which(df.pValue$Group == "T>G"), ]$p.value <= (1-conf.level)) {
        TGpV <- grid::textGrob(paste("p = ", as.character(
            round(df.pValue[which(df.pValue$Group == "T>G"), ]$p.value, 
                  digits = 3)), "*", sep=""),
            gp=gpar(fontsize=12),vjust=0,hjust=1)
    } else {
        TGpV <- grid::textGrob(expression(""), 
                               gp=gpar(fontsize=12),vjust=0,hjust=1)
    }
    
    ## names of mutational list
    CA <- grid::textGrob(expression(bold("C > A")),gp=gpar(fontsize=12, fontface="bold"),vjust=0,hjust=1)
    CG <- grid::textGrob(expression(bold("C > G")),gp=gpar(fontsize=12, fontface="bold"),vjust=0,hjust=1)
    CT <- grid::textGrob(expression(bold("C > T")),gp=gpar(fontsize=12, fontface="bold"),vjust=0,hjust=1)
    TA <- grid::textGrob(expression(bold("T > A")),gp=gpar(fontsize=12, fontface="bold"),vjust=0,hjust=1)
    TC <- grid::textGrob(expression(bold("T > C")),gp=gpar(fontsize=12, fontface="bold"),vjust=0,hjust=1)
    TG <- grid::textGrob(expression(bold("T > G")),gp=gpar(fontsize=12, fontface="bold"),vjust=0,hjust=1)
    
    group.colors <- ggsci::pal_npg("nrc", alpha=1)(6)
    pic <- ggplot(sigsInputBoxplot, aes(x=GroupBT, y=mut.frac, fill=Group)) + 
        geom_boxplot(coef=100) + 
        theme(panel.grid=element_blank(), 
              panel.border=element_blank(), 
              panel.background = element_blank(), 
              legend.position='none', 
              axis.text.x=element_text(size=10, angle = 90, vjust = 0.5, hjust=1), 
              axis.ticks.x = element_blank(), 
              axis.text.y=element_text(size=10)) + 
        ## background colors
        geom_rect(aes(xmin=0.5, xmax=2.5, ymin=0, ymax=104),
                  fill="#fce7e4", alpha=0.15) + 
        geom_rect(aes(xmin=2.5, xmax=4.5, ymin=0, ymax=104),
                  fill="#ecf8fa", alpha=0.25) + 
        geom_rect(aes(xmin=4.5, xmax=6.5, ymin=0, ymax=104),
                  fill="#dbfff9", alpha=0.05) + 
        geom_rect(aes(xmin=6.5, xmax=8.5, ymin=0, ymax=104),
                  fill="#e4e8f3", alpha=0.08) + 
        geom_rect(aes(xmin=8.5, xmax=10.5, ymin=0, ymax=104),
                  fill="#fdefeb", alpha=0.15) + 
        geom_rect(aes(xmin=10.5, xmax=12.5, ymin=0, ymax=104),
                  fill="#e5e8ef", alpha=0.1) + 
        geom_boxplot(coef=100) + 
        ## color setting
        scale_fill_manual(values=group.colors) + 
        ## axis setting
        scale_x_discrete(name = "", labels=c("Branch", "Trunk", "Branch", "Trunk", 
                                             "Branch", "Trunk", "Branch", "Trunk",
                                             "Branch", "Trunk", "Branch", "Trunk")) + 
        scale_y_continuous(name = "Mutation fraction(%)", limits=c(-5, 104), breaks=seq(0, 100, 25)) + 
        coord_cartesian(ylim = c(0,100), expand = TRUE) + 
        ## x axis bar
        geom_rect(aes(xmin=0.5, xmax=2.5, ymin=-5, ymax=-0.5),
                  fill=group.colors[1], alpha=1) + 
        geom_rect(aes(xmin=2.5, xmax=4.5, ymin=-5, ymax=-0.5),
                  fill=group.colors[2], alpha=0.25) + 
        geom_rect(aes(xmin=4.5, xmax=6.5, ymin=-5, ymax=-0.5),
                  fill=group.colors[3], alpha=0.05) + 
        geom_rect(aes(xmin=6.5, xmax=8.5, ymin=-5, ymax=-0.5),
                  fill=group.colors[4], alpha=0.08) + 
        geom_rect(aes(xmin=8.5, xmax=10.5, ymin=-5, ymax=-0.5),
                  fill=group.colors[5], alpha=0.15) + 
        geom_rect(aes(xmin=10.5, xmax=12.5, ymin=-5, ymax=-0.5),
                  fill=group.colors[6], alpha=0.1) + 
        ## Mutational Type Labels
        annotation_custom(grob = CA,  xmin = 1, xmax = 3, ymin = -8.5, ymax = -0) + 
        annotation_custom(grob = CG,  xmin = 3, xmax = 5, ymin = -8.5, ymax = -0) + 
        annotation_custom(grob = CT,  xmin = 5, xmax = 7, ymin = -8.5, ymax = -0) + 
        annotation_custom(grob = TA,  xmin = 7, xmax = 9, ymin = -8.5, ymax = -0) + 
        annotation_custom(grob = TC,  xmin = 9, xmax = 11, ymin = -8.5, ymax = -0) + 
        annotation_custom(grob = TG,  xmin = 11, xmax = 13, ymin = -8.5, ymax = -0) + 
        ## Mutational Type p value of wilcox.test
        annotation_custom(grob = CApV,  xmin = 1.5, xmax = 3, ymin = 2 + max(sigsInputBoxplot[which(sigsInputBoxplot$Group == "C>A"), ]$mut.frac), ymax = 4 + max(sigsInputBoxplot[which(sigsInputBoxplot$Group == "C>A"), ]$mut.frac)) +
        annotation_custom(grob = CGpV,  xmin = 3.5, xmax = 5, ymin = 2 + max(sigsInputBoxplot[which(sigsInputBoxplot$Group == "C>G"), ]$mut.frac), ymax = 4 + max(sigsInputBoxplot[which(sigsInputBoxplot$Group == "C>G"), ]$mut.frac)) +
        annotation_custom(grob = CTpV,  xmin = 5.5, xmax = 7, ymin = 2 + max(sigsInputBoxplot[which(sigsInputBoxplot$Group == "C>T"), ]$mut.frac), ymax = 4 + max(sigsInputBoxplot[which(sigsInputBoxplot$Group == "C>T"), ]$mut.frac)) +
        annotation_custom(grob = TApV,  xmin = 7.5, xmax = 9, ymin = 2 + max(sigsInputBoxplot[which(sigsInputBoxplot$Group == "T>A"), ]$mut.frac), ymax = 4 + max(sigsInputBoxplot[which(sigsInputBoxplot$Group == "T>A"), ]$mut.frac)) +
        annotation_custom(grob = TCpV,  xmin = 9.5, xmax = 11, ymin = 2 + max(sigsInputBoxplot[which(sigsInputBoxplot$Group == "T>C"), ]$mut.frac), ymax = 4 + max(sigsInputBoxplot[which(sigsInputBoxplot$Group == "T>C"), ]$mut.frac)) +
        annotation_custom(grob = TGpV,  xmin = 11.5, xmax = 13, ymin = 2 + max(sigsInputBoxplot[which(sigsInputBoxplot$Group == "T>G"), ]$mut.frac), ymax = 4 + max(sigsInputBoxplot[which(sigsInputBoxplot$Group == "T>G"), ]$mut.frac))
    message("Branch-trunk plot generation done!")
    return(pic)
}


## Branches' mutation collection
.treeMutationalBranches <- function(maf.dat, branchAlias, mut_sort.id){
    ## get mutationalSigs-related  infomation
    maf_input <- maf.dat
    branchChar <- as.character(branchAlias$Branch)
    datChr <- data.frame(chr=as.character(maf_input$Chromosome), stringsAsFactors=FALSE)
    datChr$chr <- paste("chr", datChr$chr, sep="")
    datMutgene <-  maf_input$Hugo_Symbol
    mutId <- dplyr::select(tidyr::unite(maf_input, "mut.id", 
                                        Hugo_Symbol, Chromosome, 
                                        Start_Position, 
                                        Reference_Allele, Tumor_Seq_Allele2, 
                                        sep=":"), mut.id)
    mutSigRef <- data.frame(as.character(maf_input$Tumor_Sample_Barcode), 
                            datChr, maf_input$Start_Position, 
                            maf_input$End_Position, maf_input$Reference_Allele, 
                            maf_input$Tumor_Seq_Allele2, datMutgene, 
                            mutId, stringsAsFactors=FALSE)
    colnames(mutSigRef) <- c("Sample", 
                             "chr", "pos", 
                             "pos_end", "ref", 
                             "alt", "Hugo_Symbol", 
                             "mut_id")
    
    ## get branch infomation
    ls.branch <- branchChar[order(nchar(branchChar), branchChar)]
    branches <- strsplit(ls.branch, split='∩')
    
    ## generate mutational intersections for each branch
    mutBranchesOutput <- list()
    for (branch in branches){
        ## generate intersection's mut.id and get the mutation information in mutSigRef
        branch <- unlist(branch)
        ## generate the branch name
        branchName <- paste(branch, collapse="∩")
        branch.id <- append(branch, "mut.id")
        unbranch <- names(mut_sort.id)[which(!(names(mut_sort.id) %in% branch.id))]
        ## generate mutation intersection for specific branch
        branch.intersection <- dplyr::intersect(
            mut_sort.id %>% dplyr::filter_at(branch, dplyr::all_vars(. == 1)), 
            mut_sort.id %>% dplyr::filter_at(unbranch, dplyr::all_vars(. == 0))) 
        if (nrow(branch.intersection) == 0){
            message(paste(branchName, ": Mutation Intersection Missing \n", sep=""))
            next()
        }
        branch.mut.id <- branch.intersection$mut.id
        
        ## data duplication
        branch.mut <- mutSigRef[which(mutSigRef$mut_id %in% branch.mut.id), ]
        branch.mut$Sample <- branchName
        branch.mut <- branch.mut[!duplicated(branch.mut),]
        branch.mut$Alias <- as.character(branchAlias[which(branchAlias$Branch == branchName), ]$Alias)
        
        ## generate branch mutation list
        mutBranchesOutput[[branchName]] <- branch.mut
    }
    return(mutBranchesOutput)
    
}





